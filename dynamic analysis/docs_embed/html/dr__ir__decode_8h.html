---
title: "/include/dr_ir_decode.h File Reference"
layout: default
permalink: /dr__ir__decode_8h.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_43e0a1f539e00dcfa1a6bc4d4fee4fc2.html">home</a></li><li class="navelem"><a class="el" href="dir_1036706e55c22cab35bc1c58ee689f1d.html">runner</a></li><li class="navelem"><a class="el" href="dir_629f8151d55d307162ff2d619fb1783d.html">work</a></li><li class="navelem"><a class="el" href="dir_84b917e355554dd3f3793c21ab4ddcaf.html">dynamorio</a></li><li class="navelem"><a class="el" href="dir_afee7b8fe0b60d0be677a736c14882ae.html">dynamorio</a></li><li class="navelem"><a class="el" href="dir_48474711f0a4ba29d8b16b7ca2362db9.html">build_release-32</a></li><li class="navelem"><a class="el" href="dir_e77cb64d414c273b7d0ccb7a22f80058.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dr_ir_decode.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Decoding routines.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0edc97a70f3135637f5091893a19f88c"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#a0edc97a70f3135637f5091893a19f88c">decode_eflags_usage</a> (void *drcontext, byte *pc, uint *usage, <a class="el" href="dr__ir__instr_8h.html#afbf9138b89c5e6e8ea4ff2e9212b2277">dr_opnd_query_flags_t</a> flags)</td></tr>
<tr class="separator:a0edc97a70f3135637f5091893a19f88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca2a278008e547130218e8cfde44e3d"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#a5ca2a278008e547130218e8cfde44e3d">decode</a> (void *drcontext, byte *pc, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a5ca2a278008e547130218e8cfde44e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf858ce8d17c1221ea6121f1bb437348"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#abf858ce8d17c1221ea6121f1bb437348">decode_from_copy</a> (void *drcontext, byte *copy_pc, byte *orig_pc, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:abf858ce8d17c1221ea6121f1bb437348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6aecfe0f91d751f8878cadac53ad3d9"><td class="memItemLeft" align="right" valign="top">DR_API <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#af6aecfe0f91d751f8878cadac53ad3d9">decode_as_bb</a> (void *drcontext, byte *start_pc)</td></tr>
<tr class="separator:af6aecfe0f91d751f8878cadac53ad3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6681a8cffe359fd76b9ed5f83ff0e3e"><td class="memItemLeft" align="right" valign="top">DR_API <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#ad6681a8cffe359fd76b9ed5f83ff0e3e">decode_trace</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:ad6681a8cffe359fd76b9ed5f83ff0e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e88898694101828122073daf671656"><td class="memItemLeft" align="right" valign="top">DR_API byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#ab2e88898694101828122073daf671656">decode_first_opcode_byte</a> (int opcode)</td></tr>
<tr class="separator:ab2e88898694101828122073daf671656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9793c4f9a1e642ca51c059c409ad8ffd"><td class="memItemLeft" align="right" valign="top">const DR_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#a9793c4f9a1e642ca51c059c409ad8ffd">decode_opcode_name</a> (int opcode)</td></tr>
<tr class="separator:a9793c4f9a1e642ca51c059c409ad8ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aabb6bc27f7d35408028943b298be05"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#a9aabb6bc27f7d35408028943b298be05">set_x86_mode</a> (void *drcontext, bool x86)</td></tr>
<tr class="separator:a9aabb6bc27f7d35408028943b298be05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c5700e9e1ad5bd7fa6be0b02e3dc51"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#a92c5700e9e1ad5bd7fa6be0b02e3dc51">get_x86_mode</a> (void *drcontext)</td></tr>
<tr class="separator:a92c5700e9e1ad5bd7fa6be0b02e3dc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381ea062dea188809a558f9ed8613697"><td class="memItemLeft" align="right" valign="top">DR_API app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#a381ea062dea188809a558f9ed8613697">dr_app_pc_as_jump_target</a> (<a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a> isa_mode, app_pc pc)</td></tr>
<tr class="separator:a381ea062dea188809a558f9ed8613697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92be5c9424e697d06f8d96f5620084a7"><td class="memItemLeft" align="right" valign="top">DR_API app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#a92be5c9424e697d06f8d96f5620084a7">dr_app_pc_as_load_target</a> (<a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a> isa_mode, app_pc pc)</td></tr>
<tr class="separator:a92be5c9424e697d06f8d96f5620084a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d565e4e2eb9e0330181d03e69ba883"><td class="memItemLeft" align="right" valign="top">DR_API app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#ac2d565e4e2eb9e0330181d03e69ba883">decode_memory_reference_size</a> (void *drcontext, app_pc pc, uint *size_in_bytes)</td></tr>
<tr class="separator:ac2d565e4e2eb9e0330181d03e69ba883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a2c830c95757037eaa1a192a22aa3a"><td class="memItemLeft" align="right" valign="top">DR_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#af4a2c830c95757037eaa1a192a22aa3a">decode_sizeof</a> (void *drcontext, byte *pc, int *num_prefixes _IF_X86_64(uint *rip_rel_pos))</td></tr>
<tr class="separator:af4a2c830c95757037eaa1a192a22aa3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae858a4329f5eab4fd5c2562831ddc196"><td class="memItemLeft" align="right" valign="top">DR_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#ae858a4329f5eab4fd5c2562831ddc196">decode_sizeof_ex</a> (void *drcontext, byte *pc, int *num_prefixes, uint *rip_rel_pos)</td></tr>
<tr class="separator:ae858a4329f5eab4fd5c2562831ddc196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f165443f3c713182124b81656aca21"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__decode_8h.html#ab6f165443f3c713182124b81656aca21">decode_next_pc</a> (void *drcontext, byte *pc)</td></tr>
<tr class="separator:ab6f165443f3c713182124b81656aca21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Decoding routines. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5ca2a278008e547130218e8cfde44e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca2a278008e547130218e8cfde44e3d">&#9670;&nbsp;</a></span>decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* decode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes the instruction at address <code>pc</code> into <code>instr</code>, filling in the instruction's opcode, eflags usage, prefixes, and operands. The instruction's raw bits are set to valid and pointed at <code>pc</code> (xref <a class="el" href="dr__ir__instr_8h.html#adf6288f48a76fdea2523a97ec5664d87">instr_get_raw_bits()</a>). Assumes that <code>instr</code> is already initialized, but uses the x86/x64 mode for the thread <code>dcontext</code> rather than that set in instr. If caller is re-using same <a class="el" href="structinstr__t.html">instr_t</a> struct over multiple decodings, caller should call <a class="el" href="dr__ir__instr_8h.html#aaf4d287021b012cde46a3f2502dde2af">instr_reset()</a> or <a class="el" href="dr__ir__instr_8h.html#a6144a509a93c02be357c37bd66fe897a">instr_reuse()</a>. Returns the address of the next byte after the decoded instruction. Returns NULL on decoding an invalid instr and sets opcode to OP_INVALID. </p>

</div>
</div>
<a id="af6aecfe0f91d751f8878cadac53ad3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6aecfe0f91d751f8878cadac53ad3d9">&#9670;&nbsp;</a></span>decode_as_bb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a>* decode_as_bb </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>start_pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Client routine to decode instructions at an arbitrary app address, following all the rules that DynamoRIO follows internally for terminating basic blocks. Note that DynamoRIO does not validate that <code>start_pc</code> is actually the first instruction of a basic block. </p><dl class="section note"><dt>Note</dt><dd>Caller is reponsible for freeing the list and its instrs! </dd></dl>

</div>
</div>
<a id="a0edc97a70f3135637f5091893a19f88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edc97a70f3135637f5091893a19f88c">&#9670;&nbsp;</a></span>decode_eflags_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* decode_eflags_usage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#afbf9138b89c5e6e8ea4ff2e9212b2277">dr_opnd_query_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes only enough of the instruction at address <code>pc</code> to determine its eflags usage, which is returned in <code>usage</code> as EFLAGS_ constants or'ed together. Returns the address of the next byte after the decoded instruction. Returns NULL on decoding an invalid instruction. </p>

</div>
</div>
<a id="ab2e88898694101828122073daf671656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e88898694101828122073daf671656">&#9670;&nbsp;</a></span>decode_first_opcode_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte decode_first_opcode_byte </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an OP_ constant, returns the first byte of its opcode when encoded as an IA-32 instruction. </p>

</div>
</div>
<a id="abf858ce8d17c1221ea6121f1bb437348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf858ce8d17c1221ea6121f1bb437348">&#9670;&nbsp;</a></span>decode_from_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* decode_from_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>orig_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes the instruction at address <code>copy_pc</code> into <code>instr</code> as though it were located at address <code>orig_pc</code>. Any pc-relative operands have their values calculated as though the instruction were actually at <code>orig_pc</code>, though that address is never de-referenced. The instruction's raw bits are not valid, but its application address field (see <a class="el" href="dr__ir__instr_8h.html#a090b27b5334c6be542c4fcfed7b97ffb">instr_get_app_pc()</a>) is set to <code>orig_pc</code>. The instruction's opcode, eflags usage, prefixes, and operands are all filled in. Assumes that <code>instr</code> is already initialized, but uses the x86/x64 mode for the thread <code>dcontext</code> rather than that set in instr. If caller is re-using same <a class="el" href="structinstr__t.html">instr_t</a> struct over multiple decodings, caller should call <a class="el" href="dr__ir__instr_8h.html#aaf4d287021b012cde46a3f2502dde2af">instr_reset()</a> or <a class="el" href="dr__ir__instr_8h.html#a6144a509a93c02be357c37bd66fe897a">instr_reuse()</a>. Returns the address of the next byte after the decoded instruction copy at <code>copy_pc</code>. Returns NULL on decoding an invalid instr and sets opcode to OP_INVALID. </p>

</div>
</div>
<a id="ac2d565e4e2eb9e0330181d03e69ba883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d565e4e2eb9e0330181d03e69ba883">&#9670;&nbsp;</a></span>decode_memory_reference_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API app_pc decode_memory_reference_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the size, in bytes, of the memory read or write of the instr at <code>pc</code>. If the instruction is a repeating string instruction, considers only one iteration. Returns the pc of the following instruction. If the instruction at <code>pc</code> does not reference memory, or is invalid, returns NULL. </p>

</div>
</div>
<a id="ab6f165443f3c713182124b81656aca21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f165443f3c713182124b81656aca21">&#9670;&nbsp;</a></span>decode_next_pc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* decode_next_pc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes only enough of the instruction at address <code>pc</code> to determine its size. Returns the address of the byte following the instruction. May return NULL on decoding certain invalid instructions. This corresponds to a Level 1 decoding. Levels are not exposed in the API anymore, however. </p>

</div>
</div>
<a id="a9793c4f9a1e642ca51c059c409ad8ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9793c4f9a1e642ca51c059c409ad8ffd">&#9670;&nbsp;</a></span>decode_opcode_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const DR_API char* decode_opcode_name </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an OP_ constant, returns the string name of its opcode. </p>

</div>
</div>
<a id="af4a2c830c95757037eaa1a192a22aa3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a2c830c95757037eaa1a192a22aa3a">&#9670;&nbsp;</a></span>decode_sizeof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int decode_sizeof </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *num_prefixes &#160;</td>
          <td class="paramname"><em>_IF_X86_64</em>uint *rip_rel_pos&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes only enough of the instruction at address <code>pc</code> to determine its size. Returns that size. If <code>num_prefixes</code> is non-NULL, returns the number of prefix bytes.</p>
<p>On x86, if <code>rip_rel_pos</code> is non-NULL, returns the offset into the instruction of a rip-relative addressing displacement (for data only: ignores control-transfer relative addressing; use <a class="el" href="dr__ir__decode_8h.html#ae858a4329f5eab4fd5c2562831ddc196">decode_sizeof_ex()</a> for that), or 0 if none. The <code>rip_rel_pos</code> parameter is only implemented for x86, where the displacement is always 4 bytes in size.</p>
<p>May return 0 size for certain invalid instructions. </p>

</div>
</div>
<a id="ae858a4329f5eab4fd5c2562831ddc196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae858a4329f5eab4fd5c2562831ddc196">&#9670;&nbsp;</a></span>decode_sizeof_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int decode_sizeof_ex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>num_prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>rip_rel_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes only enough of the instruction at address <code>pc</code> to determine its size. Returns that size. If <code>num_prefixes</code> is non-NULL, returns the number of prefix bytes.</p>
<p>On x86, if <code>rip_rel_pos</code> is non-NULL, returns the offset into the instruction of a rip-relative addressing displacement for data or control-transfer relative addressing, or 0 if none. This is only implemented for x86, where the displacement is always 4 bytes for data but can be 1 byte for control.</p>
<p>May return 0 size for certain invalid instructions. </p>

</div>
</div>
<a id="ad6681a8cffe359fd76b9ed5f83ff0e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6681a8cffe359fd76b9ed5f83ff0e3e">&#9670;&nbsp;</a></span>decode_trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a>* decode_trace </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes the trace with tag <code>tag</code>, and returns an instrlist_t of the instructions comprising that fragment. If <code>tag</code> is not a valid tag for an existing trace, the routine returns NULL. Clients can use <a class="el" href="dr__tools_8h.html#ad390db9aee211b90323f5b06bda2e489">dr_trace_exists_at()</a> to determine whether the trace exists. </p><dl class="section note"><dt>Note</dt><dd>Unlike the instruction list presented by the trace event, the list here does not include any existing client modifications. If client-modified instructions are needed, it is the responsibility of the client to record or recreate that list itself. </dd>
<dd>
This routine does not support decoding thread-private traces created by other than the calling thread. </dd></dl>

</div>
</div>
<a id="a381ea062dea188809a558f9ed8613697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381ea062dea188809a558f9ed8613697">&#9670;&nbsp;</a></span>dr_app_pc_as_jump_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API app_pc dr_app_pc_as_jump_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a>&#160;</td>
          <td class="paramname"><em>isa_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an application program counter value, returns the corresponding value to use as an indirect branch target for the given <code>isa_mode</code>. For ARM's Thumb mode (<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa3f721209faa0616ff181a7bf207a59cc">DR_ISA_ARM_THUMB</a>), this involves setting the least significant bit of the address. </p>

</div>
</div>
<a id="a92be5c9424e697d06f8d96f5620084a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92be5c9424e697d06f8d96f5620084a7">&#9670;&nbsp;</a></span>dr_app_pc_as_load_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API app_pc dr_app_pc_as_load_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a>&#160;</td>
          <td class="paramname"><em>isa_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an application program counter value, returns the corresponding value to use as a memory load target for the given <code>isa_mode</code>, or for comparing to the application address inside a basic block or trace. For ARM's Thumb mode (<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa3f721209faa0616ff181a7bf207a59cc">DR_ISA_ARM_THUMB</a>), this involves clearing the least significant bit of the address. </p>

</div>
</div>
<a id="a92c5700e9e1ad5bd7fa6be0b02e3dc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c5700e9e1ad5bd7fa6be0b02e3dc51">&#9670;&nbsp;</a></span>get_x86_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool get_x86_mode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The decode and encode routines use a per-thread persistent flag that indicates whether to treat code as 32-bit (x86) or 64-bit (x64). This routine returns the value of that flag.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="dr__ir__encode_8h.html#ae8f9b08f90490fbeae26d12a461af084">dr_get_isa_mode()</a>. </dd></dl>

</div>
</div>
<a id="a9aabb6bc27f7d35408028943b298be05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aabb6bc27f7d35408028943b298be05">&#9670;&nbsp;</a></span>set_x86_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool set_x86_mode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>x86</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The decode and encode routines use a per-thread persistent flag that indicates whether to treat code as 32-bit (x86) or 64-bit (x64). This routine sets that flag to the indicated value and returns the old value. Be sure to restore the old value prior to any further application execution to avoid problems in mis-interpreting application code.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="dr__ir__encode_8h.html#ae796d2ff6eabe43904b17742deafd637">dr_set_isa_mode()</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:04:12 &nbsp; <img border=0 src="favicon.png">
</small></address>
