---
title: "/include/dr_ir_utils.h File Reference"
layout: default
permalink: /dr__ir__utils_8h.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_43e0a1f539e00dcfa1a6bc4d4fee4fc2.html">home</a></li><li class="navelem"><a class="el" href="dir_1036706e55c22cab35bc1c58ee689f1d.html">runner</a></li><li class="navelem"><a class="el" href="dir_629f8151d55d307162ff2d619fb1783d.html">work</a></li><li class="navelem"><a class="el" href="dir_84b917e355554dd3f3793c21ab4ddcaf.html">dynamorio</a></li><li class="navelem"><a class="el" href="dir_afee7b8fe0b60d0be677a736c14882ae.html">dynamorio</a></li><li class="navelem"><a class="el" href="dir_48474711f0a4ba29d8b16b7ca2362db9.html">build_release-32</a></li><li class="navelem"><a class="el" href="dir_e77cb64d414c273b7d0ccb7a22f80058.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dr_ir_utils.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Code transformation utilities.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a85e6559244f2fc5b84c7a07f04168bad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a85e6559244f2fc5b84c7a07f04168bad">SPILL_SLOT_REDIRECT_NATIVE_TGT</a>&#160;&#160;&#160;SPILL_SLOT_1</td></tr>
<tr class="separator:a85e6559244f2fc5b84c7a07f04168bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a89a6b714ff24d91d78589877047a29b9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> { , <br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9ae4cd78beccb2525acc61f2536ba1ea71">SPILL_SLOT_2</a> = 1, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a446ae7a7df24d2c3abae567a17289566">SPILL_SLOT_3</a> = 2, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9ab1b97fb0822126941b211160965034e4">SPILL_SLOT_4</a> = 3, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a57734b157aa48d5db278cb1aa372cd56">SPILL_SLOT_5</a> = 4, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9ac4c22f3fdbacb7b37b55484b5577f1e0">SPILL_SLOT_6</a> = 5, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9abbff886ccbde7dc9ce9bd4e379eb7ac3">SPILL_SLOT_7</a> = 6, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a6bbd68ecb5a36a22f247c5806fa5fec9">SPILL_SLOT_8</a> = 7, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9aa1bffc7b66f58d71b52284c0f49d5a53">SPILL_SLOT_9</a> = 8, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a44005b876b8364b0433f880f5b9b1a68">SPILL_SLOT_10</a> = 9, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a78ba623c508dc9db382bd16205e862c5">SPILL_SLOT_11</a> = 10, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a3bd3a0c1a09dd08a8cf3cdc99902767a">SPILL_SLOT_12</a> = 11, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a2a009fac1a98d5546313cb17b0a026a7">SPILL_SLOT_13</a> = 12, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9ace6bda60e6d81dc4914384f28d2e159e">SPILL_SLOT_14</a> = 13, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a529c3a41f0f3324929310b94915de96e">SPILL_SLOT_15</a> = 14, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a3d4436b445175a7088cd958a7e81f9b8">SPILL_SLOT_16</a> = 15, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a8483a4f53a6c380d0356a0596745ce09">SPILL_SLOT_17</a> = 16, 
<br />
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a794503b196c55da22002fc15549916fa">SPILL_SLOT_MAX</a> = SPILL_SLOT_17
<br />
 }</td></tr>
<tr class="separator:a89a6b714ff24d91d78589877047a29b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae8479716f08bbbb36d7fd27cfbbc0743"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ae8479716f08bbbb36d7fd27cfbbc0743">dr_save_reg</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr class="separator:ae8479716f08bbbb36d7fd27cfbbc0743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e9767e1ff0f426b552a5f18c528ced"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a97e9767e1ff0f426b552a5f18c528ced">dr_restore_reg</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr class="separator:a97e9767e1ff0f426b552a5f18c528ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affefddf9b8411ac527cba16269ab80e6"><td class="memItemLeft" align="right" valign="top">DR_API <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#affefddf9b8411ac527cba16269ab80e6">dr_max_opnd_accessible_spill_slot</a> (void)</td></tr>
<tr class="separator:affefddf9b8411ac527cba16269ab80e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab633296eeff7b481e148ef78aad56722"><td class="memItemLeft" align="right" valign="top">DR_API <a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ab633296eeff7b481e148ef78aad56722">dr_reg_spill_slot_opnd</a> (void *drcontext, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr class="separator:ab633296eeff7b481e148ef78aad56722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdc15ea04e8d17fa537832acf274d9c"><td class="memItemLeft" align="right" valign="top">DR_API reg_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a6fdc15ea04e8d17fa537832acf274d9c">dr_read_saved_reg</a> (void *drcontext, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr class="separator:a6fdc15ea04e8d17fa537832acf274d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178b4afb7bc059afbb92e9bee3572ca0"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a178b4afb7bc059afbb92e9bee3572ca0">dr_write_saved_reg</a> (void *drcontext, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot, reg_t value)</td></tr>
<tr class="separator:a178b4afb7bc059afbb92e9bee3572ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9f556b8175c4ac72d8e7df8295f121"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#abd9f556b8175c4ac72d8e7df8295f121">dr_save_arith_flags</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr class="separator:abd9f556b8175c4ac72d8e7df8295f121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b8fd731ecc840fcddda04c36a7eadd"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a31b8fd731ecc840fcddda04c36a7eadd">dr_restore_arith_flags</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr class="separator:a31b8fd731ecc840fcddda04c36a7eadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c579801a00ce256038664288a5f8909"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a8c579801a00ce256038664288a5f8909">dr_save_arith_flags_to_xax</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr class="separator:a8c579801a00ce256038664288a5f8909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23cd7358b39b70ece301bdc48928422"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ac23cd7358b39b70ece301bdc48928422">dr_restore_arith_flags_from_xax</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr class="separator:ac23cd7358b39b70ece301bdc48928422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bbc8b62b54f91fe2f6ab76ac71641e"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a44bbc8b62b54f91fe2f6ab76ac71641e">dr_save_arith_flags_to_reg</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:a44bbc8b62b54f91fe2f6ab76ac71641e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3164b3b86afa288c819d55a9037ec897"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a3164b3b86afa288c819d55a9037ec897">dr_restore_arith_flags_from_reg</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:a3164b3b86afa288c819d55a9037ec897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21149237893f712d90da064805a4a57"><td class="memItemLeft" align="right" valign="top">DR_API reg_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#af21149237893f712d90da064805a4a57">dr_merge_arith_flags</a> (reg_t cur_xflags, reg_t saved_xflag)</td></tr>
<tr class="separator:af21149237893f712d90da064805a4a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7b4392c68e53f807bba5791183f240"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#aab7b4392c68e53f807bba5791183f240">dr_insert_read_tls_field</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:aab7b4392c68e53f807bba5791183f240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b5104ef0d55577cee0f66bd9a0051f"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a06b5104ef0d55577cee0f66bd9a0051f">dr_insert_write_tls_field</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:a06b5104ef0d55577cee0f66bd9a0051f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8c687663c2f51e60e564ca9626acea"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a4c8c687663c2f51e60e564ca9626acea">instrlist_meta_preinsert</a> (<a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a4c8c687663c2f51e60e564ca9626acea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad513dfc5199e89c7d22a271afa692b65"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ad513dfc5199e89c7d22a271afa692b65">instrlist_meta_postinsert</a> (<a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ad513dfc5199e89c7d22a271afa692b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376024b7b2d33e3a86ec3544b80f645c"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a376024b7b2d33e3a86ec3544b80f645c">instrlist_meta_append</a> (<a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a376024b7b2d33e3a86ec3544b80f645c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d006431d6330adc66e372d99fa86e2f"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a1d006431d6330adc66e372d99fa86e2f">instrlist_meta_fault_preinsert</a> (<a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a1d006431d6330adc66e372d99fa86e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee2dc65e868a33347292adb54982c16"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a3ee2dc65e868a33347292adb54982c16">instrlist_meta_fault_postinsert</a> (<a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a3ee2dc65e868a33347292adb54982c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9818755498b60ba7713a7a064b6db53"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ad9818755498b60ba7713a7a064b6db53">instrlist_meta_fault_append</a> (<a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ad9818755498b60ba7713a7a064b6db53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df44dbe3d8dbf82e63e96741f167c64"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, void *callee, bool save_fpstate, uint num_args,...)</td></tr>
<tr class="separator:a1df44dbe3d8dbf82e63e96741f167c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175c7c2531aa70017d2fb020f93e374f"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a175c7c2531aa70017d2fb020f93e374f">dr_insert_clean_call_ex</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, void *callee, <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212">dr_cleancall_save_t</a> save_flags, uint num_args,...)</td></tr>
<tr class="separator:a175c7c2531aa70017d2fb020f93e374f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0258cfa82416ee2ba40ed73e4d4eebf7"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a0258cfa82416ee2ba40ed73e4d4eebf7">dr_insert_call</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, void *callee, uint num_args,...)</td></tr>
<tr class="separator:a0258cfa82416ee2ba40ed73e4d4eebf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4640c7ef1edbf0358ba3b315ec12fb64"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a4640c7ef1edbf0358ba3b315ec12fb64">dr_insert_call_ex</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, byte *encode_pc, void *callee, uint num_args,...)</td></tr>
<tr class="separator:a4640c7ef1edbf0358ba3b315ec12fb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537f64152425259b2deda82cee6c90c4"><td class="memItemLeft" align="right" valign="top">DR_API uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a537f64152425259b2deda82cee6c90c4">dr_prepare_for_call</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a537f64152425259b2deda82cee6c90c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86baaebf4ce92dc4a3090f293ff050e0"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a86baaebf4ce92dc4a3090f293ff050e0">dr_cleanup_after_call</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, uint sizeof_param_area)</td></tr>
<tr class="separator:a86baaebf4ce92dc4a3090f293ff050e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ec83d615512402df1a245fce917281"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a25ec83d615512402df1a245fce917281">dr_swap_to_clean_stack</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr class="separator:a25ec83d615512402df1a245fce917281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ba59e69809f491c0739ed70c20bb2e"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a05ba59e69809f491c0739ed70c20bb2e">dr_restore_app_stack</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr class="separator:a05ba59e69809f491c0739ed70c20bb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1267485b39cbef76ddc0ffd683c8830"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#aa1267485b39cbef76ddc0ffd683c8830">dr_call_on_clean_stack</a> (void *drcontext, void *(*func)(void), void *arg1, void *arg2, void *arg3, void *arg4, void *arg5, void *arg6, void *arg7, void *arg8)</td></tr>
<tr class="separator:aa1267485b39cbef76ddc0ffd683c8830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27020a55e63afdf3e053dbe4a34ab97"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#aa27020a55e63afdf3e053dbe4a34ab97">dr_insert_call_instrumentation</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee)</td></tr>
<tr class="separator:aa27020a55e63afdf3e053dbe4a34ab97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50b49843cf02a5b5f91fc6b5264cc7c"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ac50b49843cf02a5b5f91fc6b5264cc7c">dr_insert_mbr_instrumentation</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> scratch_slot)</td></tr>
<tr class="separator:ac50b49843cf02a5b5f91fc6b5264cc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5269cd8806aee4e6aa1edbb4af79c09a"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a5269cd8806aee4e6aa1edbb4af79c09a">dr_insert_cbr_instrumentation</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee)</td></tr>
<tr class="separator:a5269cd8806aee4e6aa1edbb4af79c09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf70b54e0f62baf2a7bfe3b13b55c579"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#aaf70b54e0f62baf2a7bfe3b13b55c579">dr_insert_cbr_instrumentation_ex</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee, <a class="el" href="structopnd__t.html">opnd_t</a> user_data)</td></tr>
<tr class="separator:aaf70b54e0f62baf2a7bfe3b13b55c579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94534e7600a651b001a5d3e19227895b"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a94534e7600a651b001a5d3e19227895b">dr_insert_ubr_instrumentation</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee)</td></tr>
<tr class="separator:a94534e7600a651b001a5d3e19227895b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1255b93576eb509d7fe9dfb4cfae472f"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a1255b93576eb509d7fe9dfb4cfae472f">dr_clobber_retaddr_after_read</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, ptr_uint_t value)</td></tr>
<tr class="separator:a1255b93576eb509d7fe9dfb4cfae472f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70dc8c6ccbd73b540991c5da347e65b2"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a70dc8c6ccbd73b540991c5da347e65b2">dr_mcontext_xmm_fields_valid</a> (void)</td></tr>
<tr class="separator:a70dc8c6ccbd73b540991c5da347e65b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f35e8073bbec6ba326b7c3ff2d6284"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a86f35e8073bbec6ba326b7c3ff2d6284">dr_mcontext_zmm_fields_valid</a> (void)</td></tr>
<tr class="separator:a86f35e8073bbec6ba326b7c3ff2d6284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e348b2596b8750ce3fad234ab022ced"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a9e348b2596b8750ce3fad234ab022ced">dr_get_mcontext</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *context)</td></tr>
<tr class="separator:a9e348b2596b8750ce3fad234ab022ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bfa7fc3f9d4adb0857675bec2712a2"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ac4bfa7fc3f9d4adb0857675bec2712a2">dr_set_mcontext</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *context)</td></tr>
<tr class="separator:ac4bfa7fc3f9d4adb0857675bec2712a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3aa7797e4e3ce2f741f99712bb704f5"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ac3aa7797e4e3ce2f741f99712bb704f5">dr_redirect_execution</a> (<a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *context)</td></tr>
<tr class="separator:ac3aa7797e4e3ce2f741f99712bb704f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb507c7b85501e8e52d85643c1e96a66"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#acb507c7b85501e8e52d85643c1e96a66">dr_redirect_native_target</a> (void *drcontext)</td></tr>
<tr class="separator:acb507c7b85501e8e52d85643c1e96a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e815b039d8770c7422dd16059797da8"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a7e815b039d8770c7422dd16059797da8">dr_mcontext_to_context</a> (CONTEXT *dst, <a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *src)</td></tr>
<tr class="separator:a7e815b039d8770c7422dd16059797da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303cc7b7b132b9aafb8db5abae76d45f"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a303cc7b7b132b9aafb8db5abae76d45f">instrlist_insert_mov_immed_ptrsz</a> (void *drcontext, ptr_int_t val, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> **first OUT, <a class="el" href="structinstr__t.html">instr_t</a> **last OUT)</td></tr>
<tr class="separator:a303cc7b7b132b9aafb8db5abae76d45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2861316d8857d190ac174b58c18544"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#abf2861316d8857d190ac174b58c18544">instrlist_insert_push_immed_ptrsz</a> (void *drcontext, ptr_int_t val, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> **first OUT, <a class="el" href="structinstr__t.html">instr_t</a> **last OUT)</td></tr>
<tr class="separator:abf2861316d8857d190ac174b58c18544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a42d59b54c1f768a0f8ef0c0e91c34"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a18a42d59b54c1f768a0f8ef0c0e91c34">instrlist_insert_mov_instr_addr</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *src_inst, byte *encode_estimate, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> **first OUT, <a class="el" href="structinstr__t.html">instr_t</a> **last OUT)</td></tr>
<tr class="separator:a18a42d59b54c1f768a0f8ef0c0e91c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2315a34a23b75cbaebfc97e6547b5d10"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a2315a34a23b75cbaebfc97e6547b5d10">instrlist_insert_push_instr_addr</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *src_inst, byte *encode_estimate, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> **first OUT, <a class="el" href="structinstr__t.html">instr_t</a> **last OUT)</td></tr>
<tr class="separator:a2315a34a23b75cbaebfc97e6547b5d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7af9296c9f5930b025186aea0688b13"><td class="memItemLeft" align="right" valign="top">DR_API <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ad7af9296c9f5930b025186aea0688b13">dr_get_stolen_reg</a> (void)</td></tr>
<tr class="separator:ad7af9296c9f5930b025186aea0688b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a38641e89e2573d725ec05d137e0fb6"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a7a38641e89e2573d725ec05d137e0fb6">dr_insert_get_stolen_reg_value</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:a7a38641e89e2573d725ec05d137e0fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14654096a7b89666f82e4566a7d1e4c"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#aa14654096a7b89666f82e4566a7d1e4c">dr_insert_set_stolen_reg_value</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:aa14654096a7b89666f82e4566a7d1e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f75dd89d8a188f4a7fc9ae094bceaf"><td class="memItemLeft" align="right" valign="top">DR_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ad2f75dd89d8a188f4a7fc9ae094bceaf">dr_remove_it_instrs</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist)</td></tr>
<tr class="separator:ad2f75dd89d8a188f4a7fc9ae094bceaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2c05b5d49ca8dedfd52d7bbb2f59bb"><td class="memItemLeft" align="right" valign="top">DR_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a1f2c05b5d49ca8dedfd52d7bbb2f59bb">dr_insert_it_instrs</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist)</td></tr>
<tr class="separator:a1f2c05b5d49ca8dedfd52d7bbb2f59bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23665c11b7d79a29ea185113d07944f"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#aa23665c11b7d79a29ea185113d07944f">dr_insert_save_fpstate</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structopnd__t.html">opnd_t</a> buf)</td></tr>
<tr class="separator:aa23665c11b7d79a29ea185113d07944f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74016eacf3a9cfc20a93a9ac0bca9c59"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a74016eacf3a9cfc20a93a9ac0bca9c59">dr_insert_restore_fpstate</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structopnd__t.html">opnd_t</a> buf)</td></tr>
<tr class="separator:a74016eacf3a9cfc20a93a9ac0bca9c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9038ab78f7bc0385b10ea256610022ca"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a9038ab78f7bc0385b10ea256610022ca">dr_insert_get_seg_base</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> seg, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:a9038ab78f7bc0385b10ea256610022ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Code transformation utilities. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a85e6559244f2fc5b84c7a07f04168bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e6559244f2fc5b84c7a07f04168bad">&#9670;&nbsp;</a></span>SPILL_SLOT_REDIRECT_NATIVE_TGT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPILL_SLOT_REDIRECT_NATIVE_TGT&#160;&#160;&#160;SPILL_SLOT_1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags to request non-default preservation of state in a clean call </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a89a6b714ff24d91d78589877047a29b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a6b714ff24d91d78589877047a29b9">&#9670;&nbsp;</a></span>dr_spill_slot_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enum of spill slots to use with <a class="el" href="dr__ir__utils_8h.html#ae8479716f08bbbb36d7fd27cfbbc0743">dr_save_reg()</a>, <a class="el" href="dr__ir__utils_8h.html#a97e9767e1ff0f426b552a5f18c528ced">dr_restore_reg()</a>, <a class="el" href="dr__ir__utils_8h.html#abd9f556b8175c4ac72d8e7df8295f121">dr_save_arith_flags()</a>, <a class="el" href="dr__ir__utils_8h.html#a31b8fd731ecc840fcddda04c36a7eadd">dr_restore_arith_flags()</a> and <a class="el" href="dr__ir__utils_8h.html#ac50b49843cf02a5b5f91fc6b5264cc7c">dr_insert_mbr_instrumentation()</a>. Values stored in spill slots remain valid only until the next non-meta (i.e. application) instruction. Spill slots can be accessed/modifed during clean calls and restore_state_events (see <a class="el" href="dr__events_8h.html#a46dc6ae264b5b293e889cc88ea808eab">dr_register_restore_state_event()</a>) with <a class="el" href="dr__ir__utils_8h.html#a6fdc15ea04e8d17fa537832acf274d9c">dr_read_saved_reg()</a> and <a class="el" href="dr__ir__utils_8h.html#a178b4afb7bc059afbb92e9bee3572ca0">dr_write_saved_reg()</a>.</p>
<p>Spill slots &lt;= <a class="el" href="dr__ir__utils_8h.html#affefddf9b8411ac527cba16269ab80e6">dr_max_opnd_accessible_spill_slot()</a> can be directly accessed from client inserted instructions with <a class="el" href="dr__ir__utils_8h.html#ab633296eeff7b481e148ef78aad56722">dr_reg_spill_slot_opnd()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Some spill slots may be faster to access than others. Currently spill slots 1-3 are significantly faster to access than the others when running without -thread_private. When running with -thread_private all spill slots are expected to have similar performance. This is subject to change in future releases, but clients may assume that smaller numbered spill slots are faster or the same cost to access as larger numbered spill slots.</dd>
<dd>
The number of spill slots may change in future releases. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9ae4cd78beccb2525acc61f2536ba1ea71"></a>SPILL_SLOT_2&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9a446ae7a7df24d2c3abae567a17289566"></a>SPILL_SLOT_3&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9ab1b97fb0822126941b211160965034e4"></a>SPILL_SLOT_4&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9a57734b157aa48d5db278cb1aa372cd56"></a>SPILL_SLOT_5&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9ac4c22f3fdbacb7b37b55484b5577f1e0"></a>SPILL_SLOT_6&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9abbff886ccbde7dc9ce9bd4e379eb7ac3"></a>SPILL_SLOT_7&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9a6bbd68ecb5a36a22f247c5806fa5fec9"></a>SPILL_SLOT_8&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9aa1bffc7b66f58d71b52284c0f49d5a53"></a>SPILL_SLOT_9&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9a44005b876b8364b0433f880f5b9b1a68"></a>SPILL_SLOT_10&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9a78ba623c508dc9db382bd16205e862c5"></a>SPILL_SLOT_11&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p><dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9a3bd3a0c1a09dd08a8cf3cdc99902767a"></a>SPILL_SLOT_12&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p><dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9a2a009fac1a98d5546313cb17b0a026a7"></a>SPILL_SLOT_13&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p><dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9ace6bda60e6d81dc4914384f28d2e159e"></a>SPILL_SLOT_14&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p><dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9a529c3a41f0f3324929310b94915de96e"></a>SPILL_SLOT_15&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p><dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9a3d4436b445175a7088cd958a7e81f9b8"></a>SPILL_SLOT_16&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p><dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9a8483a4f53a6c380d0356a0596745ce09"></a>SPILL_SLOT_17&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p><dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a89a6b714ff24d91d78589877047a29b9a794503b196c55da22002fc15549916fa"></a>SPILL_SLOT_MAX&#160;</td><td class="fielddoc"><p>spill slot for register save/restore routines </p><dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa1267485b39cbef76ddc0ffd683c8830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1267485b39cbef76ddc0ffd683c8830">&#9670;&nbsp;</a></span>dr_call_on_clean_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_call_on_clean_stack </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the specified function <code>func</code> after switching to the DR stack for the thread corresponding to <code>drcontext</code>. Passes in 8 arguments. Uses the C calling convention, so <code>func</code> will work just fine even if if takes fewer than 8 args. Swaps the stack back upon return and returns the value returned by <code>func</code>.</p>
<p>On Windows, this routine does swap the TEB stack fields, avoiding issues with fault handling on Windows 8.1. This means there is no need for the callee to use <a class="el" href="dr__os__utils_8h.html#a8b649488383757de1237c8caeb5f1c9b">dr_switch_to_dr_state_ex()</a> with DR_STATE_STACK_BOUNDS. </p>

</div>
</div>
<a id="a86baaebf4ce92dc4a3090f293ff050e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86baaebf4ce92dc4a3090f293ff050e0">&#9670;&nbsp;</a></span>dr_cleanup_after_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_cleanup_after_call </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>sizeof_param_area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore state after a call. </p>

</div>
</div>
<a id="a1255b93576eb509d7fe9dfb4cfae472f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1255b93576eb509d7fe9dfb4cfae472f">&#9670;&nbsp;</a></span>dr_clobber_retaddr_after_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_clobber_retaddr_after_read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_uint_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes DynamoRIO to insert code that stores <code>value</code> into the return address slot on the stack immediately after the original value is read by the return instruction <code>instr</code>. <code>instr</code> must be a return instruction or this routine will fail.</p>
<p>On ARM, <code>value</code> is ignored and instead a value that is guaranteed to not look like a return address is used. This is for efficiency reasons, as on ARM it would require an extra register spill in order to write an arbitrary value.</p>
<dl class="section note"><dt>Note</dt><dd>This is meant to make it easier to obtain efficient callstacks by eliminating stale return addresses from prior stack frames. However, it is possible that writing to the application stack could result in incorrect application behavior, so use this at your own risk.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="a9e348b2596b8750ce3fad234ab022ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e348b2596b8750ce3fad234ab022ced">&#9670;&nbsp;</a></span>dr_get_mcontext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_get_mcontext </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the fields of the current application machine context selected by the <code>flags</code> field of <code>context</code> into <code>context</code>.</p>
<p>This routine may only be called from:</p>
<ul>
<li>A clean call invoked by <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a537f64152425259b2deda82cee6c90c4">dr_prepare_for_call()</a>. If register reservation code is in use (e.g., via the drreg extension library <a class="el" href="page_drreg.html">Register Management</a>), <a class="el" href="dr__ir__utils_8h.html#a175c7c2531aa70017d2fb020f93e374f">dr_insert_clean_call_ex()</a> must be used with its flags argument including <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212a76efe3cf7cffc2bf14da79133bc2e5c3">DR_CLEANCALL_READS_APP_CONTEXT</a> (and possibly <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab3ed3f85123fad82c4377cebaa2c36ed">DR_CLEANCALL_MULTIPATH</a>)to ensure proper interaction with register reservations.</li>
<li>A pre- or post-syscall event (<a class="el" href="dr__events_8h.html#a80d0f026def74d903a83fb6122816ae2">dr_register_pre_syscall_event()</a>, <a class="el" href="dr__events_8h.html#a7a62b6c11f3b0ae2fe7773189f6e4826">dr_register_post_syscall_event()</a>)</li>
<li>Basic block or trace creation events (<a class="el" href="dr__events_8h.html#acbfe1ece2c520d409ffd59076507a710">dr_register_bb_event()</a>, <a class="el" href="dr__events_8h.html#ad47842a864b5d406e56d6ceddbab47ac">dr_register_trace_event()</a>), but for basic block creation only when the basic block callback parameters <code>for_trace</code> and <code>translating</code> are false, and for trace creation only when <code>translating</code> is false.</li>
<li>A nudge callback (<a class="el" href="dr__events_8h.html#a03da807cdb97ec8d0db68b6d24974ea4">dr_register_nudge_event()</a>) on Linux. (On Windows nudges happen in separate dedicated threads.)</li>
<li>A thread or process exit event (<a class="el" href="dr__events_8h.html#aa34d296a9e990925a096501a7d5c6596">dr_register_thread_exit_event()</a>, <a class="el" href="dr__events_8h.html#a32f38cabf4b2c554ce4e476c5d5f6f3a">dr_register_exit_event()</a>)</li>
<li>A thread init event (<a class="el" href="dr__events_8h.html#a92ad96993c826232e76a56ff43cd31d0">dr_register_thread_init_event()</a>) for all but the initial thread.</li>
<li>A kernel transfer event (<a class="el" href="dr__events_8h.html#ac433abf2a9b5ec9a5571e39d7d069df2">dr_register_kernel_xfer_event()</a>). Here the obtained context is the target context of the transfer, not the source (about to be changed) context. For Windows system call event types <a class="el" href="dr__events_8h.html#a05b0d8543956536b9938ccb6fdd89570acc7205549e58402388ed6a9a33ab9bc6">DR_XFER_CONTINUE</a> and <a class="el" href="dr__events_8h.html#a05b0d8543956536b9938ccb6fdd89570aa693b58a21b0f7f0f9a9d537c40bde62">DR_XFER_SET_CONTEXT_THREAD</a>, only the portions of the context selected by the application are available. The <code>flags</code> field of <code>context</code> is adjusted to reflect which fields were returned. Given the disparity in how Ebp/Rbp is handled (in <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4af2252e055eafe402a7bf12b9951410d8">DR_MC_INTEGER</a> but in CONTEXT_CONTROL), clients that care about that register are better off using system call events instead of kernel transfer events to take actions on these two system calls.</li>
</ul>
<p>Even when <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4ab7914092947d4a374f4a95e089870218">DR_MC_CONTROL</a> is specified, does NOT copy the pc field, except for system call events, when it will point at the post-syscall address, and kernel transfer events, when it will point to the target pc.</p>
<p>Returns false if called from the init event or the initial thread's init event; returns true otherwise (cannot distinguish whether the caller is in a clean call so it is up to the caller to ensure it is used properly).</p>
<p>The size field of <code>context</code> must be set to the size of the structure as known at compile time. If the size field is invalid, this routine will return false.</p>
<p>The flags field of <code>context</code> must be set to the desired amount of information using the dr_mcontext_flags_t values. Asking for multimedia registers incurs a higher performance cost. An invalid flags value will return false.</p>
<dl class="section note"><dt>Note</dt><dd>NUM_SIMD_SLOTS in the dr_mcontext_t.xmm array are filled in, but only if <a class="el" href="dr__ir__utils_8h.html#a70dc8c6ccbd73b540991c5da347e65b2">dr_mcontext_xmm_fields_valid()</a> returns true and <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4af3780bef723b8bf1a34eb75125f7f122">DR_MC_MULTIMEDIA</a> is set in the flags field.</dd>
<dd>
The context is the context saved at the <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a537f64152425259b2deda82cee6c90c4">dr_prepare_for_call()</a> points. It does not correct for any registers saved with <a class="el" href="dr__ir__utils_8h.html#ae8479716f08bbbb36d7fd27cfbbc0743">dr_save_reg()</a>. To access registers saved with <a class="el" href="dr__ir__utils_8h.html#ae8479716f08bbbb36d7fd27cfbbc0743">dr_save_reg()</a> from a clean call use <a class="el" href="dr__ir__utils_8h.html#a6fdc15ea04e8d17fa537832acf274d9c">dr_read_saved_reg()</a>.</dd>
<dd>
System data structures are swapped to private versions prior to invoking clean calls or client events. Use <a class="el" href="dr__os__utils_8h.html#a89abb45db2c1f35564c5fa6f6765f55f">dr_switch_to_app_state()</a> to examine the application version of system state. </dd></dl>

</div>
</div>
<a id="ad7af9296c9f5930b025186aea0688b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7af9296c9f5930b025186aea0688b13">&#9670;&nbsp;</a></span>dr_get_stolen_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> dr_get_stolen_reg </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the register that is stolen and used by DynamoRIO. Reference <a class="el" href="API_BT.html#sec_reg_stolen">Register Stolen by DynamoRIO</a> for more information. </p>

</div>
</div>
<a id="a0258cfa82416ee2ba40ed73e4d4eebf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0258cfa82416ee2ba40ed73e4d4eebf7">&#9670;&nbsp;</a></span>dr_insert_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_insert_call </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to set up the passed-in parameters, make a call to <code>callee</code>, and clean up the parameters.</p>
<p>The callee must use the standard C calling convention that matches the underlying 32-bit or 64-bit binary interface convention ("cdecl"). Other calling conventions, such as "fastcall" and "stdcall", are not supported.</p>
<p>This routine uses the existing stack. In 64-bit mode, this routine assumes that the stack pointer is currently 16-byte aligned.</p>
<p>The application state is NOT saved or restored (use <a class="el" href="dr__ir__utils_8h.html#a537f64152425259b2deda82cee6c90c4">dr_prepare_for_call()</a> and <a class="el" href="dr__ir__utils_8h.html#a86baaebf4ce92dc4a3090f293ff050e0">dr_cleanup_after_call()</a>, or replace this routine with <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a>). The parameter set-up may write to registers if the calling convention so dictates. The registers are NOT saved beforehand (to do so, use <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a>).</p>
<p>It is up to the caller of this routine to preserve any caller-saved registers that the callee might modify.</p>
<p>DR does not support translating a fault in an argument. For fault transparency, the client must perform the translation (see <a class="el" href="dr__events_8h.html#a46dc6ae264b5b293e889cc88ea808eab">dr_register_restore_state_event()</a>), or use <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a>.</p>
<p>For 64-bit, for purposes of reachability, this call is assumed to be destined for encoding into DR's code cache-reachable memory region. This includes the code cache as well as memory allocated with <a class="el" href="dr__tools_8h.html#a18d391b20559c1737c795f2ef1ba33d2">dr_thread_alloc()</a>, <a class="el" href="dr__tools_8h.html#a82f6546fc3e259e64493aeda5a8f1c86">dr_global_alloc()</a>, <a class="el" href="dr__tools_8h.html#a917384359d5efd538976402ff4b08aae">dr_nonheap_alloc()</a>, or <a class="el" href="dr__tools_8h.html#a527e0746207909580b705f1743537921">dr_custom_alloc()</a> with <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ab33a2e990410bf314bdebe6a25aa06e1">DR_ALLOC_CACHE_REACHABLE</a>. The call used here will be direct if it is reachable from those locations; if it is not reachable, an indirect call through r11 will be used (with r11's contents being clobbered). Use <a class="el" href="dr__ir__utils_8h.html#a4640c7ef1edbf0358ba3b315ec12fb64">dr_insert_call_ex()</a> when encoding to a location other than DR's regular code region.</p>
<dl class="section note"><dt>Note</dt><dd>This routine only supports passing arguments that are integers or pointers of a size equal to the register size: i.e., no floating-point, multimedia, or aggregate data types. The routine also supports immediate integers that are smaller than the register size, and for 64-bit mode registers or memory references that are OPSZ_4.</dd>
<dd>
For 64-bit mode, passing arguments that use calling convention registers (for Windows, RCX, RDX, R8, R9; for Linux, RDI, RSI, RDX, RCX, R8 and R9) are supported but may incur additional stack usage.</dd>
<dd>
For 64-bit mode, if a 32-bit immediate integer is specified as an argument and it has its top bit set, we assume it is intended to be sign-extended to 64-bits; otherwise we zero-extend it.</dd>
<dd>
For 64-bit mode, variable-sized argument operands may not work properly.</dd>
<dd>
Arguments that reference DR_REG_XSP are not supported in 64-bit mode. </dd></dl>

</div>
</div>
<a id="a4640c7ef1edbf0358ba3b315ec12fb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4640c7ef1edbf0358ba3b315ec12fb64">&#9670;&nbsp;</a></span>dr_insert_call_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_insert_call_ex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>encode_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__ir__utils_8h.html#a0258cfa82416ee2ba40ed73e4d4eebf7">dr_insert_call()</a> except it takes in <code>encode_pc</code> indicating roughly where the call sequence will be encoded. If <code>callee</code> is not reachable from <code>encode_pc</code> plus or minus one page, an indirect call will be used instead of the direct call used by <a class="el" href="dr__ir__utils_8h.html#a0258cfa82416ee2ba40ed73e4d4eebf7">dr_insert_call()</a>. The indirect call overwrites the r11 register.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the inserted call is direct and false if indirect. </dd></dl>

</div>
</div>
<a id="aa27020a55e63afdf3e053dbe4a34ab97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27020a55e63afdf3e053dbe4a34ab97">&#9670;&nbsp;</a></span>dr_insert_call_instrumentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_insert_call_instrumentation </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> is a near call. Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing two arguments:</p><ol type="1">
<li>address of call instruction (caller)</li>
<li>target address of call (callee) <dl class="section note"><dt>Note</dt><dd>Sets <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212a76efe3cf7cffc2bf14da79133bc2e5c3">DR_CLEANCALL_READS_APP_CONTEXT</a> and <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab0fb37c5cbbd2c2cd9ebd9eb5e53f23e">DR_CLEANCALL_WRITES_APP_CONTEXT</a>. Conditionally skipping the instrumentation inserted by this routine is not supported (i.e., <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab3ed3f85123fad82c4377cebaa2c36ed">DR_CLEANCALL_MULTIPATH</a> is not supported here). </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a5269cd8806aee4e6aa1edbb4af79c09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5269cd8806aee4e6aa1edbb4af79c09a">&#9670;&nbsp;</a></span>dr_insert_cbr_instrumentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_insert_cbr_instrumentation </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> is a conditional branch Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing three arguments:</p><ol type="1">
<li>address of branch instruction</li>
<li>target address of branch</li>
<li>0 if the branch is not taken, 1 if it is taken <dl class="section note"><dt>Note</dt><dd>Sets <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212a76efe3cf7cffc2bf14da79133bc2e5c3">DR_CLEANCALL_READS_APP_CONTEXT</a> and <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab0fb37c5cbbd2c2cd9ebd9eb5e53f23e">DR_CLEANCALL_WRITES_APP_CONTEXT</a>. Conditionally skipping the instrumentation inserted by this routine is not supported (i.e., <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab3ed3f85123fad82c4377cebaa2c36ed">DR_CLEANCALL_MULTIPATH</a> is not supported here). </dd></dl>
</li>
</ol>

</div>
</div>
<a id="aaf70b54e0f62baf2a7bfe3b13b55c579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf70b54e0f62baf2a7bfe3b13b55c579">&#9670;&nbsp;</a></span>dr_insert_cbr_instrumentation_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_insert_cbr_instrumentation_ex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> is a conditional branch Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing four arguments:</p><ol type="1">
<li>address of branch instruction</li>
<li>target address of branch</li>
<li>fall-through address of branch</li>
<li>0 if the branch is not taken, 1 if it is taken</li>
<li>user defined operand (e.g., TLS slot, immed value, register, etc.) <dl class="section note"><dt>Note</dt><dd>The user defined operand cannot use register ebx! </dd>
<dd>
Sets <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212a76efe3cf7cffc2bf14da79133bc2e5c3">DR_CLEANCALL_READS_APP_CONTEXT</a> and <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab0fb37c5cbbd2c2cd9ebd9eb5e53f23e">DR_CLEANCALL_WRITES_APP_CONTEXT</a>. Conditionally skipping the instrumentation inserted by this routine is not supported (i.e., <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab3ed3f85123fad82c4377cebaa2c36ed">DR_CLEANCALL_MULTIPATH</a> is not supported here). </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a1df44dbe3d8dbf82e63e96741f167c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df44dbe3d8dbf82e63e96741f167c64">&#9670;&nbsp;</a></span>dr_insert_clean_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_insert_clean_call </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_fpstate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save state for a call, switch to this thread's DR stack, set up the passed-in parameters, make a call to <code>callee</code>, clean up the parameters, and then restore the saved state.</p>
<p>The callee must use the standard C calling convention that matches the underlying 32-bit or 64-bit binary interface convention ("cdecl"). Other calling conventions, such as "fastcall" and "stdcall", are not supported.</p>
<p>This routine expects to be passed a number of arguments beyond <code>num_args</code> equal to the value of <code>num_args</code>. Each of those arguments is a parameter to pass to the clean call, in the order passed to this routine. Each argument should be of type <a class="el" href="structopnd__t.html">opnd_t</a> and will be copied into the proper location for that argument slot as specified by the calling convention.</p>
<p>Stores the application state information on the DR stack, where it can be accessed from <code>callee</code> using <a class="el" href="dr__ir__utils_8h.html#a9e348b2596b8750ce3fad234ab022ced">dr_get_mcontext()</a> and modified using <a class="el" href="dr__ir__utils_8h.html#ac4bfa7fc3f9d4adb0857675bec2712a2">dr_set_mcontext()</a>. However, if register reservation code is in use (e.g., via the drreg extension library: <a class="el" href="page_drreg.html">Register Management</a>), <a class="el" href="dr__ir__utils_8h.html#a175c7c2531aa70017d2fb020f93e374f">dr_insert_clean_call_ex()</a> must be called with its flags argument including <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212a76efe3cf7cffc2bf14da79133bc2e5c3">DR_CLEANCALL_READS_APP_CONTEXT</a> (for <a class="el" href="dr__ir__utils_8h.html#a9e348b2596b8750ce3fad234ab022ced">dr_get_mcontext()</a> use) and/or <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab0fb37c5cbbd2c2cd9ebd9eb5e53f23e">DR_CLEANCALL_WRITES_APP_CONTEXT</a> (for <a class="el" href="dr__ir__utils_8h.html#ac4bfa7fc3f9d4adb0857675bec2712a2">dr_set_mcontext()</a> use) (and possibly <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab3ed3f85123fad82c4377cebaa2c36ed">DR_CLEANCALL_MULTIPATH</a>) to ensure proper interaction with register reservations.</p>
<p>On x86, if <code>save_fpstate</code> is true, preserves the x87 floating-point and MMX state on the DR stack. Note that it is relatively expensive to save this state (on the order of 200 cycles) and that it typically takes 512 bytes to store it (see <a class="el" href="dr__proc_8h.html#aadb44c42bd9051b210f7016089c7f89c">proc_fpstate_save_size()</a>). The last floating-point instruction address in the saved state is left in an untranslated state (i.e., it may point into the code cache). This optional floating-point state preservation is specific to x87; floating-point values in XMM, YMM, or ZMM registers, or any SIMD register on any non-x86 architecture, are always preserved. Thus, on ARM/AArch64, <code>save_fpstate</code> is ignored.</p>
<p>DR does support translating a fault in an argument (e.g., an argument that references application memory); such a fault will be treated as an application exception.</p>
<p>The clean call sequence will be optimized based on the runtime option <a class="el" href="page_deploy.html#op_cleancall">-opt_cleancall</a>.</p>
<p>For 64-bit, for purposes of reachability, this call is assumed to be destined for encoding into DR's code cache-reachable memory region. This includes the code cache as well as memory allocated with <a class="el" href="dr__tools_8h.html#a18d391b20559c1737c795f2ef1ba33d2">dr_thread_alloc()</a>, <a class="el" href="dr__tools_8h.html#a82f6546fc3e259e64493aeda5a8f1c86">dr_global_alloc()</a>, <a class="el" href="dr__tools_8h.html#a917384359d5efd538976402ff4b08aae">dr_nonheap_alloc()</a>, or <a class="el" href="dr__tools_8h.html#a527e0746207909580b705f1743537921">dr_custom_alloc()</a> with <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ab33a2e990410bf314bdebe6a25aa06e1">DR_ALLOC_CACHE_REACHABLE</a>. The call used here will be direct if it is reachable from those locations; if it is not reachable, an indirect call through r11 will be used (with r11's contents being clobbered). Use <a class="el" href="dr__ir__utils_8h.html#a175c7c2531aa70017d2fb020f93e374f">dr_insert_clean_call_ex()</a> with <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212a9fe53fc77afb460ba31666995df5b6c9">DR_CLEANCALL_INDIRECT</a> to ensure reachability when encoding to a location other than DR's regular code region. See also <a class="el" href="dr__ir__utils_8h.html#a4640c7ef1edbf0358ba3b315ec12fb64">dr_insert_call_ex()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The stack used to save state and call <code>callee</code> is limited to 20KB by default; this can be changed with the -stack_size DR runtime parameter. This stack cannot be used to store state that persists beyond <code>callee's</code> return point.</dd>
<dd>
This routine only supports passing arguments that are integers or pointers of a size equal to the register size: i.e., no floating-point, multimedia, or aggregate data types. The routine also supports immediate integers that are smaller than the register size, and for 64-bit mode registers or memory references that are OPSZ_4.</dd>
<dd>
For 64-bit mode, passing arguments that use calling convention registers (for Windows, RCX, RDX, R8, R9; for Linux, RDI, RSI, RDX, RCX, R8 and R9) are supported but may incur additional stack usage.</dd>
<dd>
For 64-bit mode, if a 32-bit immediate integer is specified as an argument and it has its top bit set, we assume it is intended to be sign-extended to 64-bits; otherwise we zero-extend it.</dd>
<dd>
For 64-bit mode, variable-sized argument operands may not work properly.</dd>
<dd>
Arguments that reference sub-register portions of DR_REG_XSP are not supported (full DR_REG_XSP is supported). </dd></dl>

</div>
</div>
<a id="a175c7c2531aa70017d2fb020f93e374f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175c7c2531aa70017d2fb020f93e374f">&#9670;&nbsp;</a></span>dr_insert_clean_call_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_insert_clean_call_ex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212">dr_cleancall_save_t</a>&#160;</td>
          <td class="paramname"><em>save_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a> except it takes in <code>save_flags</code> which allows requests to not save certain state. This is intended for use at application call entry points or other contexts where a client is comfortable making assumptions. Keep in mind that any register that is not saved will not be present in a context obtained from <a class="el" href="dr__ir__utils_8h.html#a9e348b2596b8750ce3fad234ab022ced">dr_get_mcontext()</a>. </p>

</div>
</div>
<a id="a9038ab78f7bc0385b10ea256610022ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9038ab78f7bc0385b10ea256610022ca">&#9670;&nbsp;</a></span>dr_insert_get_seg_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_insert_get_seg_base </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert code to get the segment base address pointed to by seg into register reg. In Linux, it is only supported with -mangle_app_seg option. In Windows, it only supports getting base address of the TLS segment.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="a7a38641e89e2573d725ec05d137e0fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a38641e89e2573d725ec05d137e0fb6">&#9670;&nbsp;</a></span>dr_insert_get_stolen_reg_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_insert_get_stolen_reg_value </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert code to get the application value of the register stolen by DynamoRIO into register <code>reg</code>. Reference <a class="el" href="API_BT.html#sec_reg_stolen">Register Stolen by DynamoRIO</a> for more information.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>ARM-only </dd></dl>

</div>
</div>
<a id="a1f2c05b5d49ca8dedfd52d7bbb2f59bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2c05b5d49ca8dedfd52d7bbb2f59bb">&#9670;&nbsp;</a></span>dr_insert_it_instrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int dr_insert_it_instrs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts enough OP_it instructions with proper parameters into <code>ilist</code> to make all predicated instructions in <code>ilist</code> legal in Thumb mode (<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa3f721209faa0616ff181a7bf207a59cc">DR_ISA_ARM_THUMB</a>). Treats predicated app and tool instructions identically, but marks inserted OP_it instructions as app instructions (see <a class="el" href="dr__ir__instr_8h.html#a2da69830f468c9a25f82c0561f44cfd7">instr_set_app()</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>the number of OP_it instructions inserted; -1 on error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>ARM-only </dd></dl>

</div>
</div>
<a id="ac50b49843cf02a5b5f91fc6b5264cc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50b49843cf02a5b5f91fc6b5264cc7c">&#9670;&nbsp;</a></span>dr_insert_mbr_instrumentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_insert_mbr_instrumentation </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>scratch_slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> is an indirect branch. Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing two arguments:</p><ol type="1">
<li>address of branch instruction</li>
<li>target address of branch <dl class="section note"><dt>Note</dt><dd>Only the address portion of a far indirect branch is considered. </dd>
<dd>
<code>scratch_slot</code> must be &lt;= <a class="el" href="dr__ir__utils_8h.html#affefddf9b8411ac527cba16269ab80e6">dr_max_opnd_accessible_spill_slot()</a>. <code>scratch_slot</code> is used internally to this routine and will be clobbered. </dd>
<dd>
Sets <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212a76efe3cf7cffc2bf14da79133bc2e5c3">DR_CLEANCALL_READS_APP_CONTEXT</a> and <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab0fb37c5cbbd2c2cd9ebd9eb5e53f23e">DR_CLEANCALL_WRITES_APP_CONTEXT</a>. Conditionally skipping the instrumentation inserted by this routine is not supported (i.e., <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab3ed3f85123fad82c4377cebaa2c36ed">DR_CLEANCALL_MULTIPATH</a> is not supported here). </dd></dl>
</li>
</ol>

</div>
</div>
<a id="aab7b4392c68e53f807bba5791183f240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7b4392c68e53f807bba5791183f240">&#9670;&nbsp;</a></span>dr_insert_read_tls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_insert_read_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to read into the general-purpose full-size register <code>reg</code> from the user-controlled drcontext field for this thread. Reads from the same field as <a class="el" href="dr__tools_8h.html#aaa04a14c2cbf783b4926c2fd14445f82">dr_get_tls_field()</a>. </p>

</div>
</div>
<a id="a74016eacf3a9cfc20a93a9ac0bca9c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74016eacf3a9cfc20a93a9ac0bca9c59">&#9670;&nbsp;</a></span>dr_insert_restore_fpstate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_insert_restore_fpstate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore the x87 floating point state from the 16-byte-aligned buffer referred to by buf, which must be 512 bytes for processors with the FXSR feature, and 108 bytes for those without (where this routine does not support 16-bit operand sizing). <code>buf</code> should have size of OPSZ_512; this routine will automatically adjust it to OPSZ_108 if necessary. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="dr__proc_8h.html#aadb44c42bd9051b210f7016089c7f89c">proc_fpstate_save_size()</a> can be used to determine the particular size needed.</dd></dl>
<p>When the FXSR feature is present, the fxsave format matches the bitwidth of the ISA mode of the current thread (see <a class="el" href="dr__ir__encode_8h.html#ae8f9b08f90490fbeae26d12a461af084">dr_get_isa_mode()</a>). </p>

</div>
</div>
<a id="aa23665c11b7d79a29ea185113d07944f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23665c11b7d79a29ea185113d07944f">&#9670;&nbsp;</a></span>dr_insert_save_fpstate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_insert_save_fpstate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the x87 floating point state into the 16-byte-aligned buffer referred to by <code>buf</code>, which must be 512 bytes for processors with the FXSR feature, and 108 bytes for those without (where this routine does not support 16-bit operand sizing). <code>buf</code> should have size of OPSZ_512; this routine will automatically adjust it to OPSZ_108 if necessary. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="dr__proc_8h.html#aadb44c42bd9051b210f7016089c7f89c">proc_fpstate_save_size()</a> can be used to determine the particular size needed.</dd></dl>
<p>When the FXSR feature is present, the fxsave format matches the bitwidth of the ISA mode of the current thread (see <a class="el" href="dr__ir__encode_8h.html#ae8f9b08f90490fbeae26d12a461af084">dr_get_isa_mode()</a>).</p>
<p>The last floating-point instruction address is left in an untranslated state (i.e., it may point into the code cache). </p>

</div>
</div>
<a id="aa14654096a7b89666f82e4566a7d1e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14654096a7b89666f82e4566a7d1e4c">&#9670;&nbsp;</a></span>dr_insert_set_stolen_reg_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_insert_set_stolen_reg_value </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert code to set the value of register <code>reg</code> as the application value of the register stolen by DynamoRIO Reference <a class="el" href="API_BT.html#sec_reg_stolen">Register Stolen by DynamoRIO</a> for more information.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>ARM-only </dd></dl>

</div>
</div>
<a id="a94534e7600a651b001a5d3e19227895b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94534e7600a651b001a5d3e19227895b">&#9670;&nbsp;</a></span>dr_insert_ubr_instrumentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_insert_ubr_instrumentation </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> is a direct, near, unconditional branch. Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing two arguments:</p><ol type="1">
<li>address of branch instruction</li>
<li>target address of branch</li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd>Basic block eliding is controlled by -max_elide_jmp. If that option is set to non-zero, ubrs may never be seen. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sets <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212a76efe3cf7cffc2bf14da79133bc2e5c3">DR_CLEANCALL_READS_APP_CONTEXT</a> and <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab0fb37c5cbbd2c2cd9ebd9eb5e53f23e">DR_CLEANCALL_WRITES_APP_CONTEXT</a>. Conditionally skipping the instrumentation inserted by this routine is not supported (i.e., <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab3ed3f85123fad82c4377cebaa2c36ed">DR_CLEANCALL_MULTIPATH</a> is not supported here). </dd></dl>

</div>
</div>
<a id="a06b5104ef0d55577cee0f66bd9a0051f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b5104ef0d55577cee0f66bd9a0051f">&#9670;&nbsp;</a></span>dr_insert_write_tls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_insert_write_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to write the general-purpose full-size register <code>reg</code> to the user-controlled drcontext field for this thread. Writes to the same field as <a class="el" href="dr__tools_8h.html#a534b38808801da50be64b9f0e6c8616f">dr_set_tls_field()</a>. </p>

</div>
</div>
<a id="affefddf9b8411ac527cba16269ab80e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affefddf9b8411ac527cba16269ab80e6">&#9670;&nbsp;</a></span>dr_max_opnd_accessible_spill_slot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> dr_max_opnd_accessible_spill_slot </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the largest dr_spill_slot_t that can be accessed with an <a class="el" href="structopnd__t.html">opnd_t</a> from <a class="el" href="dr__ir__utils_8h.html#ab633296eeff7b481e148ef78aad56722">dr_reg_spill_slot_opnd()</a>. </p>

</div>
</div>
<a id="a7e815b039d8770c7422dd16059797da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e815b039d8770c7422dd16059797da8">&#9670;&nbsp;</a></span>dr_mcontext_to_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_mcontext_to_context </td>
          <td>(</td>
          <td class="paramtype">CONTEXT *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the machine state in <code>src</code> into <code>dst</code>. Sets the <code>ContextFlags</code> field of <code>dst</code> to reflect the <code>flags</code> field of <code>src</code>. However, CONTEXT_CONTROL includes Ebp/Rbp, while that's under <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4af2252e055eafe402a7bf12b9951410d8">DR_MC_INTEGER</a>, so we recommend always setting both <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4af2252e055eafe402a7bf12b9951410d8">DR_MC_INTEGER</a> and <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4ab7914092947d4a374f4a95e089870218">DR_MC_CONTROL</a> when calling this routine.</p>
<p>It is up to the caller to ensure that <code>dst</code> is allocated and initialized properly in order to contain multimedia processor state, if <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4af3780bef723b8bf1a34eb75125f7f122">DR_MC_MULTIMEDIA</a> is set in the <code>flags</code> field of <code>src</code>.</p>
<p>The current segment register values are filled in under the assumption that this context is for the calling thread.</p>
<dl class="section note"><dt>Note</dt><dd>floating-point values are not filled in for <code>dst</code>. </dd>
<dd>
Windows only.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if unsuccessful; if successful, does not return. </dd></dl>

</div>
</div>
<a id="a70dc8c6ccbd73b540991c5da347e65b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70dc8c6ccbd73b540991c5da347e65b2">&#9670;&nbsp;</a></span>dr_mcontext_xmm_fields_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_mcontext_xmm_fields_valid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the simd fields in dr_mcontext_t are valid xmm, ymm, or zmm values (i.e., whether the underlying processor supports SSE). </p><dl class="section note"><dt>Note</dt><dd>If <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4af3780bef723b8bf1a34eb75125f7f122">DR_MC_MULTIMEDIA</a> is not specified when calling <a class="el" href="dr__ir__utils_8h.html#a9e348b2596b8750ce3fad234ab022ced">dr_get_mcontext()</a>, the simd fields will not be filled in regardless of the return value of this routine. </dd></dl>

</div>
</div>
<a id="a86f35e8073bbec6ba326b7c3ff2d6284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f35e8073bbec6ba326b7c3ff2d6284">&#9670;&nbsp;</a></span>dr_mcontext_zmm_fields_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_mcontext_zmm_fields_valid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the simd fields in dr_mcontext_t are valid zmm values (i.e., whether the underlying processor and OS support AVX-512 and AVX-512 code is present). </p><dl class="section note"><dt>Note</dt><dd>If <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4af3780bef723b8bf1a34eb75125f7f122">DR_MC_MULTIMEDIA</a> is not specified when calling <a class="el" href="dr__ir__utils_8h.html#a9e348b2596b8750ce3fad234ab022ced">dr_get_mcontext()</a>, the simd fields will not be filled in regardless of the return value of this routine. </dd></dl>

</div>
</div>
<a id="af21149237893f712d90da064805a4a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21149237893f712d90da064805a4a57">&#9670;&nbsp;</a></span>dr_merge_arith_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API reg_t dr_merge_arith_flags </td>
          <td>(</td>
          <td class="paramtype">reg_t&#160;</td>
          <td class="paramname"><em>cur_xflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&#160;</td>
          <td class="paramname"><em>saved_xflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience routine to aid restoring the arith flags done by outlined code, such as when handling restore state events. The routine takes the current value of the flags register <code>cur_xflags</code>, as well as the saved value <code>saved_xflag</code>, in order to return the original app value. </p>

</div>
</div>
<a id="a537f64152425259b2deda82cee6c90c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537f64152425259b2deda82cee6c90c4">&#9670;&nbsp;</a></span>dr_prepare_for_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API uint dr_prepare_for_call </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save state for a call. Stores the application state information on the DR stack. Returns the size of the data stored on the DR stack (in case the caller needs to align the stack pointer).</p>
<dl class="section warning"><dt>Warning</dt><dd>On x86, this routine does NOT save the x87 floating-point or MMX state: to do that the instrumentation routine should call <a class="el" href="dr__proc_8h.html#a48ca3205c37d6e41d007ac54a1d60e6a">proc_save_fpstate()</a> to save and then <a class="el" href="dr__proc_8h.html#aacb849daecc3021e451d9441b26cc814">proc_restore_fpstate()</a> to restore (or use <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The preparation modifies the DR_REG_XSP and DR_REG_XAX registers (after saving them). Use <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a> instead if an argument to the subsequent call that references DR_REG_XAX is desired.</dd>
<dd>
The stack used to save the state is limited to 20KB by default; this can be changed with the -stack_size DR runtime parameter. This stack cannot be used to store state that persists beyond a single clean call, code cache execution, or probe callback function execution. </dd></dl>

</div>
</div>
<a id="a6fdc15ea04e8d17fa537832acf274d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdc15ea04e8d17fa537832acf274d9c">&#9670;&nbsp;</a></span>dr_read_saved_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API reg_t dr_read_saved_reg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Can be used from a clean call or a restore_state_event (see <a class="el" href="dr__events_8h.html#a46dc6ae264b5b293e889cc88ea808eab">dr_register_restore_state_event()</a>) to see the value saved in spill slot <code>slot</code> by <a class="el" href="dr__ir__utils_8h.html#ae8479716f08bbbb36d7fd27cfbbc0743">dr_save_reg()</a>. </p>

</div>
</div>
<a id="ac3aa7797e4e3ce2f741f99712bb704f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3aa7797e4e3ce2f741f99712bb704f5">&#9670;&nbsp;</a></span>dr_redirect_execution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_redirect_execution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately resumes application execution from a clean call out of the cache (see <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a537f64152425259b2deda82cee6c90c4">dr_prepare_for_call()</a>) or an exception event with the state specified in <code>mcontext</code> (including pc, and including the xmm fields that are valid according to <a class="el" href="dr__ir__utils_8h.html#a70dc8c6ccbd73b540991c5da347e65b2">dr_mcontext_xmm_fields_valid()</a>). The flags field of <code>context</code> must contain DR_MC_ALL; using a partial set of fields is not suported.</p>
<p>For 32-bit ARM, be sure to use <a class="el" href="dr__ir__decode_8h.html#a381ea062dea188809a558f9ed8613697">dr_app_pc_as_jump_target()</a> to properly set the ISA mode for the continuation pc if it was obtained from <a class="el" href="dr__ir__instr_8h.html#a090b27b5334c6be542c4fcfed7b97ffb">instr_get_app_pc()</a> or a similar source rather than from <a class="el" href="dr__modules_8h.html#acb571b80307fd90538cb006725ab6183">dr_get_proc_address()</a>. This will set the least significant bit of the mcontext pc field to 1 when in Thumb mode (<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa3f721209faa0616ff181a7bf207a59cc">DR_ISA_ARM_THUMB</a>), <a class="el" href="API_BT.html#sec_thumb">Thumb Mode Addresses</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="dr__ir__utils_8h.html#a9e348b2596b8750ce3fad234ab022ced">dr_get_mcontext()</a> can be used to get the register state (except pc) saved in <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a537f64152425259b2deda82cee6c90c4">dr_prepare_for_call()</a>.</dd>
<dd>
If x87 floating point state was saved by <a class="el" href="dr__ir__utils_8h.html#a537f64152425259b2deda82cee6c90c4">dr_prepare_for_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a> it is not restored (other than the valid xmm fields according to <a class="el" href="dr__ir__utils_8h.html#a70dc8c6ccbd73b540991c5da347e65b2">dr_mcontext_xmm_fields_valid()</a>, if <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4af3780bef723b8bf1a34eb75125f7f122">DR_MC_MULTIMEDIA</a> is specified in the flags field). The caller should instead manually save and restore the floating point state with <a class="el" href="dr__proc_8h.html#a48ca3205c37d6e41d007ac54a1d60e6a">proc_save_fpstate()</a> and <a class="el" href="dr__proc_8h.html#aacb849daecc3021e451d9441b26cc814">proc_restore_fpstate()</a> if necessary.</dd>
<dd>
If the caller wishes to set any other state (such as xmm registers that are not part of the mcontext) they may do so by just setting that state in the current thread before making this call. To set system data structures, use <a class="el" href="dr__os__utils_8h.html#a89abb45db2c1f35564c5fa6f6765f55f">dr_switch_to_app_state()</a>, make the changes, and then switch back with <a class="el" href="dr__os__utils_8h.html#a3f08638719a695bcb95d101a03cfd8f3">dr_switch_to_dr_state()</a> before calling this routine.</dd>
<dd>
This routine may only be called from a clean call from the cache. It can not be called from any registered event callback except the exception event (<a class="el" href="dr__events_8h.html#a36fc1b4f973393d861c7740cda6c0002">dr_register_exception_event()</a>). From a signal event callback, use the <a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33a866dcc1af9f9076edcbed9c8afb17e93">DR_SIGNAL_REDIRECT</a> return value rather than calling this routine.</dd>
<dd>
If control is being redirected to a new pc (determined using drsyms, dr_get_proc_address, or any other way) ensure that the app state (such as the register values) are set as expected by the transfer point.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if unsuccessful; if successful, does not return. </dd></dl>

</div>
</div>
<a id="acb507c7b85501e8e52d85643c1e96a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb507c7b85501e8e52d85643c1e96a66">&#9670;&nbsp;</a></span>dr_redirect_native_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* dr_redirect_native_target </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the target to use for a native context transfer to a target application address.</p>
<p>Normally, redirection is performed from a client context in a clean call or event callback by invoking <a class="el" href="dr__ir__utils_8h.html#ac3aa7797e4e3ce2f741f99712bb704f5">dr_redirect_execution()</a>. In some circumstances, redirection from an application (or "native") context is desirable without creating an application control transfer in a basic block.</p>
<p>To accomplish such a redirection, store the target application address in <a class="el" href="dr__ir__utils_8h.html#a85e6559244f2fc5b84c7a07f04168bad">SPILL_SLOT_REDIRECT_NATIVE_TGT</a> by calling <a class="el" href="dr__ir__utils_8h.html#a178b4afb7bc059afbb92e9bee3572ca0">dr_write_saved_reg()</a>. Set up any other application state as desired directly in the current machine context. Then jump to the target returned by this routine. By default, the target is global and can be cached globally. However, if traces are thread-private, or if traces are disabled and basic blocks are thread-private, there will be a separate target per <code>drcontext</code>.</p>
<p>If a basic block is exited via such a redirection, the block should be emitted with the flag DR_EMIT_MUST_END_TRACE in order to avoid trace building errors.</p>
<p>For ARM, the address returned by this routine has its least significant bit set to 1 if the target is Thumb.</p>
<p>Returns null on error. </p>

</div>
</div>
<a id="ab633296eeff7b481e148ef78aad56722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab633296eeff7b481e148ef78aad56722">&#9670;&nbsp;</a></span>dr_reg_spill_slot_opnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API <a class="el" href="structopnd__t.html">opnd_t</a> dr_reg_spill_slot_opnd </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an <a class="el" href="structopnd__t.html">opnd_t</a> that directly accesses the spill slot <code>slot</code>. Only slots &lt;= <a class="el" href="dr__ir__utils_8h.html#affefddf9b8411ac527cba16269ab80e6">dr_max_opnd_accessible_spill_slot()</a> can be used with this routine. </p><dl class="section note"><dt>Note</dt><dd><code>slot</code> must be &lt;= <a class="el" href="dr__ir__utils_8h.html#affefddf9b8411ac527cba16269ab80e6">dr_max_opnd_accessible_spill_slot()</a> </dd></dl>

</div>
</div>
<a id="ad2f75dd89d8a188f4a7fc9ae094bceaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f75dd89d8a188f4a7fc9ae094bceaf">&#9670;&nbsp;</a></span>dr_remove_it_instrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int dr_remove_it_instrs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all OP_it instructions from <code>ilist</code> without changing the instructions that were inside each IT block. This is intended to be paired with <a class="el" href="dr__ir__utils_8h.html#a1f2c05b5d49ca8dedfd52d7bbb2f59bb">dr_insert_it_instrs()</a>, where a client's examination of the application instruction list and insertion of instrumentation occurs in between the two calls and thus does not have to worry about groups of instructions that cannot be separated or changed. The resulting predicated instructions are not encodable in Thumb mode (<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa3f721209faa0616ff181a7bf207a59cc">DR_ISA_ARM_THUMB</a>): <a class="el" href="dr__ir__utils_8h.html#a1f2c05b5d49ca8dedfd52d7bbb2f59bb">dr_insert_it_instrs()</a> must be called before encoding.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of OP_it instructions removed; -1 on error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>ARM-only </dd></dl>

</div>
</div>
<a id="a05ba59e69809f491c0739ed70c20bb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ba59e69809f491c0739ed70c20bb2e">&#9670;&nbsp;</a></span>dr_restore_app_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_restore_app_stack </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore into esp the value saved by <a class="el" href="dr__ir__utils_8h.html#a25ec83d615512402df1a245fce917281">dr_swap_to_clean_stack()</a>. </p>

</div>
</div>
<a id="a31b8fd731ecc840fcddda04c36a7eadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b8fd731ecc840fcddda04c36a7eadd">&#9670;&nbsp;</a></span>dr_restore_arith_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_restore_arith_flags </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore the 6 arithmetic flags, assuming they were saved using <a class="el" href="dr__ir__utils_8h.html#abd9f556b8175c4ac72d8e7df8295f121">dr_save_arith_flags()</a> with slot <code>slot</code> and that xax holds the same value it did after the save.</p>
<dl class="section note"><dt>Note</dt><dd>X86-only</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>This routine is equivalent to <a class="el" href="dr__ir__utils_8h.html#ac23cd7358b39b70ece301bdc48928422">dr_restore_arith_flags_from_xax()</a> followed by <a class="el" href="dr__ir__utils_8h.html#a97e9767e1ff0f426b552a5f18c528ced">dr_restore_reg()</a>. </dd></dl>

</div>
</div>
<a id="a3164b3b86afa288c819d55a9037ec897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3164b3b86afa288c819d55a9037ec897">&#9670;&nbsp;</a></span>dr_restore_arith_flags_from_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_restore_arith_flags_from_reg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore the arithmetic flags (6 arithmetic flags on X86 or APSR on ARM) from <code>reg</code>. The caller must ensure that <code>reg</code> contains the program status flags, most likely from <a class="el" href="dr__ir__utils_8h.html#a44bbc8b62b54f91fe2f6ab76ac71641e">dr_save_arith_flags_to_reg()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>On X86, only DR_REG_XAX should be passed in. </dd></dl>

</div>
</div>
<a id="ac23cd7358b39b70ece301bdc48928422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23cd7358b39b70ece301bdc48928422">&#9670;&nbsp;</a></span>dr_restore_arith_flags_from_xax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_restore_arith_flags_from_xax </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore the 6 arithmetic flags from xax. This currently uses DynamoRIO's "add $0x7f %al ;
sahf" code sequence, which is faster and easier than popf. The caller must ensure that xax contains the arithmetic flags, most likely from <a class="el" href="dr__ir__utils_8h.html#a8c579801a00ce256038664288a5f8909">dr_save_arith_flags_to_xax()</a>. </p><dl class="section note"><dt>Note</dt><dd>X86-only </dd></dl>

</div>
</div>
<a id="a97e9767e1ff0f426b552a5f18c528ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e9767e1ff0f426b552a5f18c528ced">&#9670;&nbsp;</a></span>dr_restore_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_restore_reg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore the register <code>reg</code> from the spill slot <code>slot</code>. See <a class="el" href="dr__ir__utils_8h.html#ae8479716f08bbbb36d7fd27cfbbc0743">dr_save_reg()</a> for notes on lifetime and alternative access to spill slots. </p>

</div>
</div>
<a id="abd9f556b8175c4ac72d8e7df8295f121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9f556b8175c4ac72d8e7df8295f121">&#9670;&nbsp;</a></span>dr_save_arith_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_save_arith_flags </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the 6 arithmetic flags into xax after first saving xax to the spill slot <code>slot</code>. This is equivalent to <a class="el" href="dr__ir__utils_8h.html#ae8479716f08bbbb36d7fd27cfbbc0743">dr_save_reg()</a> of xax to <code>slot</code> followed by lahf and seto al instructions. See <a class="el" href="dr__ir__utils_8h.html#a31b8fd731ecc840fcddda04c36a7eadd">dr_restore_arith_flags()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>At completion of the inserted instructions the saved flags are in the xax register. The xax register should not be modified after using this routine unless it is first saved (and later restored prior to using <a class="el" href="dr__ir__utils_8h.html#a31b8fd731ecc840fcddda04c36a7eadd">dr_restore_arith_flags()</a>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>X86-only</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>This routine is equivalent to <a class="el" href="dr__ir__utils_8h.html#ae8479716f08bbbb36d7fd27cfbbc0743">dr_save_reg()</a> followed by <a class="el" href="dr__ir__utils_8h.html#a8c579801a00ce256038664288a5f8909">dr_save_arith_flags_to_xax()</a>. </dd></dl>

</div>
</div>
<a id="a44bbc8b62b54f91fe2f6ab76ac71641e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bbc8b62b54f91fe2f6ab76ac71641e">&#9670;&nbsp;</a></span>dr_save_arith_flags_to_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_save_arith_flags_to_reg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the arithmetic flags (6 arithmetic flags on X86 or APSR on ARM) into <code>reg</code>. If the caller wishes to use <code>reg</code> between saving and restoring these flags, they must save and restore <code>reg</code>, potentially using <a class="el" href="dr__ir__utils_8h.html#ae8479716f08bbbb36d7fd27cfbbc0743">dr_save_reg()</a>/dr_restore_reg(). If the caller needs to save both the current value of <code>reg</code> and the flags stored to <code>reg</code> by this routine, they must use separate spill slots, or they will overwrite the original <code>reg</code> value in memory.</p>
<dl class="section note"><dt>Note</dt><dd>On X86, only DR_REG_XAX should be passed in.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Clobbers <code>reg</code>; the caller must ensure <code>reg</code> is dead or saved at <code>where</code>. </dd></dl>

</div>
</div>
<a id="a8c579801a00ce256038664288a5f8909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c579801a00ce256038664288a5f8909">&#9670;&nbsp;</a></span>dr_save_arith_flags_to_xax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_save_arith_flags_to_xax </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the 6 arithmetic flags into xax. This currently uses DynamoRIO's "lahf ; seto al" code sequence, which is faster and easier than pushf. If the caller wishes to use xax between saving and restoring these flags, they must save and restore xax, potentially using <a class="el" href="dr__ir__utils_8h.html#ae8479716f08bbbb36d7fd27cfbbc0743">dr_save_reg()</a>/dr_restore_reg(). If the caller needs to save both the current value of xax and the flags stored to xax by this routine, they must use separate spill slots, or they will overwrite the original xax value in memory. </p><dl class="section note"><dt>Note</dt><dd>X86-only</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Clobbers xax; the caller must ensure xax is dead or saved at <code>where</code>. </dd></dl>

</div>
</div>
<a id="ae8479716f08bbbb36d7fd27cfbbc0743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8479716f08bbbb36d7fd27cfbbc0743">&#9670;&nbsp;</a></span>dr_save_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_save_reg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the register <code>reg</code> in the spill slot <code>slot</code>. See <a class="el" href="dr__ir__utils_8h.html#a97e9767e1ff0f426b552a5f18c528ced">dr_restore_reg()</a>. Use <a class="el" href="dr__ir__utils_8h.html#a6fdc15ea04e8d17fa537832acf274d9c">dr_read_saved_reg()</a> and <a class="el" href="dr__ir__utils_8h.html#a178b4afb7bc059afbb92e9bee3572ca0">dr_write_saved_reg()</a> to access spill slots from clean calls and restore_state_events (see <a class="el" href="dr__events_8h.html#a46dc6ae264b5b293e889cc88ea808eab">dr_register_restore_state_event()</a>). </p><dl class="section note"><dt>Note</dt><dd>The stored value remains available only until the next non-meta (i.e. application) instruction. Use <a class="el" href="dr__ir__utils_8h.html#a06b5104ef0d55577cee0f66bd9a0051f">dr_insert_write_tls_field()</a> and <a class="el" href="dr__ir__utils_8h.html#aab7b4392c68e53f807bba5791183f240">dr_insert_read_tls_field()</a> for a persistent (but more costly to access) thread-local-storage location. See also <a class="el" href="dr__tools_8h.html#ac5d2a2ccd58268f84c379a38bc4aa399">dr_raw_tls_calloc()</a>. </dd></dl>

</div>
</div>
<a id="ac4bfa7fc3f9d4adb0857675bec2712a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bfa7fc3f9d4adb0857675bec2712a2">&#9670;&nbsp;</a></span>dr_set_mcontext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_set_mcontext </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the fields of the application machine context selected by the flags field of <code>context</code> to the values in <code>context</code>.</p>
<p>This routine may only be called from:</p><ul>
<li>A clean call invoked by <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a537f64152425259b2deda82cee6c90c4">dr_prepare_for_call()</a>. If register reservation code is in use (e.g., via the drreg extension library <a class="el" href="page_drreg.html">Register Management</a>), <a class="el" href="dr__ir__utils_8h.html#a175c7c2531aa70017d2fb020f93e374f">dr_insert_clean_call_ex()</a> must be used with its flags argument including <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab0fb37c5cbbd2c2cd9ebd9eb5e53f23e">DR_CLEANCALL_WRITES_APP_CONTEXT</a> (and possibly <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab3ed3f85123fad82c4377cebaa2c36ed">DR_CLEANCALL_MULTIPATH</a>) to ensure proper interaction with register reservations.</li>
<li>A pre- or post-syscall event (<a class="el" href="dr__events_8h.html#a80d0f026def74d903a83fb6122816ae2">dr_register_pre_syscall_event()</a>, <a class="el" href="dr__events_8h.html#a7a62b6c11f3b0ae2fe7773189f6e4826">dr_register_post_syscall_event()</a>) <a class="el" href="dr__events_8h.html#aa34d296a9e990925a096501a7d5c6596">dr_register_thread_exit_event()</a>)</li>
<li>A kernel transfer event (<a class="el" href="dr__events_8h.html#ac433abf2a9b5ec9a5571e39d7d069df2">dr_register_kernel_xfer_event()</a>) other than <a class="el" href="dr__events_8h.html#a05b0d8543956536b9938ccb6fdd89570ad147383a8a28f49267da635270e96830">DR_XFER_CALLBACK_RETURN</a>. Here the modified context is the target context of the transfer, not the source (about to be changed) context. For Windows system call event types <a class="el" href="dr__events_8h.html#a05b0d8543956536b9938ccb6fdd89570acc7205549e58402388ed6a9a33ab9bc6">DR_XFER_CONTINUE</a> and <a class="el" href="dr__events_8h.html#a05b0d8543956536b9938ccb6fdd89570aa693b58a21b0f7f0f9a9d537c40bde62">DR_XFER_SET_CONTEXT_THREAD</a>, only the portions of the context selected by the application can be changed. The <code>flags</code> field of <code>context</code> is adjusted to reflect which fields these are. Given the disparity in how Ebp/Rbp is handled (in <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4af2252e055eafe402a7bf12b9951410d8">DR_MC_INTEGER</a> but in CONTEXT_CONTROL), clients that care about that register are better off using system call events instead of kernel transfer events to take actions on these two system calls. - Basic block or trace creation events (<a class="el" href="dr__events_8h.html#acbfe1ece2c520d409ffd59076507a710">dr_register_bb_event()</a>, <a class="el" href="dr__events_8h.html#ad47842a864b5d406e56d6ceddbab47ac">dr_register_trace_event()</a>), but for basic block creation only when the basic block callback parameters <code>for_trace</code> and <code>translating</code> are false, and for trace creation only when <code>translating</code> is false.</li>
</ul>
<p>Ignores the pc field, except for kernel transfer events.</p>
<p>If the size field of <code>context</code> is invalid, this routine will return false. A dr_mcontext_t obtained from DR will have the size field set.</p>
<p>The flags field of <code>context</code> must be set to select the desired fields for copying, using the dr_mcontext_flags_t values. Asking to copy multimedia registers incurs a higher performance cost. An invalid flags value will return false.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The xmm fields are only set for processes where the underlying processor supports them (and when DR_MC_MULTIMEDIA is set in the flags field). For <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a> that requested <code>save_fpstate</code>, the xmm values set here override that saved state. Use <a class="el" href="dr__ir__utils_8h.html#a70dc8c6ccbd73b540991c5da347e65b2">dr_mcontext_xmm_fields_valid()</a> to determine whether the xmm fields are valid. </dd></dl>

</div>
</div>
<a id="a25ec83d615512402df1a245fce917281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ec83d615512402df1a245fce917281">&#9670;&nbsp;</a></span>dr_swap_to_clean_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_swap_to_clean_stack </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the current esp and switch to this thread's DR stack. </p><dl class="section note"><dt>Note</dt><dd>The DR stack is limited to 20KB by default; this can be changed with the -stack_size DR runtime parameter. This stack cannot be used to store state that persists beyond a single clean call, code cache execution, or probe callback function execution. </dd></dl>

</div>
</div>
<a id="a178b4afb7bc059afbb92e9bee3572ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178b4afb7bc059afbb92e9bee3572ca0">&#9670;&nbsp;</a></span>dr_write_saved_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_write_saved_reg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Can be used from a clean call to modify the value saved in the spill slot <code>slot</code> by <a class="el" href="dr__ir__utils_8h.html#ae8479716f08bbbb36d7fd27cfbbc0743">dr_save_reg()</a> such that a later <a class="el" href="dr__ir__utils_8h.html#a97e9767e1ff0f426b552a5f18c528ced">dr_restore_reg()</a> will see the new value.</p>
<dl class="section note"><dt>Note</dt><dd>This routine should only be used during a clean call out of the cache. Use at any other time could corrupt application or DynamoRIO state. </dd></dl>

</div>
</div>
<a id="a303cc7b7b132b9aafb8db5abae76d45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303cc7b7b132b9aafb8db5abae76d45f">&#9670;&nbsp;</a></span>instrlist_insert_mov_immed_ptrsz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void instrlist_insert_mov_immed_ptrsz </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_int_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> **first&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> **last&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create meta instructions for storing pointer-size integer <code>val</code> to <code>dst</code>, and then insert them into <code>ilist</code> prior to <code>where</code>. Pointers to the first and last created meta instructions are returned in <code>first</code> and <code>last</code>, unless only one meta instruction is created, in which case NULL is returned in last. If the instruction is a no-op (when dst is the zero register on AArch64) then no instructions are created and NULL is returned in first and last. </p>

</div>
</div>
<a id="a18a42d59b54c1f768a0f8ef0c0e91c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a42d59b54c1f768a0f8ef0c0e91c34">&#9670;&nbsp;</a></span>instrlist_insert_mov_instr_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void instrlist_insert_mov_instr_addr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>src_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>encode_estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> **first&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> **last&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create meta instructions for storing the address of <code>src_inst</code> to <code>dst</code>, and then insert them into <code>ilist</code> prior to <code>where</code>. The <code>encode_estimate</code> parameter, used only for 64-bit mode, indicates whether the final address of <code>src_inst</code>, when it is encoded later, will fit in 32 bits or needs 64 bits. If the encoding will be in DynamoRIO's code cache, pass NULL. If the final encoding location is unknown, pass a high address to be on the safe side. Pointers to the first and last created meta instructions are returned in <code>first</code> and <code>last</code>, unless only one meta instruction is created, in which case NULL is returned in last. If the instruction is a no-op (when dst is the zero register on AArch64) then no instructions are created and NULL is returned in first and last. </p>

</div>
</div>
<a id="abf2861316d8857d190ac174b58c18544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2861316d8857d190ac174b58c18544">&#9670;&nbsp;</a></span>instrlist_insert_push_immed_ptrsz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void instrlist_insert_push_immed_ptrsz </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_int_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> **first&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> **last&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create meta instructions for pushing pointer-size integer <code>val</code> on the stack, and then insert them into <code>ilist</code> prior to <code>where</code>. Pointers to the first and last created meta instructions are returned in <code>first</code> and <code>last</code>, unless only one meta instruction is created, in which case NULL is returned in last. </p>

</div>
</div>
<a id="a2315a34a23b75cbaebfc97e6547b5d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2315a34a23b75cbaebfc97e6547b5d10">&#9670;&nbsp;</a></span>instrlist_insert_push_instr_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void instrlist_insert_push_instr_addr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>src_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>encode_estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> **first&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> **last&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create meta instructions for pushing the address of <code>src_inst</code> on the stack, and then insert them into <code>ilist</code> prior to <code>where</code>. The <code>encode_estimate</code> parameter, used only for 64-bit mode, indicates whether the final address of <code>src_inst</code>, when it is encoded later, will fit in 32 bits or needs 64 bits. If the encoding will be in DynamoRIO's code cache, pass NULL. If the final encoding location is unknown, pass a high address to be on the safe side. Pointers to the first and last created meta instructions are returned in <code>first</code> and <code>last</code>, unless only one meta instruction is created, in which case NULL is returned in last. </p>

</div>
</div>
<a id="a376024b7b2d33e3a86ec3544b80f645c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376024b7b2d33e3a86ec3544b80f645c">&#9670;&nbsp;</a></span>instrlist_meta_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void instrlist_meta_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction onto the end of <code>ilist</code> </p>

</div>
</div>
<a id="ad9818755498b60ba7713a7a064b6db53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9818755498b60ba7713a7a064b6db53">&#9670;&nbsp;</a></span>instrlist_meta_fault_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void instrlist_meta_fault_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#aae83ef5ab1a1442718367b5b3162ab5f">instr_set_meta_may_fault()</a>) onto the end of <code>ilist</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Essentially equivalent to <a class="el" href="dr__ir__utils_8h.html#a376024b7b2d33e3a86ec3544b80f645c">instrlist_meta_append()</a> </dd></dl>

</div>
</div>
<a id="a3ee2dc65e868a33347292adb54982c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee2dc65e868a33347292adb54982c16">&#9670;&nbsp;</a></span>instrlist_meta_fault_postinsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void instrlist_meta_fault_postinsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#aae83ef5ab1a1442718367b5b3162ab5f">instr_set_meta_may_fault()</a>) into <code>ilist</code> after <code>where</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Essentially equivalent to <a class="el" href="dr__ir__utils_8h.html#ad513dfc5199e89c7d22a271afa692b65">instrlist_meta_postinsert()</a> </dd></dl>

</div>
</div>
<a id="a1d006431d6330adc66e372d99fa86e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d006431d6330adc66e372d99fa86e2f">&#9670;&nbsp;</a></span>instrlist_meta_fault_preinsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void instrlist_meta_fault_preinsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#aae83ef5ab1a1442718367b5b3162ab5f">instr_set_meta_may_fault()</a>) into <code>ilist</code> prior to <code>where</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Essentially equivalent to <a class="el" href="dr__ir__utils_8h.html#a4c8c687663c2f51e60e564ca9626acea">instrlist_meta_preinsert()</a> </dd></dl>

</div>
</div>
<a id="ad513dfc5199e89c7d22a271afa692b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad513dfc5199e89c7d22a271afa692b65">&#9670;&nbsp;</a></span>instrlist_meta_postinsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void instrlist_meta_postinsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction into <code>ilist</code> after <code>where</code>. </p>

</div>
</div>
<a id="a4c8c687663c2f51e60e564ca9626acea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8c687663c2f51e60e564ca9626acea">&#9670;&nbsp;</a></span>instrlist_meta_preinsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void instrlist_meta_preinsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction into <code>ilist</code> prior to <code>where</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:04:13 &nbsp; <img border=0 src="favicon.png">
</small></address>
