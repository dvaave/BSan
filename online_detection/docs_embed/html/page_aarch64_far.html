---
title: "Linking Far Fragments on AArch64"
layout: default
permalink: /page_aarch64_far.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Linking Far Fragments on AArch64 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md0">Background</a><ul><li class="level2"><a href="#autotoc_md1">Existing Implementation</a><ul><li class="level3"><a href="#autotoc_md2">ARM32</a></li>
<li class="level3"><a href="#autotoc_md3">AArch64</a></li>
<li class="level3"><a href="#autotoc_md4">x86</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md5">Problem Statement</a></li>
<li class="level1"><a href="#autotoc_md6">Proposed Solutions</a><ul><li class="level2"><a href="#autotoc_md7">Option 1: Append load-and-branch-to-target instrs to existing exit stub</a></li>
<li class="level2"><a href="#autotoc_md8">Option 2: Reuse code between fcache_return/linked stub</a></li>
<li class="level2"><a href="#autotoc_md9">Option 3: Landing Pads</a></li>
<li class="level2"><a href="#autotoc_md10">Option 4: Reuse data slot between fcache_return/linked stub</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md11">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md0"></a>
Background</h1>
<p>When an application runs under DynamoRIO, basic blocks are initially unlinked. This means that when a basic block completes execution, control goes back to DR. To reduce such context switches, basic block fragments are linked together when:</p><ul>
<li>there’s a direct branch from one to the other</li>
<li>building traces of frequently executed sequences of basic blocks</li>
</ul>
<p>Exit stubs are snippets of code after each basic block. They transfer control to DR when a basic block execution completes, by branching to <code>fcache_return</code> and passing information like whether the last branch was taken or not taken. When two basic blocks are linked, control no longer transfers to DR at this point; instead, it transfers to the next basic block directly. Depending on the reachability challenges on the target platform, DR uses different approaches to linking.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Existing Implementation</h2>
<h3><a class="anchor" id="autotoc_md2"></a>
ARM32</h3>
<p><code>r10</code> is the stolen reg on ARM, which contains the TLS pointer. <code>exit_cti</code> can be a conditional or unconditional direct branch at the end of a basic block (with <a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/arch/arm/emit_utils.c#L262">21-26 bits for reachability</a>).</p>
<p>When the target fragment can be reached by the exit cti, we simply modify its target to point to the target fragment pc. If not, we let control flow to the exit stub; we store the target fragment pc in a data slot at the end of the exit stub and modify the first instruction of the stub to a load-into-pc from the data slot. This allows reaching fragments arbitrarily far away. Such a modified stub is called a ''patched'' stub.</p>
<table class="doxtable">
<tr>
<th>Unlinked </th><th>Linked, <a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/arch/arm/emit_utils.c#L262">exit_cti_reaches_target</a> </th><th>Linked, <a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/arch/arm/emit_utils.c#L262">!exit_cti_reaches_target</a>  </th></tr>
<tr>
<td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line"> ...</div>
<div class="line">stub:</div>
<div class="line"> str  r0, [r10, #r0-slot]</div>
<div class="line"> movw r0, #bottom-half-&amp;linkstub</div>
<div class="line"> movt r0, #top-half-&amp;linkstub</div>
<div class="line"> ldr  pc, [r10, #fcache-ret-offs]</div>
<div class="line"> &lt;unused-ptr-sized slot&gt;</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><div class="fragment"><div class="line"> b    target</div>
<div class="line"> ...</div>
<div class="line">stub:</div>
<div class="line"> str  r0, [r10, #r0-slot]</div>
<div class="line"> movw r0, #bottom-half-&amp;linkstub</div>
<div class="line"> movt r0, #top-half-&amp;linkstub</div>
<div class="line"> ldr  pc, [r10, #fcache-ret-offs]</div>
<div class="line"> &lt;unused-ptr-sized slot&gt;</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line"> ...</div>
<div class="line">stub:</div>
<div class="line"> ldr  pc, [pc + 12]</div>
<div class="line"> movw r0, #bottom-half-&amp;linkstub</div>
<div class="line"> movt r0, #top-half-&amp;linkstub</div>
<div class="line"> ldr  pc, [r10, #fcache-ret-offs]</div>
<div class="line"> &lt;target&gt;</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
<h3><a class="anchor" id="autotoc_md3"></a>
AArch64</h3>
<p><code>x28</code> is the stolen reg on AArch64, which contains the TLS pointer. <code>exit_cti</code> can be a conditional or unconditional direct branch at the end of a basic block (with <a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/arch/aarch64/emit_utils.c#L162">14-26 bits for reachability</a>).</p>
<p>When the target fragment can be reached by the exit cti, we simply modify its target to point to the target fragment pc. If not, we let control flow to the exit stub; we modify the first instruction of the exit stub to an unconditional direct branch. Such a modified stub is called a ''patched'' stub.</p>
<p>Note that we still cannot link fragments arbitrarily far away, but only fragments that can be reached using the 26-bit offset of the unconditional direct branch instruction.</p>
<table class="doxtable">
<tr>
<th>Unlinked </th><th>Linked, <a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/arch/aarch64/emit_utils.c#L162">exit_cti_reaches_target</a> </th><th>Linked, <a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/arch/aarch64/emit_utils.c#L162">!exit_cti_reaches_target</a>  </th></tr>
<tr>
<td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> stp  x0, x1, [x28]</div>
<div class="line"> movz x0, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x0, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x0, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x0, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x1, [x28, #fcache-<span class="keywordflow">return</span>-offs]</div>
<div class="line"> br   x1</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><div class="fragment"><div class="line"> exit_cti target</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> stp  x0, x1, [x28]</div>
<div class="line"> movz x0, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x0, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x0, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x0, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x1, [x28, #fcache-<span class="keywordflow">return</span>-offs]</div>
<div class="line"> br   x1</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><div class="fragment"><div class="line"> exit_cti  stub</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> b    target</div>
<div class="line"> movz x0, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x0, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x0, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x0, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x1, [x28, #fcache-<span class="keywordflow">return</span>-offs]</div>
<div class="line"> br   x1</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
<p>Exit stub size: 7 instrs (28B)</p>
<h3><a class="anchor" id="autotoc_md4"></a>
x86</h3>
<p>x86’s reachability model assumes that the cache is always self-reachable. So, <a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/arch/x86/emit_utils.c#L127"><code>exit_cti_reaches_target</code></a> is always true.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Problem Statement</h1>
<p>We need a way to link arbitrarily far away fragments in AArch64. This will be implemented in the AArch64 <a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/arch/aarch64/emit_utils.c#L182"><code>patch_stub</code></a>, which patches the exit stub to branch to the far-away fragment (instead of the <code>fcache_return</code> routine). The Importance of this work is higher for larger applications.</p>
<p>Some constraints on the design are as follows:</p>
<p><b>Size</b></p>
<p>Exit stub size should not increase by too much. This directly affects the memory overhead of DR.</p>
<p><b>Consistency</b></p>
<p>Fragments are thread-shared by default. Any changes to the exit stub should not leave the stub in an inconsistent intermediate state.</p>
<p>The following requirements should be met to ensure stub consistency. See [1] for complete architecture specifications for concurrent modification and execution of instructions.</p><ul>
<li>To ensure the sequence of modified instructions is visible to other threads, the thread patching the stub must issue a sequence to clean its dcache and invalidate its icache (see point 2 at [1]). Today, this is done by DR in <a href="https://github.com/DynamoRIO/dynamorio/blob/57784023fc35b5aad7108c444ab79fc820276543/core/drlibc/drlibc.c#L106"><code>clear_icache</code></a>.</li>
<li>Other threads must execute an Instruction Synchronization Barrier (<code>ISB</code>). This is not done today by DR</li>
<li>No other thread must execute the instructions until the above is completed. This is not guaranteed today by DR. Without the above, the architecture cannot guarantee that the instruction executed will be either the old or new one. However, if the old and new instructions are one of the special opcodes given at [1] (which notably includes <code>B</code> and <code>NOP</code>), it is guaranteed that the instruction executed will be either one of them; though note that this still doesn’t guarantee that the old instruction won’t be executed by any thread.</li>
</ul>
<p>Today, DR guarantees only one of the three requirements for concurrent modification and execution of instructions. Even though we haven’t seen any issues due to this yet, but they may come up in future architectures or come up infrequently.</p>
<p>There are existing instances of potentially concurrent modification and execution of instructions, which will be addressed in <a href="http://github.com/DynamoRIO/dynamorio/issues/1911">i#1911</a>.</p>
<p>[1]: Section B2.2.5 of the <a href="https://developer.arm.com/documentation/ddi0487/latest">ARM manual</a></p>
<p><b>Overhead of indirect branches</b></p>
<p>Existing implementations use a direct branch when possible, to avoid the extra overhead of loading the target address from memory. We should continue doing that for linking near fragments.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Proposed Solutions</h1>
<p>Options 1 and 2 implement something similar to ARM-32, where we store the target fragment pc in a data slot at the exit stub’s end, and then patch the exit stub to branch to that address. Note that for near fragments that can be reached using a direct branch, we continue to replace the first exit stub instruction with a direct branch as described before. The drawback is that they do not strictly meet the consistency requirements of the architecture.</p>
<p>Option 3 uses Landing Pads.</p>
<p>Option 4 is slightly different from Options 1 and 2, in that it doesn’t perform any instruction modification.</p>
<p><b>Other Architecture challenges</b></p>
<p>AArch64 does not expose PC as a general purpose register, therefore doesn’t support load into PC. Therefore, to transfer control to a far fragment, we’d use an indirect branch instruction, which would need us to spill a register and restore it later. Fortunately, DR on AArch64 already supports <a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/arch/aarch64/emit_utils.c#L375">fragment prefixes</a> that restore <code>x0</code> from <code>TLS_REG1_SLOT</code>.</p>
<p>AArch64 also doesn’t allow indirect branches from memory: we need to load the address from memory into a register first.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Option 1: Append load-and-branch-to-target instrs to existing exit stub</h2>
<table class="doxtable">
<tr>
<th>Unpatched stub: Transfers to <code>fcache_return</code> </th><th>Patched stub: Transfers to far-away linked fragment  </th></tr>
<tr>
<td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> stp  x0, x1, [x28]</div>
<div class="line"> movz x0, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x0, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x0, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x0, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x1, [x28, #fcache-<span class="keywordflow">return</span>-offs]</div>
<div class="line"> br   x1</div>
<div class="line">label:</div>
<div class="line"> str  x0, [x28, #TLS_REG1_SLOT]</div>
<div class="line"> ldr  x0, [+#8]</div>
<div class="line"> br   x0</div>
<div class="line"> &lt;unused-ptr-sized-slot&gt;</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> b    label # encoded as pc offset</div>
<div class="line"> movz x0, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x0, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x0, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x0, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x1, [x28, #fcache-<span class="keywordflow">return</span>-offs]</div>
<div class="line"> br   x1</div>
<div class="line">label:</div>
<div class="line"> str  x0, [x28, #TLS_REG1_SLOT]</div>
<div class="line"> ldr  x0, [+#8]</div>
<div class="line"> br   x0</div>
<div class="line"> &lt;target&gt;</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
<p>Exit stub size: 10 instrs + 1 data slot of 8 bytes (48B)</p>
<p>This option almost doubles the exit stub size: 28B -&gt; 48B.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Option 2: Reuse code between fcache_return/linked stub</h2>
<p>The two methods below differ in the extra modifications required.</p>
<p>Option 2a: </p><table class="doxtable">
<tr>
<th>Unpatched stub: Transfers to <code>fcache_return</code> </th><th>Patched stub: Transfers to far-away linked fragment  </th></tr>
<tr>
<td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> stp  x0, x1, [x28]</div>
<div class="line"> movz x0, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x0, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x0, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x0, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x1, [x28, #fcache-<span class="keywordflow">return</span>-offs]</div>
<div class="line"> br   x1</div>
<div class="line"> &lt;unused-ptr-sized-slot&gt;</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> stp  x0, x1, [x28]</div>
<div class="line"> movz x0, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x0, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x0, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x0, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x1, [+#8]</div>
<div class="line"> br   x1</div>
<div class="line"> &lt;target&gt;</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
<p>Exit stub size: 7 instrs + 1 data slot of 8 bytes (36B)</p>
<p>We would also need to:</p><ul>
<li>For all control transfers to fragment prefix, spill both <code>x0</code> and <code>x1</code> always, and in the prefix restore both.</li>
</ul>
<p>Option 2b: </p><table class="doxtable">
<tr>
<th>Unpatched stub: Transfers to <code>fcache_return</code> </th><th>Patched stub: Transfers to far-away linked fragment  </th></tr>
<tr>
<td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> stp  x1, x0, [x28]</div>
<div class="line"> movz x1, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x1, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x1, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x1, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x0, [+#12]</div>
<div class="line"> ldr  x0, [x28, #fcache-<span class="keywordflow">return</span>-offs]</div>
<div class="line"> br   x0</div>
<div class="line"> &lt;unused-ptr-sized-slot&gt;</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> stp  x1, x0, [x28]</div>
<div class="line"> movz x1, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x1, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x1, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x1, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x0, [+#12]</div>
<div class="line"> ldr  x1, [x28] # restore x1</div>
<div class="line"> br   x0</div>
<div class="line"> &lt;target&gt;</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
<p>Exit stub size: 8 instrs + 1 data slot of 8 bytes (40B).</p>
<p>Here, <code>x0</code> is stored in <code>TLS_REG1_SLOT [x28, #8]</code>, and will be restored by the fragment prefix.</p>
<p>We’ll also need to modify fcache-return so that:</p><ul>
<li>It accepts linkstub address in <code>x1</code>, instead of <code>x0</code></li>
<li>It restores <code>x0</code> and <code>x1</code> from different TLS slots (note the swapped order in <code>stp</code>). Alternatively, we can keep the <code>stp</code> order as before, but modify the AArch64 fragment prefix (and corresponding other spill code too) <a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/arch/aarch64/emit_utils.c#L375">to restore <code>x0</code> from <code>TLS_REG0_SLOT</code> instead of <code>TLS_REG1_SLOT</code></a>, which would make the code clearer too.</li>
</ul>
<h2><a class="anchor" id="autotoc_md9"></a>
Option 3: Landing Pads</h2>
<p><a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/heap.c#L5684">Landing pads</a> are gadgets used to jump to an arbitrarily far location: on x64, they use an indirect jump to the address stored in memory. They are allocated in a manner such that they are directly reachable from a pc given during allocation, which is the pc that would jump to the landing pad.</p>
<p>Landing pads also support storing some code for execution and branching back to some code location. They are useful for cases where we want to add a call to some intercept function at a location that is originally unwritable. e.g. <a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/win32/callback.c#L1617">intercept_call</a>. In our case, the former capability of Landing Pads of branching one-way to any location is useful.</p>
<p>The existing Landing Pad for x86_64 in intercept_call looks something like the following: </p><div class="fragment"><div class="line"> &lt;app code&gt;             <span class="comment">// &lt;- start here</span></div>
<div class="line"> jmp landing_pad_start</div>
<div class="line"> &lt;some app code displaced to landing pad&gt;</div>
<div class="line">after_hook_pc:</div>
<div class="line"> &lt;app code&gt;</div>
<div class="line">...</div>
<div class="line">landing_pad:</div>
<div class="line"> far_target_pc</div>
<div class="line">landing_pad_start:</div>
<div class="line"> jmp [far_target_pc]</div>
<div class="line">landing_pad_displaced_code:</div>
<div class="line"> &lt;displaced app code&gt;</div>
<div class="line"> jmp after_hook_pc</div>
<div class="line">...</div>
<div class="line">[far_target_pc]:</div>
<div class="line">&lt;some instrumentation&gt;</div>
<div class="line">jmp landing_pad_displaced_code</div>
</div><!-- fragment --><p>Our usage of Landing Pad will look something like:</p>
<table class="doxtable">
<tr>
<th>Unpatched stub: Transfers to <code>fcache_return</code> </th><th>Patched stub: Transfers to far-away linked fragment  </th></tr>
<tr>
<td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> stp  x0, x1, [x28]</div>
<div class="line"> movz x0, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x0, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x0, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x0, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x1, [x28, #fcache-<span class="keywordflow">return</span>-offs]</div>
<div class="line"> br   x1</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> b landing_pad_start</div>
<div class="line"> movz x0, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x0, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x0, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x0, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x1, [x28, #fcache-<span class="keywordflow">return</span>-offs]</div>
<div class="line"> br   x1</div>
<div class="line"> </div>
<div class="line">landing_pad:</div>
<div class="line"> &lt;far_fragment_pc&gt;</div>
<div class="line">landing_pad_start:</div>
<div class="line"> adr x0, #-&lt;ptr-size&gt;</div>
<div class="line"> ldr x0, [x0]</div>
<div class="line"> br  x0</div>
<div class="line"><span class="comment">// no displaced code or after_hook_pc</span></div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
<p>Some extra work will be required to make Landing Pads work for linking far-away fragments on AArch64. Currently, Landing pads:</p><ul>
<li>are released only on process exit: <a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/heap.c#L6001">release_landing_pad_mem</a>. However, fragments undergo unlinking and eviction, which should ideally release the landing pad too. Otherwise, we may run out of memory for landing pads. -* We can handle pathological cases of running out of memory with a synchall flush</li>
<li>are implemented only for [Windows] and <a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/heap.c#L5683">https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/win32/callback.c#L744 x86</a>.</li>
<li>ensure only <a href="https://github.com/DynamoRIO/dynamorio/blob/228405d5dcd0ccbe2c3d36e6f16f33145415ee01/core/heap.c#L5778">32-bit reachability</a> from the given pc. -* We need to support ensuring arbitrary reachability, or for now the 26-bit case at least.</li>
</ul>
<p>Option 2 increases memory consumption by 12B for every stub. With landing pads, it’ll probably be more than that per stub, as the landing pad itself contains instructions/data of at least that size. However, in AArch64, we do not free exit stubs if they’re not being used (<code>-separate_shared_stubs</code> is enabled only on x86). As Landing Pads will be allocated lazily, overall memory overhead of Option 3 will be probably an order of magnitude less than Option 2.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Option 4: Reuse data slot between fcache_return/linked stub</h2>
<p>All of the above options involve changing instructions of the stub. As discussed before, there are architectural constraints that make arbitrary modifications of instructions more complex. One way to avoid any instruction modifications is as follows. Here, we only modify the address stored in the data slot.</p>
<p>Option 4a: </p><table class="doxtable">
<tr>
<th>Unpatched stub: Transfers to <code>fcache_return</code> </th><th>Patched stub: Transfers to far-away linked fragment  </th></tr>
<tr>
<td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> stp  x0, x1, [x28]</div>
<div class="line"> ldr  x0, [#32/#36]</div>
<div class="line"> br   x0</div>
<div class="line">label:</div>
<div class="line"> movz x0, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x0, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x0, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x0, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x1, [x28, #fcache-<span class="keywordflow">return</span>-offs]</div>
<div class="line"> br   x1</div>
<div class="line"> &lt;label-address&gt;</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> stp  x0, x1, [x28]</div>
<div class="line"> ldr  x0, [#32/#36]</div>
<div class="line"> br   x0</div>
<div class="line">label:</div>
<div class="line"> movz x0, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x0, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x0, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x0, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x1, [x28, #fcache-<span class="keywordflow">return</span>-offs]</div>
<div class="line"> br   x1</div>
<div class="line"> &lt;target-address&gt;</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
<p>Exit stub size: 9 instrs + 1 data slot of 8 bytes + (possibly) data-slot alignment (44B/48B)</p>
<p>Option 4b: </p><table class="doxtable">
<tr>
<th>Unpatched stub: Transfers to <code>fcache_return</code> </th><th>Patched stub: Transfers to far-away linked fragment  </th></tr>
<tr>
<td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> stp  x0, x1, [x28]</div>
<div class="line"> movz x0, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x0, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x0, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x0, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x1, [#8/#12]</div>
<div class="line"> br   x1</div>
<div class="line"> &lt;fcache-<span class="keywordflow">return</span>&gt;</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><div class="fragment"><div class="line"> exit_cti stub</div>
<div class="line">...</div>
<div class="line">stub:</div>
<div class="line"> stp  x0, x1, [x28]</div>
<div class="line"> movz x0, #&amp;linkstub[0, 16),  lsl #0x00</div>
<div class="line"> movk x0, #&amp;linkstub[16, 32), lsl #0x10</div>
<div class="line"> movk x0, #&amp;linkstub[32, 48), lsl #0x20</div>
<div class="line"> movk x0, #&amp;linkstub[48, 64), lsl #0x30</div>
<div class="line"> ldr  x1, [#8/#12]</div>
<div class="line"> br   x1</div>
<div class="line"> &lt;target&gt;</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
<p>Exit stub size: 7 instrs + 1 data slot of 8 bytes + (possibly) data-slot alignment = 36B/40B</p>
<p>In both Option 4a and 4b, we would also need to:</p><ul>
<li>Change fragment prefix to restore both <code>x0</code> and <code>x1</code>.</li>
</ul>
<p>Compared to Option 4a, Option 4b avoids an extra jump for the linked fragment case and has lesser stub size. But, Option 4b doesn’t work if threads don’t share the fcache-return address. It might also make run-time modifications to fache-return routine address difficult, but that doesn’t seem like a likely scenario.</p>
<p><br  />
 In both of these options, as we change only the data slot’s contents, we do not need any expensive icache synchronisation.</p>
<p>To ensure atomicity, we also need to make sure that the data-slot is 8-byte aligned.</p>
<p>The consistency constraints make avoiding indirect branches difficult. For optimising the near-fragment case, we can probably add a <code>NOP &lt;-&gt; B</code> as the first stub instruction, which can be patched in addition to the above. However, consistency of unpatching is still not guaranteed without expensive synchronisation.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Conclusion</h1>
<p>Option 4 seems the only option that meets architectural specifications completely. Option 4b seems more optimised for stub size and indirect branches. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:04:14 &nbsp; <img border=0 src="favicon.png">
</small></address>
