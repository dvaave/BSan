---
title: "Code Manipulation API"
layout: default
permalink: /API_BT.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Code Manipulation API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Code Manipulation API exposes the full power of DynamoRIO, allowing tools to observe and modify the application's actual code stream as it executes. Modifications are not limited to trampoline insertion and can include arbitrary changes. We divide the API description into the following sections:</p>
<ul>
<li><a class="el" href="API_BT.html#sec_IR">Instruction Representation</a></li>
<li><a class="el" href="API_BT.html#sec_events_bt">Events</a></li>
<li><a class="el" href="API_BT.html#sec_decode">Decoding and Encoding</a></li>
<li><a class="el" href="API_BT.html#sec_isa">Instruction Set Modes</a></li>
<li><a class="el" href="API_BT.html#sec_IR_utils">Utilities</a></li>
<li><a class="el" href="API_BT.html#sec_reg_stolen">Register Stolen by DynamoRIO</a></li>
<li><a class="el" href="API_BT.html#sec_translation">State Translation</a></li>
<li><a class="el" href="API_BT.html#sec_predication">Conditionally Executed Instructions</a></li>
<li><a class="el" href="API_BT.html#sec_ldrex">Exclusive Monitor Instrumentation</a></li>
<li><a class="el" href="API_BT.html#sec_rseq">Restartable Sequence Instrumentation Constraints</a></li>
<li><a class="el" href="API_BT.html#sec_pcache">Persisting Code</a></li>
</ul>
<p> 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
 </p>
<h1><a class="anchor" id="sec_IR"></a>
Instruction Representation</h1>
<p>The primary data structures involved in instruction manipulation are the <a class="el" href="structinstr__t.html">instr_t</a>, which represents a single instruction, and the <code><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a></code>, which is a linked list of instructions. The header files <a class="el" href="dr__ir__instrlist_8h.html" title="Functions to create and manipulate lists of instructions.">dr_ir_instrlist.h</a> and <a class="el" href="dr__ir__instr_8h.html" title="Functions to create and manipulate instructions.">dr_ir_instr.h</a> list a number of functions that operate on these data structures, including:</p>
<ul>
<li>Routines to create new instructions.</li>
<li>Routines to iterate over an instruction's operands.</li>
<li>Routines to iterate over an <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a>.</li>
<li>Routines to insert and remove an <a class="el" href="structinstr__t.html">instr_t</a> from an <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a>.</li>
</ul>
<p>As we will see in the the <a class="el" href="API_BT.html#sec_events_bt">Events</a> section that follows, a client usually interacts with <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a>'s in the form of <em>basic</em> <em>blocks</em> or <em>traces</em>. A basic block is a sequence of instructions that terminates with a control transfer operation. Traces are frequently-executed sequences of basic blocks that DynamoRIO forms dynamically as the application executes, i.e., <em>hot</em> code. Collectively, we refer to basic blocks and traces as <em>fragments</em>. Both basic blocks and traces present a linear view of control flow. In other words, instruction sequences have a single entrance and one or more exits. This representation greatly simplifies analysis and is a primary contributor to DynamoRIO's efficiency.</p>
<p>The instruction representation includes all of the operands, whether implicit or explicit, and the condition code effects of each instruction. This allows for analysis of liveness of registers and condition codes.</p>
<p>DynamoRIO's IR is mostly opaque to clients. Key data structures have their sizes exposed to allow for stack allocation, but their fields are opaque. In order to examine them, clients must call IR accessor routines in DynamoRIO. While this makes DynamoRIO ABI compatible with prior releases, there is a performance cost to calling through to an exported routine every time the client touches an instruction. Clients that are not concerned with ABI compatibility can turn many of these export routine calls into inline functions or macros by setting the CMake variable <code>DynamoRIO_FAST_IR</code> on or defining <code>DR_FAST_IR</code> before including <a class="el" href="dr__api_8h.html" title="Top-level include file for DynamoRIO API.">dr_api.h</a>. This removes some of the error checking that DynamoRIO performs on calls from the client, so it should typically be enabled only in a release build. Furthermore, some of the macros evaluate their arguments twice, so clients should avoid passing arguments with side effects.</p>
<p>When a new instruction is created using <a class="el" href="dr__ir__instr_8h.html#a9d9a1662aed6669a42a8284dae0e8019">instr_create()</a> or the INSTR_CREATE_* or XINST_CREATE_* macros, if the instruction is added to the <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> that is passed to the basic block or trace events, the heap memory used by the instruction is automatically freed when that instruction list is freed by DynamoRIO. If instead an instruction is created on the heap but used for other purposes and not added to a DynamoRIO-provided instruction list, it should be freed by calling <a class="el" href="dr__ir__instr_8h.html#a9e2667003be814d4b2e887d8ae29dac1">instr_destroy()</a> or by explicitly destroying a custom instruction list.</p>
<p>See <a class="el" href="API_BT.html#sec_decode">Decoding and Encoding</a> for further information on creating instructions from scratch, decoding, encoding, and disassembling instructions. Typically these instructions will be stored on the stack, using <a class="el" href="dr__ir__instr_8h.html#af7e998e183e87480e7fd82240ff6633d">instr_init()</a> and <a class="el" href="dr__ir__instr_8h.html#ab996c61a99fcf17880700e5adbbc6db1">instr_free()</a> or <a class="el" href="dr__ir__instr_8h.html#aaf4d287021b012cde46a3f2502dde2af">instr_reset()</a>, as shown in that section.</p>
<p>See <a class="el" href="API_BT.html#sec_IR_heap">Instruction Heap Allocation</a> for further information on heap allocation for instructions and safely using instructions in signal handlers.</p>
<p> 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
</p>
<h2><a class="anchor" id="sec_IR_AArch64"></a>
AArch64 IR Variations</h2>
<p>DynamoRIO's IR representation of AArch64 NEON instructions uses an additional immediate source operand to denote the width of the vector elements. The immediates take the values <a class="el" href="dr__ir__macros__aarch64_8h.html#aedab3b65ad211bd7510542247ce95a7c">VECTOR_ELEM_WIDTH_BYTE</a> (8 bit), <a class="el" href="dr__ir__macros__aarch64_8h.html#aab69967d6ead84edba4ab117f4116f34">VECTOR_ELEM_WIDTH_HALF</a> (16 bit), <a class="el" href="dr__ir__macros__aarch64_8h.html#ad4728ea383659d1eecc80c33bfc8f796">VECTOR_ELEM_WIDTH_SINGLE</a> (32 bit) and <a class="el" href="dr__ir__macros__aarch64_8h.html#a811e5bfe8a5e4f964e3e6e8f5809282f">VECTOR_ELEM_WIDTH_DOUBLE</a> (64 bit), for vector instructions that require arrangement specifiers for their operands. This is different from AArch64 assembly, where the element width is part of the vector register operand. For example, floating point vector addition of two vectors with 2 double elements is represented in assembly by </p><div class="fragment"><div class="line">fadd v9.2d, v30.2d, v9.2d </div>
</div><!-- fragment --><p> and in IR by </p><div class="fragment"><div class="line">fadd %q30 %q9 $0x03 -&gt; %q9 </div>
</div><!-- fragment --><p>.</p>
<h1><a class="anchor" id="sec_events_bt"></a>
Events</h1>
<p>The core of a client's interaction with DynamoRIO occurs through <em> event hooks</em>: the client registers its own callback routine (or <em>hook</em>) for each event it is interested in. DynamoRIO calls the client's event hooks at appropriate times, giving the client access to key actions during execution of the application. The <a class="el" href="using.html#sec_events">Common Events</a> section describes events common to the entire DynamoRIO API. Here we discuss the events specific to the Code Manipulation portion.</p>
<p>DynamoRIO provides two events related to application code fragments: one for basic blocks and one for traces (see <a class="el" href="dr__events_8h.html#acbfe1ece2c520d409ffd59076507a710">dr_register_bb_event()</a> and <a class="el" href="dr__events_8h.html#ad47842a864b5d406e56d6ceddbab47ac">dr_register_trace_event()</a>). Through these fragment-creation hooks, the client has the ability to inspect and modify any piece of code that DynamoRIO emits before it executes. Using the basic block hook, a client sees <em>all</em> application code. The trace-creation hook provides a mechanism for clients to instrument only frequently-executed code paths.</p>
<h2><a class="anchor" id="sec_control_points"></a>
Transformation Versus Execution Time</h2>
<p>DynamoRIO's basic block and trace events are raised when the corresponding application code is being transferred to the software code cache for execution. <em>No event is raised on each execution of this code from the code cache</em>. In a typical run, a particular block of code will only be seen once in an event. It will subsequently execute many times in the code cache.</p>
<p>The point where the event is raised, where the application code is being copied into the cache, is called <em>transformation time</em>. This is where a client can insert instrumentation to monitor the code, or can modify the application code itself. The repeated executions within the code cache of this instrumented or modified code are referred to as <em>execution time</em>. It is important to understand the distinction.</p>
<p>The code manipulation API is highly efficient in that fragment creation comprises a small part of DynamoRIO's overhead. A client's instrumentation time actions rarely add substantial overhead for most target applications. Instead, it is extra actions taken by added instrumentation code acting at execution time that affects efficiency.</p>
<h2><a class="anchor" id="sec_events_bb"></a>
Basic Block Creation</h2>
<p>Through the basic block creation event, registered via <a class="el" href="dr__events_8h.html#acbfe1ece2c520d409ffd59076507a710">dr_register_bb_event()</a>, the client has the ability to inspect and transform any piece of code prior to its execution. The client's hook receives three parameters:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> new_block(<span class="keywordtype">void</span> *drcontext, <span class="keywordtype">void</span> *tag, <a class="code" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *bb,</div>
<div class="line">                          <span class="keywordtype">bool</span> for_trace, <span class="keywordtype">bool</span> translating);</div>
</div><!-- fragment --><ul>
<li><code>drcontext</code> is a pointer to the input program's machine context. Clients should not inspect or modify the context; it is provided as an opaque pointer (i.e., <code>void *</code>) to be passed to API routines that require access to this internal data.</li>
<li><code>tag</code> is a unique identifier for the basic block fragment.</li>
<li><code>bb</code> is a pointer to the list of instructions that comprise the basic block. Clients can examine, manipulate, or completely replace the instructions in the list.</li>
<li><code>for_trace</code> indicates whether this callback is for a new basic block (false) or for adding a basic block to a trace being created (true). The client has the opportunity to either include the same modifications made to the standalone basic block, or to use different modifications, for the code in the trace.</li>
<li><code>translating</code> indicates whether this callback is for basic block creation (false) or is for address translation (true). This is further explained in <a class="el" href="API_BT.html#sec_translation">State Translation</a>.</li>
</ul>
<p>The return value of the basic block callback should generally be DR_EMIT_DEFAULT; however, time-varying instrumentation or complex code transformations may need to return DR_EMIT_STORE_TRANSLATIONS. See <a class="el" href="API_BT.html#sec_translation">State Translation</a> for further details. A tool that wants to persist its code to a file for fast re-use on subsequent runs can include the DR_EMIT_PERSISTABLE flag in its return value. See <a class="el" href="API_BT.html#sec_pcache">Persisting Code</a> for more information.</p>
<p>To iterate over instructions in an <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a>, use the <a class="el" href="dr__ir__instrlist_8h.html#a6491763e4a1534458a8d7034c8f69612">instrlist_first()</a>, <a class="el" href="dr__ir__instrlist_8h.html#a19dc2d8e481e3e42606bec21ec8501f4">instrlist_last()</a> (if necessary), and <a class="el" href="dr__ir__instr_8h.html#ac897243e24d71890e196586b8373b821">instr_get_next()</a> routines. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> new_block(<span class="keywordtype">void</span> *drcontext, <span class="keywordtype">void</span> *tag, <a class="code" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *bb,</div>
<div class="line">                          <span class="keywordtype">bool</span> for_trace, <span class="keywordtype">bool</span> translating)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="structinstr__t.html">instr_t</a> *instr, *next;</div>
<div class="line">  <span class="keywordflow">for</span> (instr = <a class="code" href="dr__ir__instrlist_8h.html#a6491763e4a1534458a8d7034c8f69612">instrlist_first</a>(bb);</div>
<div class="line">       instr != NULL;</div>
<div class="line">       instr = next) {</div>
<div class="line">    next = <a class="code" href="dr__ir__instr_8h.html#ac897243e24d71890e196586b8373b821">instr_get_next</a>(instr);</div>
<div class="line">    <span class="comment">/* do some processing on instr */</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a7d25c4546544d1a8c0b77c69230772eb">DR_EMIT_DEFAULT</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="sec_Meta"></a>
Application Versus Meta Instructions</h2>
<p>Changes to the instruction stream made by a client fall into two categories: changes or additions that should be considered part of the application's behavior, versus additions that are observational in nature and are not acting on the application's behalf. The latter are called <em>meta</em> instructions.</p>
<p>Meta instructions are marked using these API routines:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__ir__instr_8h.html#a7bd1a4d1621b685541e8c28426a0cfe4">instr_set_meta</a>()</div>
<div class="line"><a class="code" href="dr__ir__utils_8h.html#a4c8c687663c2f51e60e564ca9626acea">instrlist_meta_preinsert</a>()</div>
<div class="line"><a class="code" href="dr__ir__utils_8h.html#ad513dfc5199e89c7d22a271afa692b65">instrlist_meta_postinsert</a>()</div>
<div class="line"><a class="code" href="dr__ir__utils_8h.html#a376024b7b2d33e3a86ec3544b80f645c">instrlist_meta_append</a>()</div>
</div><!-- fragment --><p>DynamoRIO performs some processing on the basic block after the client has finished with it, primarily modifying branches to ensure that DynamoRIO retains control after execution. It is important that the client mark any control-flow instructions that it does not want treated as application instructions as <em>meta</em> instructions. Doing so informs DynamoRIO that these instructions should execute natively rather than being trapped and redirected to new basic block fragments.</p>
<p>Through meta instructions, a client can add its own internal control flow or make a call to a native routine. The target of a meta call will not be brought into the code cache by DynamoRIO. However, such native calls need to be careful to remain transparent (see <a class="el" href="API_BT.html#sec_clean_call">Clean Calls</a>).</p>
<p>Meta instructions are normally observational, in which case they should not fault and should have a NULL translation field. It is possible to use meta instructions that deliberately fault, or that could fault by accessing application memory addresses, but only if the client handles all such faults. See <a class="el" href="API_BT.html#sec_translation">State Translation</a> for more information on fault handling.</p>
<p>Meta instructions are visible to client code, if using <a class="el" href="dr__ir__instr_8h.html#ac897243e24d71890e196586b8373b821">instr_get_next()</a> and <a class="el" href="dr__ir__instrlist_8h.html#a6491763e4a1534458a8d7034c8f69612">instrlist_first()</a>. To traverse only application (non-meta) instructions, a client can use the following API functions instead:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__ir__instr_8h.html#a4582a4fd2729419bfc1d0c5dfeb86ab9">instr_get_next_app</a>()</div>
<div class="line"><a class="code" href="dr__ir__instrlist_8h.html#a623d9a44310e4d3373f266633ee07322">instrlist_first_app</a>()</div>
</div><!-- fragment --><p>We recommend that clients follow a disciplined model that separates application code analysis versus insertion of instrumentation. The <a class="el" href="page_drmgr.html">Multi-Instrumentation Manager</a> Extension facilitates this by separating application transformation, application analysis, and instrumentation. However, even with this separation, label instructions and in some cases other meta instructions (e.g., from <a class="el" href="group__drwrap.html#ga0ae2e383b0005a46848c7d0497be563a">drwrap_replace_native()</a>) are added during application transformation which should be skipped during analysis. Using <a class="el" href="dr__ir__instrlist_8h.html#a623d9a44310e4d3373f266633ee07322">instrlist_first_app()</a> and <a class="el" href="dr__ir__instr_8h.html#a4582a4fd2729419bfc1d0c5dfeb86ab9">instr_get_next_app()</a> is recommended during application analysis: it automatically skips non-application (meta) instructions, which at that stage are guaranteed to be either labels or to have no effect on register state or other key aspects of application code analysis.</p>
<p>While DynamoRIO attempts to support arbitrary code transformations, its internal operation requires that we impose the following limitations:</p>
<ul>
<li>If there is more than one application branch, only the last can be conditional.</li>
<li>An application conditional branch must be the final instruction in the block.</li>
<li>There can only be one indirect branch (call, jump, or return) in a basic block, and it must be the final application branch in the block.</li>
<li>The exit control-flow of a block ending in a system call cannot be changed.</li>
<li>On AArch64, an ISB instruction (<a class="el" href="dr__ir__opcodes__arm_8h.html#a61dadd085c1777f559549e05962b2c9eabe0b717bb763bfb4078ff2ad712be3bb">OP_isb</a>) must be the last instruction in its block.</li>
</ul>
<p>Application instructions, or non-meta instructions, in addition to being processed (and followed if control flow), are also considered safe points for relocation for the rare times when DynamoRIO must move threads around. Thus a client should ensure that it is safe to re-start an application instruction at the translation field address provided.</p>
<h2><a class="anchor" id="sec_events_trace"></a>
Trace Creation</h2>
<p>DynamoRIO provides access to traces primarily through the trace-creation event, registered via <a class="el" href="dr__events_8h.html#ad47842a864b5d406e56d6ceddbab47ac">dr_register_trace_event()</a>. It is important to note that clients are not required to employ the trace-creation event to ensure full instrumentation. Rather, it is sufficient to perform all code modification using the basic block event. Any basic blocks that DynamoRIO chooses to place in a trace will contain all client modifications (unless the client behaves differently in the basic block hook when its <code>for_trace</code> parameter is true). The trace-creation event provides a mechanism for clients to instrument <em>hot</em> code separately.</p>
<p>The parameters to the trace-creation event hook are nearly identical to those of the basic block hook:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> new_trace(<span class="keywordtype">void</span> *drcontext, <span class="keywordtype">void</span> *tag, <a class="code" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *trace,</div>
<div class="line">                          <span class="keywordtype">bool</span> translating);</div>
</div><!-- fragment --><ul>
<li><code>drcontext</code> is a pointer to the input program's machine context. Clients should not inspect or modify the context; it is provided as an opaque pointer (i.e., <code>void *</code>) to be passed to API routines that require access to this internal data.</li>
<li><code>tag</code> is a unique identifier for the trace fragment.</li>
<li><code>bb</code> is a pointer to the list of instructions that comprise the trace. Clients can examine, manipulate, or completely replace the instructions in the list.</li>
<li><code>translating</code> indicates whether this callback is for trace creation (false) or is for address translation (true). This is further explained in <a class="el" href="API_BT.html#sec_translation">State Translation</a>.</li>
</ul>
<p>The return value of the trace callback should generally be DR_EMIT_DEFAULT; however, time-varying instrumentation or complex code transformations may need to return DR_EMIT_STORE_TRANSLATIONS. See <a class="el" href="API_BT.html#sec_translation">State Translation</a> for further details.</p>
<p>DynamoRIO calls the client-supplied event hook each time a trace is created, just before the trace is emitted into the code cache. Additionally, as each constituent basic block is added to the trace, DynamoRIO calls the basic block creation hook with the <code>for_trace</code> parameter set to true. In order to preserve basic block instrumentation inside of traces, a client need only act identically with respect to the <code>for_trace</code> parameter; it can ignore the trace event if its goal is to place instrumentation on all code.</p>
<p>The constituent basic blocks will be stitched together prior to insertion in the code cache: conditional branches will be realigned so that their fall-through target remains on the trace, and inlined indirect branches will be preceded by a comparison against the on-trace target.</p>
<p>If the basic block callback behaves differently based on the <code>for_trace</code> parameter, different instrumentation will exist in the trace as opposed to the standalone basic block. If the basic block corresponds to the application code at the start of the trace (i.e., it is a trace head), the trace will shadow the basic block and the trace will be executed preferentially. If <a class="el" href="dr__tools_8h.html#a65e5ee30d5f4226445ce589f5b41b720">dr_delete_fragment()</a> is called, it will also delete the trace first and may leave the basic block in place. The flush routines (<a class="el" href="dr__tools_8h.html#a5b02f80af80dcd6005bf6c70ae7e7ad7">dr_flush_region()</a>, <a class="el" href="dr__tools_8h.html#a9a3f791ec0b8edddf607612c6804709f">dr_delay_flush_region()</a>, <a class="el" href="dr__tools_8h.html#a57669d0e147191660153b928eca7f09b">dr_unlink_flush_region()</a>), however, will delete traces and basic blocks alike.</p>
<h2><a class="anchor" id="sec_events_translation"></a>
State Restoration</h2>
<p>If a client is only adding instrumentation (meta instructions) that do not reference application memory, and is not reordering or removing application instructions, then it need not register for this event. If, however, a client is modifying application code or adding instructions that could fault, the client must be capable of restoring the original context. DynamoRIO calls a state restoration event, registered via <a class="el" href="dr__events_8h.html#a46dc6ae264b5b293e889cc88ea808eab">dr_register_restore_state_event()</a> or <a class="el" href="dr__events_8h.html#a89881448b9890f44ef26eab71014e956">dr_register_restore_state_ex_event()</a>, whenever it needs to translate a code cache context to an original application context:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> restore_state(<span class="keywordtype">void</span> *drcontext, <span class="keywordtype">void</span> *tag, <a class="code" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *mcontext,</div>
<div class="line">                   <span class="keywordtype">bool</span> restore_memory, <span class="keywordtype">bool</span> app_code_consistent)</div>
<div class="line"><span class="keywordtype">void</span> restore_state_ex(<span class="keywordtype">void</span> *drcontext, <span class="keywordtype">bool</span> restore_memory,</div>
<div class="line">                      <a class="code" href="struct__dr__restore__state__info__t.html">dr_restore_state_info_t</a> *info)</div>
</div><!-- fragment --><p>See <a class="el" href="API_BT.html#sec_translation">State Translation</a> for further details.</p>
<h2><a class="anchor" id="sec_events_del"></a>
Basic Block and Trace Deletion</h2>
<p>DynamoRIO can also provide notification of fragment deletion via <a class="el" href="dr__events_8h.html#a94ddb3474f89f5fb63b726ac9edaf08e">dr_register_delete_event()</a>. The signature for this event callback is:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> fragment_deleted(<span class="keywordtype">void</span> *drcontext, <span class="keywordtype">void</span> *tag);</div>
</div><!-- fragment --><p>DynamoRIO calls this event hook each time it deletes a fragment from the code cache. Such information may be needed if the client maintains its own data structures about emitted fragment code that must be consistent across fragment deletions.</p>
<h2><a class="anchor" id="sec_events_wow64"></a>
Special System Calls</h2>
<p>For 32-bit applications on a 64-bit Windows kernel ("Windows-on-Windows-64" or "WOW64"), DynamoRIO treats the indirect call from 32-bit system libraries that transitions to WOW64 marshalling code as a system call, even though there are a few 32-bit instructions executed afterward on some versions of Windows. Tools monitoring calls and returns will need to also check for instructions being considered system calls.</p>
<p> 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
 </p>
<h1><a class="anchor" id="sec_decode"></a>
Decoding and Encoding</h1>
<p>As discussed in <a class="el" href="API_BT.html#sec_events_bb">Basic Block Creation</a> and <a class="el" href="API_BT.html#sec_events_trace">Trace Creation</a>, a client's primary interface to code inspection and manipulation is via the basic block and trace hooks. However, DynamoRIO also exports a rich set of functions and data structures to decode and encode instructions directly. The following subsections overview this functionality.</p>
<h2><a class="anchor" id="sec_Decoding"></a>
Decoding</h2>
<p>DynamoRIO provides several routines for decoding and disassembling instructions. The most common method for decoding is the <a class="el" href="dr__ir__decode_8h.html#a5ca2a278008e547130218e8cfde44e3d">decode()</a> routine, which populates an <a class="el" href="structinstr__t.html">instr_t</a> data structure with all information about the instruction (e.g., opcode and operand information).</p>
<p>When decoding instructions, clients must explicitly manage the <code><a class="el" href="structinstr__t.html">instr_t</a></code> data structure. For example, the following code shows how to use the <a class="el" href="dr__ir__instr_8h.html#af7e998e183e87480e7fd82240ff6633d">instr_init()</a>, <a class="el" href="dr__ir__instr_8h.html#aaf4d287021b012cde46a3f2502dde2af">instr_reset()</a>, and <a class="el" href="dr__ir__instr_8h.html#ab996c61a99fcf17880700e5adbbc6db1">instr_free()</a> routines to decode a sequence of arbritrary instructions:</p>
<div class="fragment"><div class="line"><a class="code" href="structinstr__t.html">instr_t</a> instr;</div>
<div class="line"><a class="code" href="dr__ir__instr_8h.html#af7e998e183e87480e7fd82240ff6633d">instr_init</a>(&amp;instr);</div>
<div class="line"><span class="keywordflow">do</span> {</div>
<div class="line">  <a class="code" href="dr__ir__instr_8h.html#aaf4d287021b012cde46a3f2502dde2af">instr_reset</a>(dcontext, &amp;instr);</div>
<div class="line">  pc = <a class="code" href="dr__ir__decode_8h.html#a5ca2a278008e547130218e8cfde44e3d">decode</a>(dcontext, pc, &amp;instr);</div>
<div class="line">  <span class="comment">/* check for invalid instr */</span></div>
<div class="line">  <span class="keywordflow">if</span> (pc == NULL)</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="dr__ir__instr_8h.html#a61b348667a4fc288e84e3f053033c075">instr_writes_memory</a>(&amp;instr)) {</div>
<div class="line">    <span class="comment">/* do some processing */</span></div>
<div class="line">  }</div>
<div class="line">} <span class="keywordflow">while</span> (pc &lt; stop_pc);</div>
<div class="line"><a class="code" href="dr__ir__instr_8h.html#ab996c61a99fcf17880700e5adbbc6db1">instr_free</a>(dcontext, &amp;instr);</div>
</div><!-- fragment --><p>DynamoRIO supports decoding multiple instruction set modes. See <a class="el" href="API_BT.html#sec_isa">Instruction Set Modes</a> for full details.</p>
<h2><a class="anchor" id="sec_InstrGen"></a>
Instruction Generation</h2>
<p>Clients can construct instructions from scratch in two different ways:</p>
<ol type="1">
<li>Using the INSTR_CREATE_opcode macros that fill in implicit operands automatically: <div class="fragment"><div class="line"><a class="code" href="structinstr__t.html">instr_t</a> *instr = <a class="code" href="dr__ir__macros__x86_8h.html#a648549a9f8c47a283ae9ffbd3a51fde8">INSTR_CREATE_dec</a>(dcontext, <a class="code" href="dr__ir__opnd_8h.html#ae6cf2a1e25144a7c81b3b3a4a89f8dda">opnd_create_reg</a>(REG_EDX));</div>
</div><!-- fragment --></li>
<li>Specifying the opcode and all operands (including implicit operands): <div class="fragment"><div class="line"><a class="code" href="structinstr__t.html">instr_t</a> *instr = <a class="code" href="dr__ir__instr_8h.html#a9d9a1662aed6669a42a8284dae0e8019">instr_create</a>(dcontext);</div>
<div class="line"><a class="code" href="dr__ir__instr_8h.html#acc1a1b2c972ea65f7d51c026180d4fd5">instr_set_opcode</a>(instr, <a class="code" href="dr__ir__opcodes__x86_8h.html#a726ca809ffd3d67ab4b8476646f26635ac291f7f1164c416847b0b47b0a922ed9">OP_dec</a>);</div>
<div class="line"><a class="code" href="dr__ir__instr_8h.html#aaf2fde49de7d8146936040b3a6819717">instr_set_num_opnds</a>(dcontext, instr, 1, 1);</div>
<div class="line"><a class="code" href="dr__ir__instr_8h.html#aa32ec5e76a43312c51b85dc26fb1b3bf">instr_set_dst</a>(instr, 0, <a class="code" href="dr__ir__opnd_8h.html#ae6cf2a1e25144a7c81b3b3a4a89f8dda">opnd_create_reg</a>(REG_EDX));</div>
<div class="line"><a class="code" href="dr__ir__instr_8h.html#a934c79e6d544708352907275c1a7cfc9">instr_set_src</a>(instr, 0, <a class="code" href="dr__ir__opnd_8h.html#ae6cf2a1e25144a7c81b3b3a4a89f8dda">opnd_create_reg</a>(REG_EDX));</div>
</div><!-- fragment --></li>
</ol>
<p>When using the second method, the exact order of operands and their sizes must match the templates that DynamoRIO uses. The INSTR_CREATE_ macros in <a class="el" href="dr__ir__macros_8h.html" title="Cross-platform instruction creation convenience macros.">dr_ir_macros.h</a> should be consulted to determine the order.</p>
<h2><a class="anchor" id="sec_Encoding"></a>
Encoding</h2>
<p>DynamoRIO's encoding routines take an instruction or list of instructions and encode them into the corresponding bit pattern:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__ir__encode_8h.html#a3d194e7ce235e330a28686db29ee5480">instr_encode</a>(), <a class="code" href="dr__ir__encode_8h.html#a04d414952f335eaee8221c2a0e65ea46">instrlist_encode</a>() </div>
</div><!-- fragment --><p>When encoding a control transfer instruction that targets another instruction, two encoding passes are performed: one to find the offset of the target instruction, and the other to link the control transfer to the proper target offset.</p>
<p>DynamoRIO is capable of encoding multiple instruction set modes. See <a class="el" href="API_BT.html#sec_isa">Instruction Set Modes</a> for details.</p>
<h2><a class="anchor" id="sec_disasm"></a>
Disassembly</h2>
<p>DynamoRIO provides several routines for printing instructions to a file or a buffer. These include <a class="el" href="dr__ir__disassemble_8h.html#a4f2549391d161b1cee7d620efef7b9ff">disassemble()</a>, <a class="el" href="dr__ir__disassemble_8h.html#a2666f0a7b808cfed991026f45fef31c6">opnd_disassemble()</a>, <a class="el" href="dr__ir__disassemble_8h.html#aa79cdac5ac955e946ee053adf2bf81db">instr_disassemble()</a>, <a class="el" href="dr__ir__disassemble_8h.html#a3834ea0272d09914b3f0156241a92965">instrlist_disassemble()</a>, <a class="el" href="dr__ir__disassemble_8h.html#a890a42d15aed23a7e0b0c81a23e7e2ac">disassemble_with_info()</a>, <a class="el" href="dr__ir__disassemble_8h.html#a0d650d53ee0c47b24b74703bb62a2c87">disassemble_from_copy()</a>, and <a class="el" href="dr__ir__disassemble_8h.html#a24a055e3c3228129c9b0229bfa3c9fdb">disassemble_to_buffer()</a>.</p>
<p>The style of disassembly can be controlled through the <a class="el" href="page_deploy.html#op_syntax_intel">-syntax_intel</a> (for Intel-style disassembly), <a class="el" href="page_deploy.html#op_syntax_att">-syntax_att</a> (for AT&amp;T-style disassembly), and <a class="el" href="page_deploy.html#op_syntax_arm">-syntax_arm</a> (for ARM-style disassembly) runtime options, or the <a class="el" href="dr__ir__disassemble_8h.html#ac5e34cc6c23ce496b13eebb043184552">disassemble_set_syntax()</a> function. The default disassembly style is DynamoRIO's custom style, which lists all operands (both implicit and explicit). The sources are listed first, followed by "-&gt;", and then the destinations. This provides more information than any of the other formats.</p>
<h2><a class="anchor" id="sec_IR_heap"></a>
Instruction Heap Allocation</h2>
<p>DynamoRIO's IR is designed for efficiency and a small footprint. By default, space for operands is dynamically allocated from the heap. This can be problematic when using instructions in fragile locations such as signal handlers. DR provides a separate instruction structure for such situations: <a class="el" href="structinstr__noalloc__t.html">instr_noalloc_t</a>. This structure contains built-in storage for all possible operand slots and for temporary encoding space, avoiding heap allocation when used for decoding or encoding.</p>
<p>To use <a class="el" href="structinstr__noalloc__t.html">instr_noalloc_t</a>, declare it and then obtain a pointer to it as an <a class="el" href="structinstr__t.html">instr_t</a> structure for use with API functions:</p>
<div class="fragment"><div class="line"><a class="code" href="structinstr__noalloc__t.html">instr_noalloc_t</a> noalloc;</div>
<div class="line"><a class="code" href="dr__ir__instr_8h.html#a2b0ce5e5125951e4a7dfdc5ac716282a">instr_noalloc_init</a>(dcontext, &amp;noalloc);</div>
<div class="line"><a class="code" href="structinstr__t.html">instr_t</a> *instr = <a class="code" href="dr__ir__instr_8h.html#a75a82f341d4ea6a5b5f29f2ef1263355">instr_from_noalloc</a>(&amp;noalloc);</div>
<div class="line">pc = <a class="code" href="dr__ir__decode_8h.html#a5ca2a278008e547130218e8cfde44e3d">decode</a>(dcontext, ptr, instr);</div>
</div><!-- fragment --><p>No freeing is required. To re-use the same no-alloc structure, <a class="el" href="dr__ir__instr_8h.html#aaf4d287021b012cde46a3f2502dde2af">instr_reset()</a> can be called on its <a class="el" href="structinstr__t.html">instr_t</a> pointer.</p>
<p> 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
 </p>
<h1><a class="anchor" id="sec_isa"></a>
Instruction Set Modes</h1>
<p>Some architectures support multiple instruction set modes. The AMD64 build of DynamoRIO is capable of decoding and encoding 32-bit IA-32 instructions, while the 32-bit ARM build is capable of decoding and encoding both ARM and Thumb modes.</p>
<p>In DynamoRIO, each thread has a current mode that is used to determine how to interpret instructions while decoding, whose default matches the DynamoRIO build. The <a class="el" href="dr__ir__encode_8h.html#ae796d2ff6eabe43904b17742deafd637">dr_set_isa_mode()</a> routine changes the current mode, while <a class="el" href="dr__ir__encode_8h.html#ae8f9b08f90490fbeae26d12a461af084">dr_get_isa_mode()</a> queries the current mode.</p>
<p>Additionally, each instruction contains a flag indicating the mode in which it should be encoded. When an instruction is created or decoded, the instruction's flag is set to the thread's current mode. It can be queried with <a class="el" href="dr__ir__instr_8h.html#a4362c9281f6555d65240e447eed9e5c0">instr_get_isa_mode()</a> and changed with <a class="el" href="dr__ir__instr_8h.html#aa61dd047ca3e81daf2ff7b38835cd446">instr_set_isa_mode()</a>.</p>
<h2><a class="anchor" id="sec_64bit"></a>
64-bit Versus 32-bit Instructions</h2>
<p>The 64-bit build of DynamoRIO uses 64-bit decoding and encoding by default, while the 32-bit build uses 32-bit. The 64-bit build is also capable of decoding and encoding 32-bit instructions.</p>
<p>For a 64-bit build of DynamoRIO, the instruction creation macros all use 64-bit-sized registers. The recommended model when generating 32-bit code is to use the macros to create an instruction list and before encoding to call instr_set_isa_mode(DR_ISA_IA32) and <a class="el" href="dr__ir__instr_8h.html#a9a324bfca6929954eacc80dfc67086c9">instr_shrink_to_32_bits()</a> on each instruction. Naturally any instruction that differs in more than register selection must be special-cased.</p>
<h2><a class="anchor" id="sec_thumb"></a>
Thumb Mode Addresses</h2>
<p>For 32-bit ARM, target addresses passed as event callbacks, as clean call targets, or as <a class="el" href="dr__ir__utils_8h.html#ac3aa7797e4e3ce2f741f99712bb704f5">dr_redirect_execution()</a> targets should have their least significant bit set to 1 if they need to be executed in Thumb mode (<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa3f721209faa0616ff181a7bf207a59cc">DR_ISA_ARM_THUMB</a>). Addresses obtained via <a class="el" href="dr__modules_8h.html#acb571b80307fd90538cb006725ab6183">dr_get_proc_address()</a>, or function pointers at the source code level, should automatically have this property. <a class="el" href="dr__ir__decode_8h.html#a381ea062dea188809a558f9ed8613697">dr_app_pc_as_jump_target()</a> can also be used to construct the proper address from an aligned value.</p>
<p>When decoding, if the target address has its least significant bit set to 1, the decoder switches to Thumb mode for the duration of the decoding, regardless of the current thread's mode.</p>
<p> 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
 </p>
<h1><a class="anchor" id="sec_IR_utils"></a>
Utilities</h1>
<p>In addition to instruction decoding and encoding, the API includes several higher-level routines to facilitate code instrumentation. These include the following:</p>
<ul>
<li>Routines to insert clean calls to client-defined functions.</li>
<li>Routines to instrument control-flow instructions.</li>
<li>Routines to spill registers to DynamoRIO's thread-private spill slots.</li>
<li>Routines to quickly save and restore arithmetic flags, floating-point state, and MMX/SSE registers.</li>
</ul>
<p>The following subsections describe these routines in more detail.</p>
<h2><a class="anchor" id="sec_clean_call"></a>
Clean Calls</h2>
<p>To make it easy to insert code into the application instruction stream, DynamoRIO provides a <em>clean call</em> mechanism, which allows insertion of a transparent call to a client routine. The <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a> routine takes care of switching to a clean stack, setting up arguments to a call and making the call, optionally preserving floating point state, and preserving application state across the entire sequence.</p>
<p>Here is an example of inserting a clean call to the <code>at_mbr</code> function:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="dr__ir__instr_8h.html#a9f22e2640d0b987341ee87b8b6c9fa16">instr_is_mbr</a>(instr)) {</div>
<div class="line">  app_pc address = <a class="code" href="dr__ir__instr_8h.html#a090b27b5334c6be542c4fcfed7b97ffb">instr_get_app_pc</a>(instr);</div>
<div class="line">  uint opcode = <a class="code" href="dr__ir__instr_8h.html#a99682422e3f2060e3b85a61ef7e4fbbb">instr_get_opcode</a>(instr);</div>
<div class="line">  <a class="code" href="structinstr__t.html">instr_t</a> *nxt = <a class="code" href="dr__ir__instr_8h.html#ac897243e24d71890e196586b8373b821">instr_get_next</a>(instr);</div>
<div class="line">  <a class="code" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call</a>(drcontext, ilist, nxt, (<span class="keywordtype">void</span> *) at_mbr,</div>
<div class="line">                       <span class="keyword">false</span><span class="comment">/*don&#39;t need to save fp state*/</span>,</div>
<div class="line">                       2 <span class="comment">/* 2 parameters */</span>,</div>
<div class="line">                       <span class="comment">/* opcode is 1st parameter */</span></div>
<div class="line">                       <a class="code" href="dr__ir__macros_8h.html#aa32fcd12a03eb97ef42ded7b68a85203">OPND_CREATE_INT32</a>(opcode),</div>
<div class="line">                       <span class="comment">/* address is 2nd parameter */</span></div>
<div class="line">                       <a class="code" href="dr__ir__macros_8h.html#a74d7ad05e5371236dfd5b91b0767b690">OPND_CREATE_INTPTR</a>(address));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Through this mechanism, clients can write analysis code in C or other high-level languages and easily insert calls to these routines in the instruction stream. Note, however, that saving and restoring machine state is an expensive operation. Performance-critical operations should be inlined for maximum efficiency.</p>
<p>The stack that DynamoRIO switches to for clean calls is relatively small: only 20KB by default. Clients can increase the size of the stack with the <a class="el" href="page_deploy.html#op_stack_size">-stack_size</a> runtime option. Clients should also avoid keeping persistent state on the clean call stack, as it is wiped clean at the start of each clean call.</p>
<p>The saved interrupted application state can be accessed using <a class="el" href="dr__ir__utils_8h.html#a9e348b2596b8750ce3fad234ab022ced">dr_get_mcontext()</a> and modified using <a class="el" href="dr__ir__utils_8h.html#ac4bfa7fc3f9d4adb0857675bec2712a2">dr_set_mcontext()</a>.</p>
<p>For performance reasons, clean calls do not save or restore floating point, MMX, or SSE state by default. If the clean callee is using floating point or multimedia operations, it should request that the clean call mechanism preserve the floating point state through the appropriate parameter to <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a>. See also <a class="el" href="transparency.html#sec_trans_floating_point">Floating Point State, MMX, and SSE Transparency</a>.</p>
<p>If more detailed control over the call sequence is desired, it can be broken down into its constituent pieces:</p>
<ul>
<li><a class="el" href="dr__ir__utils_8h.html#a537f64152425259b2deda82cee6c90c4">dr_prepare_for_call()</a></li>
<li>Optionally, <a class="el" href="dr__ir__utils_8h.html#aa23665c11b7d79a29ea185113d07944f">dr_insert_save_fpstate()</a></li>
<li><a class="el" href="dr__ir__utils_8h.html#a0258cfa82416ee2ba40ed73e4d4eebf7">dr_insert_call()</a></li>
<li>Optionally, <a class="el" href="dr__ir__utils_8h.html#a74016eacf3a9cfc20a93a9ac0bca9c59">dr_insert_restore_fpstate()</a></li>
<li><a class="el" href="dr__ir__utils_8h.html#a86baaebf4ce92dc4a3090f293ff050e0">dr_cleanup_after_call()</a></li>
</ul>
<p>DynamoRIO analyzes the callee target of each clean call and attempts to reduce the context switch size and, if the callee is simple enough, to automatically inline it. This analysis and potential inlining works best when the callee is fully optimized. Thus, we recommend using high optimization levels in clients, even when running DynamoRIO itself in debug build in order to examine whether callees are being inlined. See <a class="el" href="page_deploy.html#op_cleancall">-opt_cleancall</a> for information on how to adjust the aggressiveness of these optimizations and for a list of specific conditions that affect inlining.</p>
<h2><a class="anchor" id="sec_state"></a>
State Preservation</h2>
<p>To facilitate code transformations, DynamoRIO makes available its register spill slots and other state preservation functionality. It exports API routines for saving and restoring registers to and from thread-local spill slots:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__ir__utils_8h.html#ae8479716f08bbbb36d7fd27cfbbc0743">dr_save_reg</a>(), <a class="code" href="dr__ir__utils_8h.html#a97e9767e1ff0f426b552a5f18c528ced">dr_restore_reg</a>(), and <a class="code" href="dr__ir__utils_8h.html#ab633296eeff7b481e148ef78aad56722">dr_reg_spill_slot_opnd</a>() </div>
</div><!-- fragment --><p>The values stored in these spill slots remain valid until the next application (i.e. non-meta) instruction and as such can be accessed from clean calls using:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__ir__utils_8h.html#a6fdc15ea04e8d17fa537832acf274d9c">dr_read_saved_reg</a>(), <a class="code" href="dr__ir__utils_8h.html#a178b4afb7bc059afbb92e9bee3572ca0">dr_write_saved_reg</a>() </div>
</div><!-- fragment --><p>For longer term persistence DynamoRIO also provides a generic dedicated thread-local storage field for use by clients, making it easy to write thread-aware clients. From C code, use:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__tools_8h.html#aaa04a14c2cbf783b4926c2fd14445f82">dr_get_tls_field</a>(), <a class="code" href="dr__tools_8h.html#a534b38808801da50be64b9f0e6c8616f">dr_set_tls_field</a>() </div>
</div><!-- fragment --><p>To access this thread-local field from the code cache, use the following routines to generate the necessary code:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__ir__utils_8h.html#aab7b4392c68e53f807bba5791183f240">dr_insert_read_tls_field</a>(), <a class="code" href="dr__ir__utils_8h.html#a06b5104ef0d55577cee0f66bd9a0051f">dr_insert_write_tls_field</a>() </div>
</div><!-- fragment --><p>Since saving and restoring the <code>eflags</code> register is required for almost all code transformations, and since it is difficult to do so efficiently, we export routines that use our efficient method of arithmetic flag preservation:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__ir__utils_8h.html#abd9f556b8175c4ac72d8e7df8295f121">dr_save_arith_flags</a>(), <a class="code" href="dr__ir__utils_8h.html#a31b8fd731ecc840fcddda04c36a7eadd">dr_restore_arith_flags</a>() </div>
</div><!-- fragment --><p>As just discussed in <a class="el" href="API_BT.html#sec_clean_call">Clean Calls</a>, we also export convenience routines for making <em>clean</em> (i.e., transparent) native calls from the code cache, as well as floating point and multimedia state preservation.</p>
<h2><a class="anchor" id="sec_branch_instru"></a>
Branch Instrumentation</h2>
<p>DynamoRIO provides explicit support for instrumenting call instructions, direct (or unconditional) branches, indirect (or multi-way) branches, and conditional branches. These convenience routines insert clean calls to client-provided methods, passing as arguments the instruction pc and target pc of each control transfer, along with taken or not taken information for conditional branches:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__ir__utils_8h.html#aa27020a55e63afdf3e053dbe4a34ab97">dr_insert_call_instrumentation</a>()</div>
<div class="line"><a class="code" href="dr__ir__utils_8h.html#a94534e7600a651b001a5d3e19227895b">dr_insert_ubr_instrumentation</a>()</div>
<div class="line"><a class="code" href="dr__ir__utils_8h.html#ac50b49843cf02a5b5f91fc6b5264cc7c">dr_insert_mbr_instrumentation</a>()</div>
<div class="line"><a class="code" href="dr__ir__utils_8h.html#a5269cd8806aee4e6aa1edbb4af79c09a">dr_insert_cbr_instrumentation</a>()</div>
</div><!-- fragment --><h2><a class="anchor" id="sec_adaptive"></a>
Dynamic Instrumentation</h2>
<p>DynamoRIO allows a client to dynamically adjust its instrumentation by providing a routine to flush all cached fragments corresponding to an application code region and register (or unregister) instrumentation event callbacks:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__tools_8h.html#aa9d4ad288807e3c033ab54013d8a49a4">dr_flush_region_ex</a>()</div>
</div><!-- fragment --><p>The client should provide a callback to this routine, that unregisters old instrumentation event callbacks, and registers new ones.</p>
<p>In order to directly modify the instrumentation on a particular fragment (as opposed to replacing instrumentation on all copies of fragments corresponding to particular application code), DynamoRIO also supports directly replacing an existing fragment with a new <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__tools_8h.html#a3c602c9d795079655bc599550cb4492b">dr_replace_fragment</a>()</div>
</div><!-- fragment --><p>However, this routine is only supported when running with the <a class="el" href="page_deploy.html#op_thread_priv">-thread_private</a> runtime option, and it replaces the fragment for the current thread only. A client can call this routine even while inside the to-be-replaced fragment (e.g., in a clean call from inside the fragment). In this scenario, the old fragment is executed to completion and the new code is inserted before the next execution.</p>
<p>For example usage, see the client sample <a class="el" href="API_samples.html#sec_ex3">Modifying Existing Instrumentation</a>.</p>
<h2><a class="anchor" id="sec_custom_traces"></a>
Custom Traces</h2>
<p>DynamoRIO combines frequently executed sequences of basic blocks into <em>traces</em>. It uses a simple profiling scheme based on <em>trace heads</em>, which are the targets of backward branches or exits from existing traces. Execution counters are kept for each trace head. Once a head crosses a threshold, the next sequence of basic blocks that are executed becomes a new trace.</p>
<p>DynamoRIO allows a client to build custom traces by marking its own trace heads (<em>in addition</em> to DynamoRIO's normal trace heads) and deciding when to end traces. If a client registers for the following event, DynamoRIO will call its hook before extending a trace (with tag <code>trace_tag</code>) with a new basic block (with tag <code>next_tag</code>):</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> query_end_trace(<span class="keywordtype">void</span> *drcontext, <span class="keywordtype">void</span> *trace_tag, <span class="keywordtype">void</span> *next_tag);</div>
</div><!-- fragment --><p>The client hook returns one of these values:</p><ul>
<li>CUSTOM_TRACE_DR_DECIDES = use standard termination criteria</li>
<li>CUSTOM_TRACE_END_NOW = end trace now</li>
<li>CUSTOM_TRACE_CONTINUE = do not end trace</li>
</ul>
<p>If using standard termination criteria, DynamoRIO ends the trace if it reaches a trace head or another trace (or certain corner-case basic blocks that cannot be part of a trace).</p>
<p>The client can also mark any basic block as a trace head with </p><div class="fragment"><div class="line"><a class="code" href="dr__tools_8h.html#a15aa23aae4a1d322fbe0a1cffedbaf3a">dr_mark_trace_head</a>() </div>
</div><!-- fragment --><p>For example usage, see the callee-inlining client sample <a class="el" href="API_samples.html#sec_ex5">Custom Tracing</a>.</p>
<p> 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
 </p>
<h1><a class="anchor" id="sec_reg_stolen"></a>
Register Stolen by DynamoRIO</h1>
<p>On some architectures, e.g., ARM and AArch64, DynamoRIO steals a register for holding the base of DynamoRIO's own TLS (Thread-Local Storage). DynamoRIO guarantees the correctness of the application execution by saving and restoring the stolen register's value before and after that register is used by each application instruction. DynamoRIO also guarantees the stolen register's value is stored in the application machine context (dr_mcontext_t) for client use at event callbacks or clean calls. However, DynamoRIO exposes the stolen register to the client and places the burden on the client to ensure the correctness of its instrumentation.</p>
<p>The client can use <a class="el" href="dr__ir__opnd_8h.html#aff8f178ccfbc5b12bf3813656ba5da71">reg_is_stolen()</a> or <a class="el" href="dr__ir__utils_8h.html#ad7af9296c9f5930b025186aea0688b13">dr_get_stolen_reg()</a> to identify the stolen register. To use the application value of the stolen register in the inserted code, the client must first use <a class="el" href="dr__ir__utils_8h.html#a7a38641e89e2573d725ec05d137e0fb6">dr_insert_get_stolen_reg_value()</a> to insert code to get the value into another register. Otherwise, the TLS base value might be used instead. Similarly, the client should use <a class="el" href="dr__ir__utils_8h.html#aa14654096a7b89666f82e4566a7d1e4c">dr_insert_set_stolen_reg_value()</a> to set the application value of the stolen register.</p>
<p> 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
 </p>
<h1><a class="anchor" id="sec_translation"></a>
State Translation</h1>
<p>To support transparent fault handling, DynamoRIO must translate a fault in the code cache into a fault at the corresponding application address. DynamoRIO must also be able to translate when a suspended thread is examined by the application or by DynamoRIO itself for internal synchronization purposes.</p>
<p>If a client is only adding observational instrumentation (i.e., <a class="el" href="API_BT.html#sec_Meta">Application Versus Meta Instructions</a>) (which should not fault) and is not modifying, reordering, or removing application instructions, these details can be ignored. In that case the client's basic block and trace callbacks should return <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a7d25c4546544d1a8c0b77c69230772eb">DR_EMIT_DEFAULT</a> in addition to being deterministic and idempotent (i.e., DynamoRIO should be able to repeatedly call the callback and receive back the same resulting instruction list, with no net state changes to the client).</p>
<p>If a client is performing modifications, then in order for DynamoRIO to properly translate a code cache address the client must use <a class="el" href="dr__ir__instr_8h.html#a463d5a15e50d1578dce60bc44343eb1a">instr_set_translation()</a> (chainable via <a class="el" href="dr__ir__macros_8h.html#ad21fbdff8a5631b3e31b8221180a2a9c">INSTR_XL8()</a>) in the basic block and trace creation callbacks to set the corresponding application address for each added meta instruction that can fault, each modified instruction, and each added application instruction. The translation value is the application address that should be presented to the application as the faulting address, or the application address that should be restarted after a suspend. Currently the translation address must be within the existing range of source addresses for the basic block or trace.</p>
<p>There are two methods for using the translated addresses:</p>
<ol type="1">
<li>Return <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> from the basic block creation callback. DR will then store the translation addresses and use the stored information on a fault. The basic block callback for <code>tag</code> will not be called with <code>translating</code> set to true. Note that unless <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> is also returned for <code>for_trace</code> calls (or <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> is returned in the trace callback), each constituent block comprising the trace will need to be re-created with both <code>for_trace</code> and <code>translating</code> set to true. Storing translations uses additional memory that can be significant: up to 20% in some cases, as it prevents DR from using its simple data structures and forces it to fall back to its complex, corner-case design. This is why DR does not store all translations by default.</li>
<li>Return <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a7d25c4546544d1a8c0b77c69230772eb">DR_EMIT_DEFAULT</a> from the basic block or trace creation callback. DynamoRIO will then call the callback again during fault translation with <code>translating</code> set to true. All modifications to the instruction list that were performed on the creation callback must be repeated on the translating callback. This option is only posible when basic block modifications are deterministic and idempotent, but it saves memory. Naturally, global state changes triggered by block creation should be wrapped in checks for <code>translating</code> being false. Even in this case, <a class="el" href="dr__ir__instr_8h.html#a463d5a15e50d1578dce60bc44343eb1a">instr_set_translation()</a> should be called for appropriate instructions even when <code>translating</code> is false, as DynamoRIO may decide to store the translations at creation time for reasons of its own.</li>
</ol>
<p>Furthermore, if the client's modifications change any part of the machine state besides the program counter, the client should use <a class="el" href="dr__events_8h.html#a46dc6ae264b5b293e889cc88ea808eab">dr_register_restore_state_event()</a> or <a class="el" href="dr__events_8h.html#a89881448b9890f44ef26eab71014e956">dr_register_restore_state_ex_event()</a> (see <a class="el" href="API_BT.html#sec_events_translation">State Restoration</a>) to restore the registers to their original application values. DR attempts to reconstruct the <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> for the faulting fragment; this list contains all instrs added by the basic block event(s) with <code>translating</code> set to true, and also DR's own mangling of some instrs. If this reconstructed <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> is available, it will be passed on to the registered callback as part of <a class="el" href="dr__events_8h.html#ab5cb8a18ea3f099157d827cf09d6a8d8">dr_fault_fragment_info_t</a> in <a class="el" href="dr__events_8h.html#a7b60f2254adf92bc99ebd248f76044fe">dr_restore_state_info_t</a>. It may not be available when some or all clients returned <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a>, or for DR internal reasons when the app code may not be consistent: for pending deletion or self-modifying fragments.</p>
<p>For meta instructions that do not reference application memory (i.e., they should not fault), leave the translation field as NULL. A NULL value instructs DynamoRIO to use the subsequent application instruction's translation as the application address, and to fail when translating the full state. Since the full state will only be needed when relocating a thread (as stated, there will not be a fault here), failure indicates that this is not a valid relocation point, and DynamoRIO's thread synchronization scheme will use another spot. If the translation field is set to a non-NULL value, the client should be willing to also restore the rest of the machine state at that point (restore spilled registers, etc.) via <a class="el" href="dr__events_8h.html#a46dc6ae264b5b293e889cc88ea808eab">dr_register_restore_state_event()</a> or <a class="el" href="dr__events_8h.html#a89881448b9890f44ef26eab71014e956">dr_register_restore_state_ex_event()</a>. This is necessary for meta instructions that reference application memory or that may deliberately fault when accessing client memory. DynamoRIO takes care of such potentially-faulting instructions added by its own API routines (<a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a> arguments that reference application data, <a class="el" href="dr__ir__utils_8h.html#ac50b49843cf02a5b5f91fc6b5264cc7c">dr_insert_mbr_instrumentation()</a>'s read of application indirect branch data, etc.)</p>
<p>Here is an example of using the INSTR_XL8 macro to set the translation field for a meta instruction:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define PREM instrlist_meta_preinsert</span></div>
<div class="line"> </div>
<div class="line">app_pc xl8 = <a class="code" href="dr__ir__instr_8h.html#a090b27b5334c6be542c4fcfed7b97ffb">instr_get_app_pc</a>(inst);</div>
<div class="line">PREM(bb, inst, <a class="code" href="dr__ir__macros_8h.html#ad21fbdff8a5631b3e31b8221180a2a9c">INSTR_XL8</a>(<a class="code" href="dr__ir__macros__x86_8h.html#a9d0f07bc39f6e37f5f4a9836f342e077">INSTR_CREATE_mov_st</a>(drcontext, dst, src), xl8));</div>
</div><!-- fragment --><p> 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
 </p>
<h1><a class="anchor" id="sec_predication"></a>
Conditionally Executed Instructions</h1>
<p>DynamoRIO models conditionally executed, or "predicated", instructions as regular instructions with extra predication attributes. Use <a class="el" href="dr__ir__instr_8h.html#aa0dda1bdd960e675b6b65a4093b44896">instr_is_predicated()</a> to determine whether an instruction is conditionally executed. If so, use <a class="el" href="dr__ir__instr_8h.html#a19932f4d78cd67b02b3b4c657fba329f">instr_get_predicate()</a> to determine the type of condition. At execution time, <a class="el" href="dr__ir__instr_8h.html#a07d5832cf5ea24804b4c827b489f1ffc">instr_predicate_triggered()</a> can be used to query whether an instruction will execute or not.</p>
<p>The degree of conditional execution varies. In some cases, when an instruction is not executed, it will not read any source operands nor write any destination operands. In other cases, the condition on which it depends involves the value of a source operand (e.g., OP_bsf or OP_maskmovq). However, all conditionally executed instructions share the same property that their destination operands are conditionally written. This does not apply to eflags, which are written to unconditionally by some conditional instructions.</p>
<p>To aid in analyzing liveness and other properties of application code, all API routines that query whether registers or flags are written take a parameter of type <a class="el" href="dr__ir__instr_8h.html#afbf9138b89c5e6e8ea4ff2e9212b2277">dr_opnd_query_flags_t</a> that controls how to treat conditionally accessed operands: whether to include them or skip them.</p>
<p>API routines that operate on raw instruction information, such as <a class="el" href="dr__ir__instr_8h.html#a3574118088b6a3a5a9b3b7308da90ed7">instr_num_dsts()</a>, include all possible operands. Clients should explicitly query <a class="el" href="dr__ir__instr_8h.html#aa0dda1bdd960e675b6b65a4093b44896">instr_is_predicated()</a> when using API routines that do not take in <a class="el" href="dr__ir__instr_8h.html#afbf9138b89c5e6e8ea4ff2e9212b2277">dr_opnd_query_flags_t</a>.</p>
<p>As shorthand for emitting instrumentation that necessarily uses the same predicate as the current instruction, <code><a class="el" href="dr__ir__instrlist_8h.html#a36321a6f6cbdbcd1b0e4e03132e15e26">instrlist_set_auto_predicate()</a></code> is provided which will predicate all instructions inserted into an instruction list. Although writing to aflags is strictly forbidden, as is meta control flow, internal DR components such as <code><a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a></code> will gracefully handle this auto-predication setting and are safe for use with it.</p>
<p><code><a class="el" href="dr__ir__instrlist_8h.html#a0f3ebb7e7a847c44ab9518917ad0ce7b">instrlist_get_auto_predicate()</a></code> similarly may be used to query the current predicate desired for auto predication.</p>
<h2><a class="anchor" id="sec_it_blocks"></a>
IT Blocks</h2>
<p>On ARM AArch32, the Thumb mode includes conditional groups of instructions called IT blocks. The <a class="el" href="dr__ir__opcodes__arm_8h.html#a61dadd085c1777f559549e05962b2c9ea651b96b5040e974b49d32bf7f6277309">OP_it</a> header instruction indicates how many instructions are in the block and the direction of each instruction's conditional. Thus, inserting instrumentation inside the block without updating the header results in an unencodable instruction list. To solve this, we provide two API routines: <a class="el" href="dr__ir__utils_8h.html#ad2f75dd89d8a188f4a7fc9ae094bceaf">dr_remove_it_instrs()</a> and <a class="el" href="dr__ir__utils_8h.html#a1f2c05b5d49ca8dedfd52d7bbb2f59bb">dr_insert_it_instrs()</a>. The first simply removes the headers. Since the individual instructions from the blocks are marked with their condition in our IR, the header is not necessary for tools to analyze the instructions. The second re-instates the headers, creating a legal instruction list. This re-creation of the proper IT block headers occurs as a final phase in drmgr, after the instru2instru event. This means that the original <a class="el" href="dr__ir__opcodes__arm_8h.html#a61dadd085c1777f559549e05962b2c9ea651b96b5040e974b49d32bf7f6277309">OP_it</a> header instructions are present for clients to observe in the analysis phase.</p>
<p>Clients not using drmgr can call <a class="el" href="dr__ir__utils_8h.html#ad2f75dd89d8a188f4a7fc9ae094bceaf">dr_remove_it_instrs()</a> and then <a class="el" href="dr__ir__utils_8h.html#a1f2c05b5d49ca8dedfd52d7bbb2f59bb">dr_insert_it_instrs()</a> on their own.</p>
<p> 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
 </p>
<h1><a class="anchor" id="sec_ldrex"></a>
Exclusive Monitor Instrumentation</h1>
<p>On ARM and AArch64, a load-exclusive store-exclusive pair of instructions has some constraints that make inserting instrumentation in between the pair challenging. ARM/AArch64 hardware requires that an application minimize memory operations in between the load-exclusive and store-exclusive and minimize the total number of instructions in between. Violating this can result in failure to acquire the desired exclusive monitor, which is always done in a loop and can result in a non-terminating loop when the application is run with instrumentation.</p>
<p>Inserting a few memory references in between the pair works on some but not all hardware. Inserting something heavyweight like a clean call is very likely to result in a non-terminating loop.</p>
<p>By default, DynamoRIO converts each such sequence to a compare-and-swap sequence which can handle any amount of added instrumentation. However, compare-and-swap is not semantically identical: it does not detect "ABA" changes and could cause errors in lock-free data structures or other application constructs. This compare-and-swap conversion can be disabled with the runtime option <a class="el" href="page_deploy.html#op_ldstex2cas">no_ldstex2cas</a>.</p>
<p>If compare-and-swap conversion must be disabled, we recommend using inlined instrumentation with at most a few memory references in such regions, rather than clean calls. In general, this is the best performing strategy anyway for heavyweight tools that want to instrument every instruction. Take a look at the memtrace_simple and instrace_simple samples, which check for <a class="el" href="dr__ir__instr_8h.html#acfe56a8a97951fe69cab14cd7e46f16b">instr_is_exclusive_store()</a> to avoid a clean call in between. However, even this is not enough on some hardware, where instrumentation would have to be shifted to before and/or after the monitor region. The runtime option "-unsafe_build_ldstex" may be useful on AArch64 hardware that does not allow any loads or stores between an exclusive load and the corresponding exclusive store. With this option DynamoRIO tries to turn a sequence of instructions containing an exclusive load/store pair into a macro-instruction, which prevents any loads and stores from being inserted, but also prevents any of the instructions involved from being instrumented.</p>
<p> 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
 </p>
<h1><a class="anchor" id="sec_rseq"></a>
Restartable Sequence Instrumentation Constraints</h1>
<p>The Linux kernel supports special code regions called restartable sequences. This "rseq" feature is challenging to support under instrumentation due to the tight restrictions on operations inside the sequence. Instrumentation inserted in the sequence would need to be designed to be restartable as well, with a single commit point. Meeting such requirements is unrealistic for most instrumentation. Instead, DR provides a "run twice" solution where the sequence is first executed as regular code with regular instrumentation up to the commit point. Then the sequence is restarted and executed without instrumentation to perform the commit.</p>
<p>This run-twice approach is subject to the following limitations:</p>
<ul>
<li>Only x86 and aarch64 are supported for now, and 32-bit x86 is not as well-tested.</li>
<li>The application must store an rseq_cs struct for each rseq region in a section of its binary named "__rseq_cs", optionally with an "__rseq_cs_ptr_array" section of pointers into the __rseq_cs section, per established conventions. These sections must be located in loaded segments.</li>
<li>The application must use static thread-local storage for its struct rseq registrations.</li>
<li>The application must use the same signature for every rseq system call.</li>
<li>Each rseq region's code must never be also executed as a non-restartable sequence.</li>
<li>Each rseq region must handle being directly restarted without its abort handler being called (with the machine state restored: though just the general-purpose registers as described in the limitation below).</li>
<li>Each memory store instruction inside an rseq region must have no other side effects: it must only write to memory and not to any registers. For example, a push instruction which both writes to memory and the stack pointer register is not supported. An exception is a pre-indexed or post-indexed writeback store, which is supported.</li>
<li>Each rseq region's code must end with a fall-through (non-control-flow) instruction.</li>
<li>Indirect branches that do not exit the rseq region are not allowed.</li>
<li>Each rseq region must be entered only from the top, with no branches from outside the region targeting a point inside the region.</li>
<li>No system calls are allowed inside rseq regions.</li>
<li>No call instructions are allowed inside rseq regions.</li>
<li>The only register inputs to an rseq region, or registers written inside an rseq region whose values are then read afterward, must be general-purpose registers.</li>
<li>The instrumented execution of the rseq region may not perfectly reflect the native behavior of the application. The instrumentation will never see an abort anywhere but just prior to the committing store. Additionally, memory addresses may be wrong if they are based on the live (as opposed to cached at the rseq region entrance) underlying cpuid and a migration occurred mid-region. These are minor and acceptable for most tools (especially given that there is no better alternative).</li>
</ul>
<p>Some of these limitations are explicitly checked, and DR will exit with an error message if they are not met. However, not all are efficiently verifiable. If an application does not satisfy these limitations, the <a class="el" href="page_deploy.html#op_disable_rseq">disable_rseq</a> runtime option may be used to return ENOSYS, which can provide a workaround for applications which have fallback code for kernels where rseq is not supported.</p>
<p> 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
 </p>
<h1><a class="anchor" id="sec_pcache"></a>
Persisting Code</h1>
<p>Decoding, instrumenting, and emitting code into the code cache takes time. Short-running applications, or applications that execute large amounts of code with little code re-use, can incur noticeable overhead when run under DynamoRIO. One solution is to write the code cache to a file for fast re-use on subsequent runs by simply loading the file. DynamoRIO provides support for tools to persist their instrumented code.</p>
<p>First, the <a class="el" href="page_deploy.html#op_persist">-persist</a> runtime option, and optionally <code>-persist_dir</code>, must be set in order for any caches to be persisted. Only basic block persistence is supported: no traces. In the presence of a client, basic blocks by default are not persisted. Only if the return value of the basic block event callback includes the DR_EMIT_PERSISTABLE flag is a block eligible for persistence. Even then, there are further constraints on persistence, as only simple blocks are persistable.</p>
<p>Persisted caches end in the extension <code></code>.dpc, for DynamoRIO Persisted Cache, and are stored in the directory specified by the <code>-persist_dir</code> runtime option, or the log directory if unspecified, inside a per-user subdirectory.</p>
<p>A client may need to store data in the persisted file in order to determine whether it is re-usable when loaded again, or to provide generated code or other auxiliary data or code that the persisted code requires. A set of events are provided for this purpose. These events allow a client to store three types of data in a persisted file, beyond instrumented code inside each basic block: read-only data, executed code (outside of basic blocks), and writable data. The types of data are separated because the file is laid out in different protection zones. Read-only data can be added using <a class="el" href="dr__events_8h.html#a825819cfee635c11b8d43070d09611ce">dr_register_persist_ro()</a>, executable code using <a class="el" href="dr__events_8h.html#a0e3991d3fc34318385c4e1d7279ba4ef">dr_register_persist_rx()</a>, and writable data using <a class="el" href="dr__events_8h.html#aad426e6c0afbb889d0b90f23a98bf6cc">dr_register_persist_rw()</a>. Additionally, the basic blocks to be persisted can be patched using <a class="el" href="dr__events_8h.html#a15a89c0af1a58f59b80649aaeda219fc">dr_register_persist_patch()</a>.</p>
<p>Whenever code is about to be persisted, DynamoRIO will call all of the registered events for that module. A user data parameter can be used to share information across the event callbacks.</p>
<p>Clients are cautioned to ensure their instrumentation is either position-independent or properly patched to operate correctly when the client library base or the persisted code addresses change. For example, if inserted instrumentation includes calls or jumps into the client library, these can be persisted unchanged if the client also stores its base address in the read-only section and in the resurrection callback checks it against its current base address. On a mismatch, the persisted file must be rejected. A more sophisticated approach requires indirection, position independence in the code, or patching.</p>
<p>DynamoRIO itself ensures that a persisted file is only re-used if its application module has not changed, if the set of clients in use is identical to those present on creation of the file, and that the TLS offset is identical. The application module check currently includes the base address on Windows, which precludes re-using persisted files for libraries loaded at different addresses via ASLR. (In the future we plan to provide application relocation support, but it is not there today.). The client check is based on the absolute paths. If a client needs to validate based on its runtime options, or do a version check based on its own changing instrumentation, it must do that on its own in the event callbacks. The TLS check ensures that TLS scratch slots are identical. DynamoRIO also ensures that any runtime options that affect persistent code (such as whether traces are enabled) are identical. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="astruct__dr__mcontext__t_html"><div class="ttname"><a href="struct__dr__mcontext__t.html">_dr_mcontext_t</a></div><div class="ttdef"><b>Definition:</b> dr_defines.h:765</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_a31b8fd731ecc840fcddda04c36a7eadd"><div class="ttname"><a href="dr__ir__utils_8h.html#a31b8fd731ecc840fcddda04c36a7eadd">dr_restore_arith_flags</a></div><div class="ttdeci">DR_API void dr_restore_arith_flags(void *drcontext, instrlist_t *ilist, instr_t *where, dr_spill_slot_t slot)</div></div>
<div class="ttc" id="adr__tools_8h_html_a15aa23aae4a1d322fbe0a1cffedbaf3a"><div class="ttname"><a href="dr__tools_8h.html#a15aa23aae4a1d322fbe0a1cffedbaf3a">dr_mark_trace_head</a></div><div class="ttdeci">DR_API bool dr_mark_trace_head(void *drcontext, void *tag)</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_aaf2fde49de7d8146936040b3a6819717"><div class="ttname"><a href="dr__ir__instr_8h.html#aaf2fde49de7d8146936040b3a6819717">instr_set_num_opnds</a></div><div class="ttdeci">DR_API void instr_set_num_opnds(void *drcontext, instr_t *instr, int num_dsts, int num_srcs)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_a5269cd8806aee4e6aa1edbb4af79c09a"><div class="ttname"><a href="dr__ir__utils_8h.html#a5269cd8806aee4e6aa1edbb4af79c09a">dr_insert_cbr_instrumentation</a></div><div class="ttdeci">DR_API void dr_insert_cbr_instrumentation(void *drcontext, instrlist_t *ilist, instr_t *instr, void *callee)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_ab633296eeff7b481e148ef78aad56722"><div class="ttname"><a href="dr__ir__utils_8h.html#ab633296eeff7b481e148ef78aad56722">dr_reg_spill_slot_opnd</a></div><div class="ttdeci">DR_API opnd_t dr_reg_spill_slot_opnd(void *drcontext, dr_spill_slot_t slot)</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_a4582a4fd2729419bfc1d0c5dfeb86ab9"><div class="ttname"><a href="dr__ir__instr_8h.html#a4582a4fd2729419bfc1d0c5dfeb86ab9">instr_get_next_app</a></div><div class="ttdeci">DR_API INSTR_INLINE instr_t * instr_get_next_app(instr_t *instr)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_a06b5104ef0d55577cee0f66bd9a0051f"><div class="ttname"><a href="dr__ir__utils_8h.html#a06b5104ef0d55577cee0f66bd9a0051f">dr_insert_write_tls_field</a></div><div class="ttdeci">DR_API void dr_insert_write_tls_field(void *drcontext, instrlist_t *ilist, instr_t *where, reg_id_t reg)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_ae8479716f08bbbb36d7fd27cfbbc0743"><div class="ttname"><a href="dr__ir__utils_8h.html#ae8479716f08bbbb36d7fd27cfbbc0743">dr_save_reg</a></div><div class="ttdeci">DR_API void dr_save_reg(void *drcontext, instrlist_t *ilist, instr_t *where, reg_id_t reg, dr_spill_slot_t slot)</div></div>
<div class="ttc" id="adr__ir__decode_8h_html_a5ca2a278008e547130218e8cfde44e3d"><div class="ttname"><a href="dr__ir__decode_8h.html#a5ca2a278008e547130218e8cfde44e3d">decode</a></div><div class="ttdeci">DR_API byte * decode(void *drcontext, byte *pc, instr_t *instr)</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_aa32ec5e76a43312c51b85dc26fb1b3bf"><div class="ttname"><a href="dr__ir__instr_8h.html#aa32ec5e76a43312c51b85dc26fb1b3bf">instr_set_dst</a></div><div class="ttdeci">DR_API void instr_set_dst(instr_t *instr, uint pos, opnd_t opnd)</div></div>
<div class="ttc" id="adr__ir__instrlist_8h_html_a6491763e4a1534458a8d7034c8f69612"><div class="ttname"><a href="dr__ir__instrlist_8h.html#a6491763e4a1534458a8d7034c8f69612">instrlist_first</a></div><div class="ttdeci">DR_API instr_t * instrlist_first(instrlist_t *ilist)</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_aaf4d287021b012cde46a3f2502dde2af"><div class="ttname"><a href="dr__ir__instr_8h.html#aaf4d287021b012cde46a3f2502dde2af">instr_reset</a></div><div class="ttdeci">DR_API void instr_reset(void *drcontext, instr_t *instr)</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_a2b0ce5e5125951e4a7dfdc5ac716282a"><div class="ttname"><a href="dr__ir__instr_8h.html#a2b0ce5e5125951e4a7dfdc5ac716282a">instr_noalloc_init</a></div><div class="ttdeci">DR_API void instr_noalloc_init(void *drcontext, instr_noalloc_t *instr)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_a94534e7600a651b001a5d3e19227895b"><div class="ttname"><a href="dr__ir__utils_8h.html#a94534e7600a651b001a5d3e19227895b">dr_insert_ubr_instrumentation</a></div><div class="ttdeci">DR_API void dr_insert_ubr_instrumentation(void *drcontext, instrlist_t *ilist, instr_t *instr, void *callee)</div></div>
<div class="ttc" id="adr__ir__macros__x86_8h_html_a648549a9f8c47a283ae9ffbd3a51fde8"><div class="ttname"><a href="dr__ir__macros__x86_8h.html#a648549a9f8c47a283ae9ffbd3a51fde8">INSTR_CREATE_dec</a></div><div class="ttdeci">#define INSTR_CREATE_dec(dc, d)</div><div class="ttdef"><b>Definition:</b> dr_ir_macros_x86.h:1579</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_a7bd1a4d1621b685541e8c28426a0cfe4"><div class="ttname"><a href="dr__ir__instr_8h.html#a7bd1a4d1621b685541e8c28426a0cfe4">instr_set_meta</a></div><div class="ttdeci">DR_API void instr_set_meta(instr_t *instr)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_a178b4afb7bc059afbb92e9bee3572ca0"><div class="ttname"><a href="dr__ir__utils_8h.html#a178b4afb7bc059afbb92e9bee3572ca0">dr_write_saved_reg</a></div><div class="ttdeci">DR_API void dr_write_saved_reg(void *drcontext, dr_spill_slot_t slot, reg_t value)</div></div>
<div class="ttc" id="astruct__dr__restore__state__info__t_html"><div class="ttname"><a href="struct__dr__restore__state__info__t.html">_dr_restore_state_info_t</a></div><div class="ttdef"><b>Definition:</b> dr_events.h:664</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_a090b27b5334c6be542c4fcfed7b97ffb"><div class="ttname"><a href="dr__ir__instr_8h.html#a090b27b5334c6be542c4fcfed7b97ffb">instr_get_app_pc</a></div><div class="ttdeci">DR_API app_pc instr_get_app_pc(instr_t *instr)</div></div>
<div class="ttc" id="adr__ir__opcodes__x86_8h_html_a726ca809ffd3d67ab4b8476646f26635ac291f7f1164c416847b0b47b0a922ed9"><div class="ttname"><a href="dr__ir__opcodes__x86_8h.html#a726ca809ffd3d67ab4b8476646f26635ac291f7f1164c416847b0b47b0a922ed9">OP_dec</a></div><div class="ttdeci">@ OP_dec</div><div class="ttdef"><b>Definition:</b> dr_ir_opcodes_x86.h:86</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_a934c79e6d544708352907275c1a7cfc9"><div class="ttname"><a href="dr__ir__instr_8h.html#a934c79e6d544708352907275c1a7cfc9">instr_set_src</a></div><div class="ttdeci">DR_API void instr_set_src(instr_t *instr, uint pos, opnd_t opnd)</div></div>
<div class="ttc" id="adr__ir__macros_8h_html_ad21fbdff8a5631b3e31b8221180a2a9c"><div class="ttname"><a href="dr__ir__macros_8h.html#ad21fbdff8a5631b3e31b8221180a2a9c">INSTR_XL8</a></div><div class="ttdeci">#define INSTR_XL8(instr_ptr, app_addr)</div><div class="ttdef"><b>Definition:</b> dr_ir_macros.h:63</div></div>
<div class="ttc" id="adr__tools_8h_html_aaa04a14c2cbf783b4926c2fd14445f82"><div class="ttname"><a href="dr__tools_8h.html#aaa04a14c2cbf783b4926c2fd14445f82">dr_get_tls_field</a></div><div class="ttdeci">DR_API void * dr_get_tls_field(void *drcontext)</div></div>
<div class="ttc" id="adr__ir__macros_8h_html_aa32fcd12a03eb97ef42ded7b68a85203"><div class="ttname"><a href="dr__ir__macros_8h.html#aa32fcd12a03eb97ef42ded7b68a85203">OPND_CREATE_INT32</a></div><div class="ttdeci">#define OPND_CREATE_INT32(val)</div><div class="ttdef"><b>Definition:</b> dr_ir_macros.h:122</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_ac897243e24d71890e196586b8373b821"><div class="ttname"><a href="dr__ir__instr_8h.html#ac897243e24d71890e196586b8373b821">instr_get_next</a></div><div class="ttdeci">DR_API INSTR_INLINE instr_t * instr_get_next(instr_t *instr)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_abd9f556b8175c4ac72d8e7df8295f121"><div class="ttname"><a href="dr__ir__utils_8h.html#abd9f556b8175c4ac72d8e7df8295f121">dr_save_arith_flags</a></div><div class="ttdeci">DR_API void dr_save_arith_flags(void *drcontext, instrlist_t *ilist, instr_t *where, dr_spill_slot_t slot)</div></div>
<div class="ttc" id="adr__events_8h_html_a689518ac5d1ad136b13e03012702b209"><div class="ttname"><a href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a></div><div class="ttdeci">dr_emit_flags_t</div><div class="ttdef"><b>Definition:</b> dr_events.h:82</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_a99682422e3f2060e3b85a61ef7e4fbbb"><div class="ttname"><a href="dr__ir__instr_8h.html#a99682422e3f2060e3b85a61ef7e4fbbb">instr_get_opcode</a></div><div class="ttdeci">DR_API int instr_get_opcode(instr_t *instr)</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_af7e998e183e87480e7fd82240ff6633d"><div class="ttname"><a href="dr__ir__instr_8h.html#af7e998e183e87480e7fd82240ff6633d">instr_init</a></div><div class="ttdeci">DR_API void instr_init(void *drcontext, instr_t *instr)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_a4c8c687663c2f51e60e564ca9626acea"><div class="ttname"><a href="dr__ir__utils_8h.html#a4c8c687663c2f51e60e564ca9626acea">instrlist_meta_preinsert</a></div><div class="ttdeci">DR_API void instrlist_meta_preinsert(instrlist_t *ilist, instr_t *where, instr_t *instr)</div></div>
<div class="ttc" id="adr__ir__opnd_8h_html_ae6cf2a1e25144a7c81b3b3a4a89f8dda"><div class="ttname"><a href="dr__ir__opnd_8h.html#ae6cf2a1e25144a7c81b3b3a4a89f8dda">opnd_create_reg</a></div><div class="ttdeci">DR_API INSTR_INLINE opnd_t opnd_create_reg(reg_id_t r)</div></div>
<div class="ttc" id="adr__defines_8h_html_a3fb73c55def575ec5705577625491d66"><div class="ttname"><a href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a></div><div class="ttdeci">struct _instrlist_t instrlist_t</div><div class="ttdef"><b>Definition:</b> dr_defines.h:788</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_ad513dfc5199e89c7d22a271afa692b65"><div class="ttname"><a href="dr__ir__utils_8h.html#ad513dfc5199e89c7d22a271afa692b65">instrlist_meta_postinsert</a></div><div class="ttdeci">DR_API void instrlist_meta_postinsert(instrlist_t *ilist, instr_t *where, instr_t *instr)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_aa27020a55e63afdf3e053dbe4a34ab97"><div class="ttname"><a href="dr__ir__utils_8h.html#aa27020a55e63afdf3e053dbe4a34ab97">dr_insert_call_instrumentation</a></div><div class="ttdeci">DR_API void dr_insert_call_instrumentation(void *drcontext, instrlist_t *ilist, instr_t *instr, void *callee)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_aab7b4392c68e53f807bba5791183f240"><div class="ttname"><a href="dr__ir__utils_8h.html#aab7b4392c68e53f807bba5791183f240">dr_insert_read_tls_field</a></div><div class="ttdeci">DR_API void dr_insert_read_tls_field(void *drcontext, instrlist_t *ilist, instr_t *where, reg_id_t reg)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_ac50b49843cf02a5b5f91fc6b5264cc7c"><div class="ttname"><a href="dr__ir__utils_8h.html#ac50b49843cf02a5b5f91fc6b5264cc7c">dr_insert_mbr_instrumentation</a></div><div class="ttdeci">DR_API void dr_insert_mbr_instrumentation(void *drcontext, instrlist_t *ilist, instr_t *instr, void *callee, dr_spill_slot_t scratch_slot)</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_a75a82f341d4ea6a5b5f29f2ef1263355"><div class="ttname"><a href="dr__ir__instr_8h.html#a75a82f341d4ea6a5b5f29f2ef1263355">instr_from_noalloc</a></div><div class="ttdeci">DR_API INSTR_INLINE instr_t * instr_from_noalloc(instr_noalloc_t *noalloc)</div></div>
<div class="ttc" id="adr__tools_8h_html_a3c602c9d795079655bc599550cb4492b"><div class="ttname"><a href="dr__tools_8h.html#a3c602c9d795079655bc599550cb4492b">dr_replace_fragment</a></div><div class="ttdeci">DR_API bool dr_replace_fragment(void *drcontext, void *tag, instrlist_t *ilist)</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_acc1a1b2c972ea65f7d51c026180d4fd5"><div class="ttname"><a href="dr__ir__instr_8h.html#acc1a1b2c972ea65f7d51c026180d4fd5">instr_set_opcode</a></div><div class="ttdeci">DR_API void instr_set_opcode(instr_t *instr, int opcode)</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_a61b348667a4fc288e84e3f053033c075"><div class="ttname"><a href="dr__ir__instr_8h.html#a61b348667a4fc288e84e3f053033c075">instr_writes_memory</a></div><div class="ttdeci">DR_API bool instr_writes_memory(instr_t *instr)</div></div>
<div class="ttc" id="adr__tools_8h_html_aa9d4ad288807e3c033ab54013d8a49a4"><div class="ttname"><a href="dr__tools_8h.html#aa9d4ad288807e3c033ab54013d8a49a4">dr_flush_region_ex</a></div><div class="ttdeci">DR_API bool dr_flush_region_ex(app_pc start, size_t size, void(*flush_completion_callback)(void *user_data), void *user_data)</div></div>
<div class="ttc" id="adr__ir__encode_8h_html_a04d414952f335eaee8221c2a0e65ea46"><div class="ttname"><a href="dr__ir__encode_8h.html#a04d414952f335eaee8221c2a0e65ea46">instrlist_encode</a></div><div class="ttdeci">DR_API byte * instrlist_encode(void *drcontext, instrlist_t *ilist, byte *pc, bool has_instr_jmp_targets)</div></div>
<div class="ttc" id="adr__ir__macros__x86_8h_html_a9d0f07bc39f6e37f5f4a9836f342e077"><div class="ttname"><a href="dr__ir__macros__x86_8h.html#a9d0f07bc39f6e37f5f4a9836f342e077">INSTR_CREATE_mov_st</a></div><div class="ttdeci">#define INSTR_CREATE_mov_st(dc, d, s)</div><div class="ttdef"><b>Definition:</b> dr_ir_macros_x86.h:1206</div></div>
<div class="ttc" id="adr__ir__encode_8h_html_a3d194e7ce235e330a28686db29ee5480"><div class="ttname"><a href="dr__ir__encode_8h.html#a3d194e7ce235e330a28686db29ee5480">instr_encode</a></div><div class="ttdeci">DR_API byte * instr_encode(void *drcontext, instr_t *instr, byte *pc)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_a1df44dbe3d8dbf82e63e96741f167c64"><div class="ttname"><a href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call</a></div><div class="ttdeci">DR_API void dr_insert_clean_call(void *drcontext, instrlist_t *ilist, instr_t *where, void *callee, bool save_fpstate, uint num_args,...)</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_ab996c61a99fcf17880700e5adbbc6db1"><div class="ttname"><a href="dr__ir__instr_8h.html#ab996c61a99fcf17880700e5adbbc6db1">instr_free</a></div><div class="ttdeci">DR_API void instr_free(void *drcontext, instr_t *instr)</div></div>
<div class="ttc" id="adr__events_8h_html_a689518ac5d1ad136b13e03012702b209a7d25c4546544d1a8c0b77c69230772eb"><div class="ttname"><a href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a7d25c4546544d1a8c0b77c69230772eb">DR_EMIT_DEFAULT</a></div><div class="ttdeci">@ DR_EMIT_DEFAULT</div><div class="ttdef"><b>Definition:</b> dr_events.h:84</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_a376024b7b2d33e3a86ec3544b80f645c"><div class="ttname"><a href="dr__ir__utils_8h.html#a376024b7b2d33e3a86ec3544b80f645c">instrlist_meta_append</a></div><div class="ttdeci">DR_API void instrlist_meta_append(instrlist_t *ilist, instr_t *instr)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_a6fdc15ea04e8d17fa537832acf274d9c"><div class="ttname"><a href="dr__ir__utils_8h.html#a6fdc15ea04e8d17fa537832acf274d9c">dr_read_saved_reg</a></div><div class="ttdeci">DR_API reg_t dr_read_saved_reg(void *drcontext, dr_spill_slot_t slot)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_a97e9767e1ff0f426b552a5f18c528ced"><div class="ttname"><a href="dr__ir__utils_8h.html#a97e9767e1ff0f426b552a5f18c528ced">dr_restore_reg</a></div><div class="ttdeci">DR_API void dr_restore_reg(void *drcontext, instrlist_t *ilist, instr_t *where, reg_id_t reg, dr_spill_slot_t slot)</div></div>
<div class="ttc" id="astructinstr__t_html"><div class="ttname"><a href="structinstr__t.html">instr_t</a></div><div class="ttdef"><b>Definition:</b> dr_defines.h:371</div></div>
<div class="ttc" id="adr__ir__instrlist_8h_html_a623d9a44310e4d3373f266633ee07322"><div class="ttname"><a href="dr__ir__instrlist_8h.html#a623d9a44310e4d3373f266633ee07322">instrlist_first_app</a></div><div class="ttdeci">DR_API instr_t * instrlist_first_app(instrlist_t *ilist)</div></div>
<div class="ttc" id="astructinstr__noalloc__t_html"><div class="ttname"><a href="structinstr__noalloc__t.html">instr_noalloc_t</a></div><div class="ttdef"><b>Definition:</b> dr_ir_instr.h:324</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_a9f22e2640d0b987341ee87b8b6c9fa16"><div class="ttname"><a href="dr__ir__instr_8h.html#a9f22e2640d0b987341ee87b8b6c9fa16">instr_is_mbr</a></div><div class="ttdeci">DR_API bool instr_is_mbr(instr_t *instr)</div></div>
<div class="ttc" id="adr__ir__instr_8h_html_a9d9a1662aed6669a42a8284dae0e8019"><div class="ttname"><a href="dr__ir__instr_8h.html#a9d9a1662aed6669a42a8284dae0e8019">instr_create</a></div><div class="ttdeci">DR_API instr_t * instr_create(void *drcontext)</div></div>
<div class="ttc" id="adr__tools_8h_html_a534b38808801da50be64b9f0e6c8616f"><div class="ttname"><a href="dr__tools_8h.html#a534b38808801da50be64b9f0e6c8616f">dr_set_tls_field</a></div><div class="ttdeci">DR_API void dr_set_tls_field(void *drcontext, void *value)</div></div>
<div class="ttc" id="adr__ir__macros_8h_html_a74d7ad05e5371236dfd5b91b0767b690"><div class="ttname"><a href="dr__ir__macros_8h.html#a74d7ad05e5371236dfd5b91b0767b690">OPND_CREATE_INTPTR</a></div><div class="ttdeci">#define OPND_CREATE_INTPTR</div><div class="ttdef"><b>Definition:</b> dr_ir_macros.h:108</div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:04:14 &nbsp; <img border=0 src="favicon.png">
</small></address>
