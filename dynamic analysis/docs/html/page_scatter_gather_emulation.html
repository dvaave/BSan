<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>DynamoRIO: Emulating x86 Scatter and Gather Instructions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('page_scatter_gather_emulation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Emulating x86 Scatter and Gather Instructions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md256">Background</a></li>
<li class="level1"><a href="#autotoc_md257">Problem Statement</a></li>
<li class="level1"><a href="#autotoc_md258">Design</a><ul><li class="level2"><a href="#autotoc_md259">Scatter/gather Instruction Expansion</a></li>
<li class="level2"><a href="#autotoc_md260">Drreg Support For Multi-phase Reservations</a><ul><li class="level3"><a href="#autotoc_md261">State Restoration For Drreg</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md262">Simplifying Instrumentation For Emulated Instructions</a></li>
<li class="level2"><a href="#autotoc_md263">Support For Vector Reservation</a></li>
<li class="level2"><a href="#autotoc_md264">Using The Expansion In DR Clients</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md265">Testing On Large Apps</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md256"></a>
Background</h1>
<p>The x86 gather and scatter instructions were introduced in the AVX2 and AVX512 instruction set extensions. They allow loading or storing a subset of elements in a vector from/to multiple non-contiguous addresses.</p>
<p>AVX2 has only gather instructions, no scatter instructions, whereas AVX512 has both. AVX2 is limited to 256-bit length vectors, whereas AVX512 has 512-bit support. Both support masking of individual memory accesses, using either a special mask register in AVX512 or another vector in AVX2.</p>
<p>Examples of these instructions are (in DRâ€™s IR): </p><div class="fragment"><div class="line">vpgatherdd %rax(,%ymm11,4)[4byte] %ymm13 -&gt; %ymm12 %ymm13</div>
</div><!-- fragment --><p>Above is an AVX2 gather instruction that reads 32-bit doublewords into the 256-bit <code>ymm12</code> vector from addresses generated by adding the base address in <code>rax</code> to the corresponding index elements in <code>ymm11</code>, conditionally based on the masks in <code>ymm13</code>. Elements may be gathered in any order. When an element is read, its mask is cleared. If some load faults, all elements to its right (closer to LSB) will be complete.</p>
<div class="fragment"><div class="line">vpscatterdd {%k1} %xmm10 -&gt; %rax(,%xmm11,4)[4byte] %k1</div>
</div><!-- fragment --><p>Above is an AVX512 scatter instruction that writes 32-bit doublewords from the 128- bit <code>xmm10</code> vector to addresses generated by adding the base address in <code>rax</code> to the corresponding index element in <code>xmm11</code>, conditionally based on the mask register <code>k1</code>. Elements may be scattered in any order. When an element is stored, its mask is cleared. If some store faults, all elements to its right (closer to LSB) will be complete.</p>
<h1><a class="anchor" id="autotoc_md257"></a>
Problem Statement</h1>
<p>Scatter and gather instructions pose a challenge to DynamoRIO clients that observe memory addresses, like address tracing tools (e.g. drcachesim, that collects memory address and control flow traces), and taint tracking tools. They are complex to handle because:</p>
<ul>
<li>A single gather or scatter instruction loads from or stores to multiple addresses</li>
<li>Accessed addresses may be non-contiguous</li>
<li>Each access is conditional based on some mask</li>
</ul>
<p>DynamoRIO clients only see the scatter or gather instruction and need to do more work to extract all accessed addresses. This is unlike regular scalar loads or stores, where the accessed address is readily available. The goal of this work is to make it easier for DR clients to observe these addresses. We achieve this by expanding the scatter and gather instructions into a functionally equivalent sequence of scalar stores and loads. This way, DR clients will see regular store and load instructions which they can instrument as usual. This is similar to what DR does for repeat string operations (like <code>rep movs</code>, <code>repnz cmps</code>): convert it into a loop so that each memory access is made by a separate dynamic instruction. This method has worked well for such instructions that implicitly issue multiple memory accesses.</p>
<p>Original issue: <a href="https://github.com/DynamoRIO/dynamorio/issues/2985">DynamoRIO/dynamorio#2985</a>.</p>
<h1><a class="anchor" id="autotoc_md258"></a>
Design</h1>
<p>This required the addition of new support in various DynamoRIO components, like drreg, drx, drmgr and core DR. Multiple contributors worked on designing and implementing the required changes.</p>
<p>Note that we expect the same approach to work for other platforms too, like for the AArch64 SVE scatter/gather instructions.</p>
<h2><a class="anchor" id="autotoc_md259"></a>
Scatter/gather Instruction Expansion</h2>
<p>Owner: <a href="https://github.com/hgreving2304">Hendrik Greving</a></p>
<p>As described above, we can simplify work for DR clients by replacing each scatter and gather instruction with a functionally equivalent sequence of scalar stores and loads. The expanded sequence is the unrolled version of the following loop: </p><div class="fragment"><div class="line">num_accesses = vector_size / element_size</div>
<div class="line"><span class="keywordflow">for</span> i = 0, 1, ..., (num_accesses-1), <span class="keywordflow">do</span></div>
<div class="line">  extract mask <span class="keywordflow">for</span> the ith access from mask reg or mask vector</div>
<div class="line">  <span class="keywordflow">if</span> mask is set, then</div>
<div class="line">    extract ith element of index vector</div>
<div class="line">    compute address = base + ith index element</div>
<div class="line">    <span class="keywordflow">if</span> <a class="code" href="dr__ir__instr_8h.html#ab99dd3460f2fd5abc2d59a9ddb26a6b5">instr_is_gather</a>, then</div>
<div class="line">      load data from address into a scalar reg</div>
<div class="line">      insert scalar data into destination vector</div>
<div class="line">    <span class="keywordflow">else</span> <span class="comment">// instr_is_scatter</span></div>
<div class="line">      extract scalar data from source vector to scalar reg</div>
<div class="line">      store data from scalar reg to address</div>
<div class="line">    done</div>
<div class="line">    clear ith mask in mask reg or mask vector</div>
<div class="line">  done</div>
<div class="line">done</div>
</div><!-- fragment --><p>Due to the x86 ISA, the extraction/insertion of the scalar value from/to the vector may involve multiple steps, e.g. to extract a 32-bit scalar value from a 512-bit <code>zmm</code> reg, we first need to extract a 128-bit <code>xmm</code> from it.</p>
<p>drmgr in DR provides multiple phases of instrumentation. Our expansion is done in the first phase known as app2app. As the name suggests, this phase is intended to transform app instructions to equivalent instructions. For simplicity, we also separate out the scatter and gather instructions from their basic block and create a separate fragment with only the expanded sequence. The logic for expanding scatter and gather instructions is implemented in the drx extension library as <a href="https://github.com/DynamoRIO/dynamorio/blob/
eb5d5af8e3444912c9f3f70e5ebf7969252ee4d6/ext/drx/drx.h#L538"><code>drx_expand_scatter_gather</code></a>, and can be used by any client that needs it, including drcachesim. This support was added by <a href="https://github.com/DynamoRIO/dynamorio/commit/4359ef134e47942004c09db04b54593579763186">commit</a>.</p>
<p>As an example, the following are the expansions of some instructions.</p>
<p>Expansion for </p><div class="fragment"><div class="line">vpgatherdd 0x00402039(,%xmm11,4)[4<span class="keywordtype">byte</span>] %xmm13 -&gt; %xmm12 %xmm13</div>
</div><!-- fragment --><div class="fragment"><div class="line">+0    m4 @0x00007fdb2ac5e6a0  65 48 a3 e0 00 00 00 mov    %rax -&gt; %gs:0x000000e0[8byte]</div>
<div class="line">                              00 00 00 00</div>
<div class="line">+11   m4 @0x00007fdb2ac5eac0  9f                   lahf    -&gt; %ah</div>
<div class="line">+12   m4 @0x00007fdb2ac5ea40  0f 90 c0             seto    -&gt; %al                              <span class="comment">// Spill aflags using drreg.</span></div>
<div class="line">+15   m4 @0x00007fdb2ac5efa8  65 48 89 0c 25 e8 00 mov    %rcx -&gt; %gs:0x000000e8[8byte]        <span class="comment">// Spill the scratch GPR using drreg.</span></div>
<div class="line">                              00 00</div>
<div class="line">+24   m4 @0x00007fdb2ac0ec70  65 48 8b 0c 25 20 00 mov    %gs:0x20[8byte] -&gt; %rcx</div>
<div class="line">                              00 00</div>
<div class="line">+33   m4 @0x00007fdb2ac0ebf0  48 8b 89 f0 0a 00 00 mov    0x00000af0(%rcx)[8<span class="keywordtype">byte</span>] -&gt; %rcx</div>
<div class="line">+40   m4 @0x00007fdb2ac5f0a8  48 8b 09             mov    (%rcx)[8byte] -&gt; %rcx</div>
<div class="line">+43   m4 @0x00007fdb2ac5e7f0  48 8b 49 10          mov    0x10(%rcx)[8<span class="keywordtype">byte</span>] -&gt; %rcx</div>
<div class="line">+47   m4 @0x00007fdb2ac0f488  48 8b 49 08          mov    0x08(%rcx)[8byte] -&gt; %rcx</div>
<div class="line">+51   m4 @0x00007fdb2ac0ed38  62 f1 7c 48 29 01    vmovaps {%k0} %zmm0 -&gt; (%rcx)[64<span class="keywordtype">byte</span>]       <span class="comment">// Manually spill the scratch zmm reg.</span></div>
<div class="line">+57   m4 @0x00007fdb2ac0ee00                       &lt;label&gt;</div>
<div class="line">+57   L4 @0x00007fdb2ac0efb0  c4 63 7d 39 e8 00    vextracti128 %ymm13 $0x00 -&gt; %xmm0          <span class="comment">// Expansion for the first vector element starts here.</span></div>
<div class="line">+63   L4 @0x00007fdb2ac0bee8  c4 e3 79 16 c1 00    vpextrd %xmm0 $0x00 -&gt; %ecx                 <span class="comment">// Extract mask for the first element.</span></div>
<div class="line">+69   L4 @0x00007fdb2ac0c750  c1 e9 1f             shr    $0x0000001f %ecx -&gt; %ecx</div>
<div class="line">+72   L4 @0x00007fdb2ac0be68  81 e1 01 00 00 00    and    $0x00000001 %ecx -&gt; %ecx</div>
<div class="line">+78   L4 @0x00007fdb2ac0bca0  0f 84 fa ff ff ff    jz     @0x00007fdb2ac0ee98[8<span class="keywordtype">byte</span>]           <span class="comment">// Check whether to load the first element based on mask.</span></div>
<div class="line">+84   L4 @0x00007fdb2ac0c6d0  c4 63 7d 39 d8 00    vextracti128 %ymm11 $0x00 -&gt; %xmm0</div>
<div class="line">+90   L4 @0x00007fdb2ac0be00  c4 e3 79 16 c1 00    vpextrd %xmm0 $0x00 -&gt; %ecx                 <span class="comment">// Extract index for the first load address.</span></div>
<div class="line">+96   L4 @0x00007fdb2ac0b8b8  48 63 c9             movsxd %ecx -&gt; %rcx</div>
<div class="line">+99   L4 @0x00007fdb2ac0cc20  8b 0c 8d 39 20 40 00 mov    0x00402039(,%rcx,4)[4byte] -&gt; %ecx   <span class="comment">// Load the first element into a scalar reg.</span></div>
<div class="line">+106  L4 @0x00007fdb2ac5e5b8  c4 63 7d 39 e0 00    vextracti128 %ymm12 $0x00 -&gt; %xmm0</div>
<div class="line">+112  L4 @0x00007fdb2ac5e870  c4 e3 79 22 c1 00    vpinsrd %xmm0 %ecx $0x00 -&gt; %xmm0</div>
<div class="line">+118  L4 @0x00007fdb2ac5e9c0  c4 63 1d 38 e0 00    vinserti128 %ymm12 %xmm0 $0x00 -&gt; %ymm12    <span class="comment">// Insert the first element into the destination vector reg</span></div>
<div class="line">+124  L4 @0x00007fdb2ac5eb40  33 c9                xor    %ecx %ecx -&gt; %ecx</div>
<div class="line">+126  L4 @0x00007fdb2ac5ebc0  c4 63 7d 39 e8 00    vextracti128 %ymm13 $0x00 -&gt; %xmm0</div>
<div class="line">+132  L4 @0x00007fdb2ac5eda8  c4 e3 79 22 c1 00    vpinsrd %xmm0 %ecx $0x00 -&gt; %xmm0</div>
<div class="line">+138  L4 @0x00007fdb2ac5ec40  c4 63 15 38 e8 00    vinserti128 %ymm13 %xmm0 $0x00 -&gt; %ymm13    <span class="comment">// Clear the mask bit for the first element.</span></div>
<div class="line">+144  m4 @0x00007fdb2ac0ee98                       &lt;label&gt;</div>
<div class="line">+144  L4 @0x00007fdb2ac5ed40  c4 63 7d 39 e8 00    vextracti128 %ymm13 $0x00 -&gt; %xmm0          <span class="comment">// Repeat for the second vector element.</span></div>
<div class="line">+150  L4 @0x00007fdb2ac5ee28  c4 e3 79 16 c1 01    vpextrd %xmm0 $0x01 -&gt; %ecx</div>
<div class="line">+156  L4 @0x00007fdb2ac5eea8  c1 e9 1f             shr    $0x0000001f %ecx -&gt; %ecx</div>
<div class="line">+159  L4 @0x00007fdb2ac5e638  81 e1 01 00 00 00    and    $0x00000001 %ecx -&gt; %ecx</div>
<div class="line">+165  L4 @0x00007fdb2ac5e788  0f 84 fa ff ff ff    jz     @0x00007fdb2ac5ecc0[8byte]</div>
<div class="line">+171  L4 @0x00007fdb2ac5e720  c4 63 7d 39 d8 00    vextracti128 %ymm11 $0x00 -&gt; %xmm0</div>
<div class="line">+177  L4 @0x00007fdb2ac5e958  c4 e3 79 16 c1 01    vpextrd %xmm0 $0x01 -&gt; %ecx</div>
<div class="line">+183  L4 @0x00007fdb2ac5e8f0  48 63 c9             movsxd %ecx -&gt; %rcx</div>
<div class="line">+186  L4 @0x00007fdb2ac5f028  8b 0c 8d 39 20 40 00 mov    0x00402039(,%rcx,4)[4<span class="keywordtype">byte</span>] -&gt; %ecx</div>
<div class="line">+193  L4 @0x00007fdb2ac5ef28  c4 63 7d 39 e0 00    vextracti128 %ymm12 $0x00 -&gt; %xmm0</div>
<div class="line">+199  L4 @0x00007fdb2ac0baa0  c4 e3 79 22 c1 01    vpinsrd %xmm0 %ecx $0x01 -&gt; %xmm0</div>
<div class="line">+205  L4 @0x00007fdb2ac5f128  c4 63 1d 38 e0 00    vinserti128 %ymm12 %xmm0 $0x00 -&gt; %ymm12</div>
<div class="line">+211  L4 @0x00007fdb2ac0ea60  33 c9                xor    %ecx %ecx -&gt; %ecx</div>
<div class="line">+213  L4 @0x00007fdb2ac0e9c8  c4 63 7d 39 e8 00    vextracti128 %ymm13 $0x00 -&gt; %xmm0</div>
<div class="line">+219  L4 @0x00007fdb2ac0e930  c4 e3 79 22 c1 01    vpinsrd %xmm0 %ecx $0x01 -&gt; %xmm0</div>
<div class="line">+225  L4 @0x00007fdb2ac0cbb8  c4 63 15 38 e8 00    vinserti128 %ymm13 %xmm0 $0x00 -&gt; %ymm13</div>
<div class="line">+231  m4 @0x00007fdb2ac5ecc0                       &lt;label&gt;</div>
<div class="line">+231  L4 @0x00007fdb2ac5e538  c4 63 7d 39 e8 00    vextracti128 %ymm13 $0x00 -&gt; %xmm0          <span class="comment">// Repeat for the third vector element.</span></div>
<div class="line">+237  L4 @0x00007fdb2ac5e4b8  c4 e3 79 16 c1 02    vpextrd %xmm0 $0x02 -&gt; %ecx</div>
<div class="line">+243  L4 @0x00007fdb2ac5df68  c1 e9 1f             shr    $0x0000001f %ecx -&gt; %ecx</div>
<div class="line">+246  L4 @0x00007fdb2ac5e438  81 e1 01 00 00 00    and    $0x00000001 %ecx -&gt; %ecx</div>
<div class="line">+252  L4 @0x00007fdb2ac5e3b8  0f 84 fa ff ff ff    jz     @0x00007fdb2ac0f018[8<span class="keywordtype">byte</span>]</div>
<div class="line">+258  L4 @0x00007fdb2ac5e050  c4 63 7d 39 d8 00    vextracti128 %ymm11 $0x00 -&gt; %xmm0</div>
<div class="line">+264  L4 @0x00007fdb2ac5e338  c4 e3 79 16 c1 02    vpextrd %xmm0 $0x02 -&gt; %ecx</div>
<div class="line">+270  L4 @0x00007fdb2ac5e2b8  48 63 c9             movsxd %ecx -&gt; %rcx</div>
<div class="line">+273  L4 @0x00007fdb2ac5e238  8b 0c 8d 39 20 40 00 mov    0x00402039(,%rcx,4)[4byte] -&gt; %ecx</div>
<div class="line">+280  L4 @0x00007fdb2ac5e1b8  c4 63 7d 39 e0 00    vextracti128 %ymm12 $0x00 -&gt; %xmm0</div>
<div class="line">+286  L4 @0x00007fdb2ac5e138  c4 e3 79 22 c1 02    vpinsrd %xmm0 %ecx $0x02 -&gt; %xmm0</div>
<div class="line">+292  L4 @0x00007fdb2ac5e0b8  c4 63 1d 38 e0 00    vinserti128 %ymm12 %xmm0 $0x00 -&gt; %ymm12</div>
<div class="line">+298  L4 @0x00007fdb2ac5dfd0  33 c9                xor    %ecx %ecx -&gt; %ecx</div>
<div class="line">+300  L4 @0x00007fdb2ac5dee8  c4 63 7d 39 e8 00    vextracti128 %ymm13 $0x00 -&gt; %xmm0</div>
<div class="line">+306  L4 @0x00007fdb2ac0f080  c4 e3 79 22 c1 02    vpinsrd %xmm0 %ecx $0x02 -&gt; %xmm0</div>
<div class="line">+312  L4 @0x00007fdb2ac0f0e8  c4 63 15 38 e8 00    vinserti128 %ymm13 %xmm0 $0x00 -&gt; %ymm13</div>
<div class="line">+318  m4 @0x00007fdb2ac0f018                       &lt;label&gt;</div>
<div class="line">+318  L4 @0x00007fdb2ac0f220  c4 63 7d 39 e8 00    vextracti128 %ymm13 $0x00 -&gt; %xmm0          <span class="comment">// Repeat for the fourth vector element.</span></div>
<div class="line">+324  L4 @0x00007fdb2ac0f2a0  c4 e3 79 16 c1 03    vpextrd %xmm0 $0x03 -&gt; %ecx</div>
<div class="line">+330  L4 @0x00007fdb2ac0f150  c1 e9 1f             shr    $0x0000001f %ecx -&gt; %ecx</div>
<div class="line">+333  L4 @0x00007fdb2ac0f388  81 e1 01 00 00 00    and    $0x00000001 %ecx -&gt; %ecx</div>
<div class="line">+339  L4 @0x00007fdb2ac0f408  0f 84 fa ff ff ff    jz     @0x00007fdb2ac0f1b8[8byte]</div>
<div class="line">+345  L4 @0x00007fdb2ac0ba20  c4 63 7d 39 d8 00    vextracti128 %ymm11 $0x00 -&gt; %xmm0</div>
<div class="line">+351  L4 @0x00007fdb2ac0f320  c4 e3 79 16 c1 03    vpextrd %xmm0 $0x03 -&gt; %ecx</div>
<div class="line">+357  L4 @0x00007fdb2ac0f508  48 63 c9             movsxd %ecx -&gt; %rcx</div>
<div class="line">+360  L4 @0x00007fdb2ac0f588  8b 0c 8d 39 20 40 00 mov    0x00402039(,%rcx,4)[4<span class="keywordtype">byte</span>] -&gt; %ecx</div>
<div class="line">+367  L4 @0x00007fdb2ac0ef30  c4 63 7d 39 e0 00    vextracti128 %ymm12 $0x00 -&gt; %xmm0</div>
<div class="line">+373  L4 @0x00007fdb2ac0c050  c4 e3 79 22 c1 03    vpinsrd %xmm0 %ecx $0x03 -&gt; %xmm0</div>
<div class="line">+379  L4 @0x00007fdb2ac0c1c8  c4 63 1d 38 e0 00    vinserti128 %ymm12 %xmm0 $0x00 -&gt; %ymm12</div>
<div class="line">+385  L4 @0x00007fdb2ac0c3c8  33 c9                xor    %ecx %ecx -&gt; %ecx</div>
<div class="line">+387  L4 @0x00007fdb2ac0bfd0  c4 63 7d 39 e8 00    vextracti128 %ymm13 $0x00 -&gt; %xmm0</div>
<div class="line">+393  L4 @0x00007fdb2ac5de68  c4 e3 79 22 c1 03    vpinsrd %xmm0 %ecx $0x03 -&gt; %xmm0</div>
<div class="line">+399  L4 @0x00007fdb2ac5dde8  c4 63 15 38 e8 00    vinserti128 %ymm13 %xmm0 $0x00 -&gt; %ymm13</div>
<div class="line">+405  m4 @0x00007fdb2ac0f1b8                       &lt;label&gt;</div>
<div class="line">+405  L4 @0x00007fdb2ac5d898  c4 41 11 ef ed       vpxor  %xmm13 %xmm13 -&gt; %xmm13              <span class="comment">// Zero the mask reg.</span></div>
<div class="line">+410  m4 @0x00007fdb2ac5dd68  65 48 8b 0c 25 20 00 mov    %gs:0x20[8<span class="keywordtype">byte</span>] -&gt; %rcx</div>
<div class="line">                              00 00</div>
<div class="line">+419  m4 @0x00007fdb2ac5dce8  48 8b 89 f0 0a 00 00 mov    0x00000af0(%rcx)[8byte] -&gt; %rcx</div>
<div class="line">+426  m4 @0x00007fdb2ac5d980  48 8b 09             mov    (%rcx)[8byte] -&gt; %rcx</div>
<div class="line">+429  m4 @0x00007fdb2ac5dc68  48 8b 49 10          mov    0x10(%rcx)[8<span class="keywordtype">byte</span>] -&gt; %rcx</div>
<div class="line">+433  m4 @0x00007fdb2ac5dbe8  48 8b 49 08          mov    0x08(%rcx)[8byte] -&gt; %rcx</div>
<div class="line">+437  m4 @0x00007fdb2ac5db68  62 f1 7c 48 28 01    vmovaps {%k0} (%rcx)[64<span class="keywordtype">byte</span>] -&gt; %zmm0       <span class="comment">// Manually restore the scratch zmm reg.</span></div>
<div class="line">+443  m4 @0x00007fdb2ac5dae8  65 48 8b 0c 25 e8 00 mov    %gs:0x000000e8[8<span class="keywordtype">byte</span>] -&gt; %rcx        <span class="comment">// Restore the scratch GPR using drreg.</span></div>
<div class="line">                              00 00</div>
<div class="line">+452  m4 @0x00007fdb2ac5da68  3c 81                cmp    %al $0x81</div>
<div class="line">+454  m4 @0x00007fdb2ac5d9e8  9e                   sahf   %ah</div>
<div class="line">+455  m4 @0x00007fdb2ac5d900  65 48 a1 e0 00 00 00 mov    %gs:0x000000e0[8<span class="keywordtype">byte</span>] -&gt; %rax        <span class="comment">// Restore aflags using drreg.</span></div>
<div class="line">                              00 00 00 00</div>
<div class="line">+466  m4 @0x00007fdb2ac5d818                       &lt;label&gt;</div>
</div><!-- fragment --><p>Expansion for </p><div class="fragment"><div class="line">vpscatterdd {%k1} %xmm10 -&gt; 0x00402039(,%xmm11,4)[4<span class="keywordtype">byte</span>] %k1</div>
</div><!-- fragment --><div class="fragment"><div class="line">+0    m4 @0x00007fdb2ac106e0  65 48 a3 e0 00 00 00 mov    %rax -&gt; %gs:0x000000e0[8byte]</div>
<div class="line">                              00 00 00 00</div>
<div class="line">+11   m4 @0x00007fdb2ac10760  9f                   lahf    -&gt; %ah</div>
<div class="line">+12   m4 @0x00007fdb2ac107e0  0f 90 c0             seto    -&gt; %al                              <span class="comment">// Spill aflags using drreg.</span></div>
<div class="line">+15   m4 @0x00007fdb2ac100a8  65 48 89 0c 25 e8 00 mov    %rcx -&gt; %gs:0x000000e8[8byte]        <span class="comment">// Spill the first scratch GPR using drreg.</span></div>
<div class="line">                              00 00</div>
<div class="line">+24   m4 @0x00007fdb2ac10110  65 48 89 14 25 f0 00 mov    %rdx -&gt; %gs:0x000000f0[8byte]        <span class="comment">// Spill the second scratch GPR using drreg.</span></div>
<div class="line">                              00 00</div>
<div class="line">+33   m4 @0x00007fdb2ac0fed8  65 48 8b 0c 25 20 00 mov    %gs:0x20[8byte] -&gt; %rcx</div>
<div class="line">                              00 00</div>
<div class="line">+42   m4 @0x00007fdb2ac0ff40  48 8b 89 f0 0a 00 00 mov    0x00000af0(%rcx)[8<span class="keywordtype">byte</span>] -&gt; %rcx</div>
<div class="line">+49   m4 @0x00007fdb2ac0f608  48 8b 09             mov    (%rcx)[8byte] -&gt; %rcx</div>
<div class="line">+52   m4 @0x00007fdb2ac10860  48 8b 49 10          mov    0x10(%rcx)[8<span class="keywordtype">byte</span>] -&gt; %rcx</div>
<div class="line">+56   m4 @0x00007fdb2ac108e0  48 8b 49 08          mov    0x08(%rcx)[8byte] -&gt; %rcx</div>
<div class="line">+60   m4 @0x00007fdb2ac0ca50  62 f1 7c 48 29 01    vmovaps {%k0} %zmm0 -&gt; (%rcx)[64<span class="keywordtype">byte</span>]       <span class="comment">// Manually spill the scratch zmm reg.</span></div>
<div class="line">+66   m4 @0x00007fdb2ac10660                       &lt;label&gt;</div>
<div class="line">+66   L4 @0x00007fdb2ac10560  c5 f8 93 c9          kmovw  %k1 -&gt; %ecx                          <span class="comment">// Expansion for the first vector element starts here.</span></div>
<div class="line">+70   L4 @0x00007fdb2ac104f8  f7 c1 01 00 00 00    test   %ecx $0x00000001</div>
<div class="line">+76   L4 @0x00007fdb2ac10478  0f 84 fa ff ff ff    jz     @0x00007fdb2ac105e0[8<span class="keywordtype">byte</span>]           <span class="comment">// Check whether to store the first element based on mask.</span></div>
<div class="line">+82   L4 @0x00007fdb2ac103f8  62 73 7d 48 39 d8 00 vextracti32x4 {%k0} $0x00 %zmm11 -&gt; %xmm0</div>
<div class="line">+89   L4 @0x00007fdb2ac10378  c4 e3 79 16 c1 00    vpextrd %xmm0 $0x00 -&gt; %ecx                 <span class="comment">// Extract index for the first store address.</span></div>
<div class="line">+95   L4 @0x00007fdb2ac102f8  62 73 7d 48 39 d0 00 vextracti32x4 {%k0} $0x00 %zmm10 -&gt; %xmm0</div>
<div class="line">+102  L4 @0x00007fdb2ac10278  c4 e3 79 16 c2 00    vpextrd %xmm0 $0x00 -&gt; %edx                 <span class="comment">// Extract the element for the first store.</span></div>
<div class="line">+108  L4 @0x00007fdb2ac101f8  48 63 c9             movsxd %ecx -&gt; %rcx</div>
<div class="line">+111  L4 @0x00007fdb2ac10178  89 14 8d 39 20 40 00 mov    %edx -&gt; 0x00402039(,%rcx,4)[4<span class="keywordtype">byte</span>]   <span class="comment">// Store the first element.</span></div>
<div class="line">+118  L4 @0x00007fdb2ac10028  b9 01 00 00 00       mov    $0x00000001 -&gt; %ecx</div>
<div class="line">+123  m4 @0x00007fdb2ac0ffa8  65 48 89 1c 25 f8 00 mov    %rbx -&gt; %gs:0x000000f8[8<span class="keywordtype">byte</span>]        <span class="comment">// Spill the third scratch GPR using drreg.</span></div>
<div class="line">                              00 00</div>
<div class="line">+132  m4 @0x00007fdb2ac0fe58  c5 f8 93 d8          kmovw  %k0 -&gt; %ebx                          <span class="comment">// Manually spill the scratch mask reg k0 to the scratch GPR.</span></div>
<div class="line">+136  L4 @0x00007fdb2ac0fdd8  c5 f8 92 c1          kmovw  %ecx -&gt; %k0</div>
<div class="line">+140  L4 @0x00007fdb2ac0fbf0  c5 fc 42 c9          kandnw %k0 %k1 -&gt; %k1                       <span class="comment">// Clear bit for the first element in the mask reg.</span></div>
<div class="line">+144  m4 @0x00007fdb2ac0fd58  c5 f8 92 c3          kmovw  %ebx -&gt; %k0                          <span class="comment">// Manually restore the scratch mask reg from the scratch GPR.</span></div>
<div class="line">+148  m4 @0x00007fdb2ac0fcd8  65 48 8b 1c 25 f8 00 mov    %gs:0x000000f8[8<span class="keywordtype">byte</span>] -&gt; %rbx        <span class="comment">// Restore the third scratch GPR using drreg.</span></div>
<div class="line">                              00 00</div>
<div class="line">+157  m4 @0x00007fdb2ac105e0                       &lt;label&gt;</div>
<div class="line">+157  L4 @0x00007fdb2ac0fb70  c5 f8 93 c9          kmovw  %k1 -&gt; %ecx                          <span class="comment">// Repeat for the second vector element.</span></div>
<div class="line">+161  L4 @0x00007fdb2ac0faf0  f7 c1 02 00 00 00    test   %ecx $0x00000002</div>
<div class="line">+167  L4 @0x00007fdb2ac0fa70  0f 84 fa ff ff ff    jz     @0x00007fdb2ac0fc58[8<span class="keywordtype">byte</span>]</div>
<div class="line">+173  L4 @0x00007fdb2ac0f9f0  62 73 7d 48 39 d8 00 vextracti32x4 {%k0} $0x00 %zmm11 -&gt; %xmm0</div>
<div class="line">+180  L4 @0x00007fdb2ac0f970  c4 e3 79 16 c1 01    vpextrd %xmm0 $0x01 -&gt; %ecx</div>
<div class="line">+186  L4 @0x00007fdb2ac0f8f0  62 73 7d 48 39 d0 00 vextracti32x4 {%k0} $0x00 %zmm10 -&gt; %xmm0</div>
<div class="line">+193  L4 @0x00007fdb2ac0f870  c4 e3 79 16 c2 01    vpextrd %xmm0 $0x01 -&gt; %edx</div>
<div class="line">+199  L4 @0x00007fdb2ac0f7f0  48 63 c9             movsxd %ecx -&gt; %rcx</div>
<div class="line">+202  L4 @0x00007fdb2ac0f770  89 14 8d 39 20 40 00 mov    %edx -&gt; 0x00402039(,%rcx,4)[4<span class="keywordtype">byte</span>]</div>
<div class="line">+209  L4 @0x00007fdb2ac0f6f0  b9 02 00 00 00       mov    $0x00000002 -&gt; %ecx</div>
<div class="line">+214  m4 @0x00007fdb2ac0f670  65 48 89 1c 25 f8 00 mov    %rbx -&gt; %gs:0x000000f8[8<span class="keywordtype">byte</span>]</div>
<div class="line">                              00 00</div>
<div class="line">+223  m4 @0x00007fdb2ac0c448  c5 f8 93 d8          kmovw  %k0 -&gt; %ebx</div>
<div class="line">+227  L4 @0x00007fdb2ac0c2c8  c5 f8 92 c1          kmovw  %ecx -&gt; %k0</div>
<div class="line">+231  L4 @0x00007fdb2ac0c9e8  c5 fc 42 c9          kandnw %k0 %k1 -&gt; %k1</div>
<div class="line">+235  m4 @0x00007fdb2ac0c980  c5 f8 92 c3          kmovw  %ebx -&gt; %k0</div>
<div class="line">+239  m4 @0x00007fdb2ac0c818  65 48 8b 1c 25 f8 00 mov    %gs:0x000000f8[8<span class="keywordtype">byte</span>] -&gt; %rbx</div>
<div class="line">                              00 00</div>
<div class="line">+248  m4 @0x00007fdb2ac0fc58                       &lt;label&gt;</div>
<div class="line">+248  L4 @0x00007fdb2ac0c518  c5 f8 93 c9          kmovw  %k1 -&gt; %ecx                          <span class="comment">// Repeat for the third vector element.</span></div>
<div class="line">+252  L4 @0x00007fdb2ac0c668  f7 c1 04 00 00 00    test   %ecx $0x00000004</div>
<div class="line">+258  L4 @0x00007fdb2ac0cab8  0f 84 fa ff ff ff    jz     @0x00007fdb2ac0ba20[8<span class="keywordtype">byte</span>]</div>
<div class="line">+264  L4 @0x00007fdb2ac0cb20  62 73 7d 48 39 d8 00 vextracti32x4 {%k0} $0x00 %zmm11 -&gt; %xmm0</div>
<div class="line">+271  L4 @0x00007fdb2ac0c248  c4 e3 79 16 c1 02    vpextrd %xmm0 $0x02 -&gt; %ecx</div>
<div class="line">+277  L4 @0x00007fdb2ac0bd98  62 73 7d 48 39 d0 00 vextracti32x4 {%k0} $0x00 %zmm10 -&gt; %xmm0</div>
<div class="line">+284  L4 @0x00007fdb2ac0c0d0  c4 e3 79 16 c2 02    vpextrd %xmm0 $0x02 -&gt; %edx</div>
<div class="line">+290  L4 @0x00007fdb2ac0c900  48 63 c9             movsxd %ecx -&gt; %rcx</div>
<div class="line">+293  L4 @0x00007fdb2ac0bfd0  89 14 8d 39 20 40 00 mov    %edx -&gt; 0x00402039(,%rcx,4)[4<span class="keywordtype">byte</span>]</div>
<div class="line">+300  L4 @0x00007fdb2ac0c3c8  b9 04 00 00 00       mov    $0x00000004 -&gt; %ecx</div>
<div class="line">+305  m4 @0x00007fdb2ac0c1c8  65 48 89 1c 25 f8 00 mov    %rbx -&gt; %gs:0x000000f8[8<span class="keywordtype">byte</span>]</div>
<div class="line">                              00 00</div>
<div class="line">+314  m4 @0x00007fdb2ac0c050  c5 f8 93 d8          kmovw  %k0 -&gt; %ebx</div>
<div class="line">+318  L4 @0x00007fdb2ac0ef30  c5 f8 92 c1          kmovw  %ecx -&gt; %k0</div>
<div class="line">+322  L4 @0x00007fdb2ac0f588  c5 fc 42 c9          kandnw %k0 %k1 -&gt; %k1</div>
<div class="line">+326  m4 @0x00007fdb2ac0f508  c5 f8 92 c3          kmovw  %ebx -&gt; %k0</div>
<div class="line">+330  m4 @0x00007fdb2ac0f320  65 48 8b 1c 25 f8 00 mov    %gs:0x000000f8[8<span class="keywordtype">byte</span>] -&gt; %rbx</div>
<div class="line">                              00 00</div>
<div class="line">+339  m4 @0x00007fdb2ac0ba20                       &lt;label&gt;</div>
<div class="line">+339  L4 @0x00007fdb2ac0f408  c5 f8 93 c9          kmovw  %k1 -&gt; %ecx                          <span class="comment">// Repeat for the fourth vector element.</span></div>
<div class="line">+343  L4 @0x00007fdb2ac0f388  f7 c1 08 00 00 00    test   %ecx $0x00000008</div>
<div class="line">+349  L4 @0x00007fdb2ac0f150  0f 84 fa ff ff ff    jz     @0x00007fdb2ac0f488[8<span class="keywordtype">byte</span>]</div>
<div class="line">+355  L4 @0x00007fdb2ac0f2a0  62 73 7d 48 39 d8 00 vextracti32x4 {%k0} $0x00 %zmm11 -&gt; %xmm0</div>
<div class="line">+362  L4 @0x00007fdb2ac0f220  c4 e3 79 16 c1 03    vpextrd %xmm0 $0x03 -&gt; %ecx</div>
<div class="line">+368  L4 @0x00007fdb2ac0f1b8  62 73 7d 48 39 d0 00 vextracti32x4 {%k0} $0x00 %zmm10 -&gt; %xmm0</div>
<div class="line">+375  L4 @0x00007fdb2ac0f0e8  c4 e3 79 16 c2 03    vpextrd %xmm0 $0x03 -&gt; %edx</div>
<div class="line">+381  L4 @0x00007fdb2ac0f080  48 63 c9             movsxd %ecx -&gt; %rcx</div>
<div class="line">+384  L4 @0x00007fdb2ac0f018  89 14 8d 39 20 40 00 mov    %edx -&gt; 0x00402039(,%rcx,4)[4<span class="keywordtype">byte</span>]</div>
<div class="line">+391  L4 @0x00007fdb2ac0cbb8  b9 08 00 00 00       mov    $0x00000008 -&gt; %ecx</div>
<div class="line">+396  m4 @0x00007fdb2ac0e930  65 48 89 1c 25 f8 00 mov    %rbx -&gt; %gs:0x000000f8[8<span class="keywordtype">byte</span>]</div>
<div class="line">                              00 00</div>
<div class="line">+405  m4 @0x00007fdb2ac0e9c8  c5 f8 93 d8          kmovw  %k0 -&gt; %ebx</div>
<div class="line">+409  L4 @0x00007fdb2ac0ea60  c5 f8 92 c1          kmovw  %ecx -&gt; %k0</div>
<div class="line">+413  L4 @0x00007fdb2ac0eb28  c5 fc 42 c9          kandnw %k0 %k1 -&gt; %k1</div>
<div class="line">+417  m4 @0x00007fdb2ac0ebf0  c5 f8 92 c3          kmovw  %ebx -&gt; %k0</div>
<div class="line">+421  m4 @0x00007fdb2ac0ec70  65 48 8b 1c 25 f8 00 mov    %gs:0x000000f8[8<span class="keywordtype">byte</span>] -&gt; %rbx</div>
<div class="line">                              00 00</div>
<div class="line">+430  m4 @0x00007fdb2ac0f488                       &lt;label&gt;</div>
<div class="line">+430  L4 @0x00007fdb2ac0ed38  c4 e1 f4 47 c9       kxorq  %k1 %k1 -&gt; %k1                       <span class="comment">// Clear the mask reg.</span></div>
<div class="line">+435  m4 @0x00007fdb2ac0ee00  65 48 8b 0c 25 20 00 mov    %gs:0x20[8<span class="keywordtype">byte</span>] -&gt; %rcx</div>
<div class="line">                              00 00</div>
<div class="line">+444  m4 @0x00007fdb2ac0ee98  48 8b 89 f0 0a 00 00 mov    0x00000af0(%rcx)[8byte] -&gt; %rcx</div>
<div class="line">+451  m4 @0x00007fdb2ac0efb0  48 8b 09             mov    (%rcx)[8byte] -&gt; %rcx</div>
<div class="line">+454  m4 @0x00007fdb2ac0bee8  48 8b 49 10          mov    0x10(%rcx)[8<span class="keywordtype">byte</span>] -&gt; %rcx</div>
<div class="line">+458  m4 @0x00007fdb2ac0c750  48 8b 49 08          mov    0x08(%rcx)[8byte] -&gt; %rcx</div>
<div class="line">+462  m4 @0x00007fdb2ac0be68  62 f1 7c 48 28 01    vmovaps {%k0} (%rcx)[64<span class="keywordtype">byte</span>] -&gt; %zmm0       <span class="comment">// Manually restore the scratch zmm reg.</span></div>
<div class="line">+468  m4 @0x00007fdb2ac0bca0  65 48 8b 0c 25 e8 00 mov    %gs:0x000000e8[8<span class="keywordtype">byte</span>] -&gt; %rcx        <span class="comment">// Restore the first scratch GPR using drreg.</span></div>
<div class="line">                              00 00</div>
<div class="line">+477  m4 @0x00007fdb2ac0c6d0  65 48 8b 14 25 f0 00 mov    %gs:0x000000f0[8<span class="keywordtype">byte</span>] -&gt; %rdx        <span class="comment">// Restore the second scratch GPR using drreg.</span></div>
<div class="line">                              00 00</div>
<div class="line">+486  m4 @0x00007fdb2ac0be00  3c 81                cmp    %al $0x81</div>
<div class="line">+488  m4 @0x00007fdb2ac0b8b8  9e                   sahf   %ah</div>
<div class="line">+489  m4 @0x00007fdb2ac0cc20  65 48 a1 e0 00 00 00 mov    %gs:0x000000e0[8<span class="keywordtype">byte</span>] -&gt; %rax        <span class="comment">// Restore aflags using drreg.</span></div>
<div class="line">                              00 00 00 00</div>
<div class="line">+500  m4 @0x00007fdb2ac0baa0                       &lt;label&gt;</div>
</div><!-- fragment --><p>As shown by the above expanded scatter and gather sequences, we require scratch registers for the expansion. The GPR scratch registers are obtained using drreg, whereas the scratch <code>zmm</code> register and the scratch mask register are obtained by manually spilling them.</p>
<p>We need to make sure that we restore the application state correctly when a state restoration event occurs, which can be a fault in one of the scalar loads or stores in the expanded sequence, a fault in instrumentation added by some other DR client, or some async event like DR detach. While the spilled registers obtained from drreg are restored by the drreg state restoration logic, drx still needs to restore the scratch mask register that is spilled manually to a GPR, and the scratch <code>zmm</code> register that is spilled manually to a drx spill slot. We also need to ensure that the bit for the previous access is cleared if the state restore event happened after the load or store completed but before we could reflect it in the mask. When a state restore event occurs, we walk the expanded sequence using a state machine till we reach the faulting pc, keeping track of the state that needs to be restored (<a href="https://github.com/DynamoRIO/dynamorio/commit/de511a72197e9b04a9732f33622fe7bc7fd12623">commit</a>, <a href="https://github.com/DynamoRIO/dynamorio/commit/e54913b4845794b96e8682ba6a214d54e10741a0">commit</a>).</p>
<p>As pointed out above, this expansion is done in the app2app phase. DR clients may use drreg to get scratch registers for their instrumentation in later phases (like insertion or instru2instru). While drreg indeed supports some basic usage outside of the insertion phase, it does not mitigate bad interactions by such multi-phase use. The following section talks about the changes made in drreg to support multi-phase use.</p>
<h2><a class="anchor" id="autotoc_md260"></a>
Drreg Support For Multi-phase Reservations</h2>
<p>Owner: <a href="https://github.com/abhinav92003">Abhinav Sharma</a></p>
<p>Upstream issue: <a href="https://github.com/DynamoRIO/dynamorio/issues/3823">DynamoRIO/dynamorio#3823</a></p>
<p>Drreg is DynamoRIOâ€™s register reservation framework. It allows users to reserve a register to use as scratch. Internally, drreg automatically performs the following functions so that the user does not need to. Drreg</p><ul>
<li>keeps all required book-keeping like the spill slot to spilled register mapping</li>
<li>restores spilled registers to their application value before they are read by an application instruction; also, it re-spills the spilled registers if they are written by an application instruction.</li>
<li>performs application state restoration on state restore events like encountering an application fault, and DR detach.</li>
</ul>
<p>While expanding a scatter or gather instruction in the app2app phase, we need a scratch register to hold the scalar values and masks. In later phases (like the insertion or the instru2instru phase), drcachesim and other DR clients may also use drreg to get scratch registers for their instrumentation.</p>
<p>Drreg initially supported only insertion phase use, with some basic support in other phases. Importantly, it did not attempt to avoid any bad interactions between the multiple phases. To support multi-phase use of drreg, we needed to solve the following:</p><ul>
<li>avoid spill slot conflict across multiple phases: multi-phase use can potentially lead to spill slot conflicts if the same slot is selected in multiple phases. This may clobber the spilled application value and cause the application to crash or otherwise fail.</li>
<li>allow aflags spill to any slot: drreg hardcoded the aflags spill slot as the zero-th slot, to simplify some logic. To support the ability to spill aflags in multiple phases, drreg should be able to use any spill slot for aflags.</li>
<li>application state restore logic: on a state restore event, we should be able to figure out which slot contains each spilled register's app value. This is complicated by the fact that registers may be spilled by instrumentation added by multiple phases, and the spill regions may overlap which causes the spilled application value to be moved between spill slots.</li>
</ul>
<p>We explored the following ideas to avoid spill slot conflicts in drreg:</p>
<p><b>Disjoint slot spaces or arenas</b></p>
<p>We can ask drreg to create slot spaces or arenas at init time, which are assigned disjoint spill slots. When reserving a register, the user passes in a "space/arena
Id" to instruct drreg to pick free slots only from that arena. This requires keeping some global drreg state. This also requires the user to guess the best configuration for assigning slots to the arenas, and passing the correct arena Id before each reservation. It may artificially make some spill slots unavailable for use, thereby reducing efficiency.</p>
<p><b>Assign phase Id to slots</b></p>
<p>Instead of creating slot spaces at init time with a best-guess assignment of slots, we can instead assign a phase Id to slots when they are requested in that phase. We then avoid using slots that are already assigned a phase Id, when we are not in that phase where the slot was used before. This also requires keeping some global drreg state. This does not help in avoiding spill slot conflicts between multiple clients in the same phase.</p>
<p><b>Preferred: Scan fragment to determine eligible slots</b></p>
<p>When picking a spill slot, we can determine whether using it will cause a slot conflict by scanning for its uses in the current fragment after the current instruction. We pick only that spill slot which does not have any later uses in the current fragment. This does not require any init time guesses or keeping any global drreg state. It does not impose any additional responsibilities on the users, and it also works for multiple clients in the same phase. This was implemented to pick spill slots for GPRs (<a href="https://github.com/DynamoRIO/dynamorio/commit/238bb25de02d4741f52ec368e2118244329d76f0">commit</a>) and aflags too (<a href="https://github.com/DynamoRIO/dynamorio/commit/a3d0419e4d05113ca8c665f4ef0edb970e3bcf58">commit</a>).</p>
<h3><a class="anchor" id="autotoc_md261"></a>
State Restoration For Drreg</h3>
<p>Owner: <a href="https://github.com/abhinav92003">Abhinav Sharma</a></p>
<p>Upstream issue: <a href="https://github.com/DynamoRIO/dynamorio/issues/3823">DynamoRIO/dynamorio#3823</a>, <a href="https://github.com/DynamoRIO/dynamorio/issues/3801">DynamoRIO/dynamorio#3801</a></p>
<p>On a state restore event, drreg should be able to restore all spilled registers to their application values.</p>
<p>Unfortunately, when a state restore event happens, we only have the encoded fragment, and none of the drreg state, like the register to spill slot mappings. We need to reconstruct this state based on the faulting pc and the encoded fragment.</p>
<p>It is complex to determine which registers need to be restored and from which spill slot. This is because drreg automatically adds spill and restore instructions to handle various complex cases like automatic re-spilling of reserved registers after their application write instruction, and automatic restore of reserved registers before their application read instruction. Drreg also uses various optimisations like lazy restores for application values in case the register is reserved again. This is even more complex for aflags, for which spill and restore require atleast two steps (spilling aflags involves reading aflags into a register using <code>lahf</code> and then writing that register to a spill slot; restoring aflags involves reading aflags from its spill slot to a register, and then writing aflags from that register using <code>sahf</code>); and an additional step for reading or writing the overflow flag if needed. In some cases, aflags are even kept in a register as an optimisation.</p>
<p>Additionally, in multi-phase use, a register may be spilled by multiple phases, with a separate spill slot for each phase. The application value for the register may reside in one or more spill slots, and may also move between spill slots based on how the spill regions from different phases overlap. See various tricky scenarios in <a href="https://github.com/DynamoRIO/dynamorio/blob/f1d496b451eaa6e9aaff7125617030164c6cfdff/suite/tests/client-interface/drreg-test.c#L637">drreg-test.c</a>.</p>
<p>We explored two ways to adapt drregâ€™s state restoration logic to multi-phase use. This also fixed some known existing issues with drreg: <a href="https://github.com/DynamoRIO/dynamorio/issues/4933">Dynamorio/dynamorio#4933</a>, <a href="https://github.com/DynamoRIO/dynamorio/issues/4939">DynamoRIO/dynamorio#4939</a>.</p>
<p><b>Track app values as they are moved between slots and registers</b></p>
<p>At a state restoration event, we walk the faulting fragment from beginning to the faulting instruction, and we keep track of where the native value of each register is present. At any point, it may be present in the register itself, a spill slot, or both. We track <code>gpr_is_native</code> to denote whether a register contains its native app value or not; and <code>spill_slot_to_reg</code>, to denote which registerâ€™s app value a spill slot contains.</p>
<ul>
<li>When a register is written by an application instruction, we invalidate all <code>spill_slot_to_reg</code> entries that are mapped to that register, and also set <code>gpr_is_native</code> for that register.</li>
<li>When a register is written by a non-drreg meta instruction, we clear <code>gpr_is_native</code> for that reg.</li>
<li>When a register is loaded by drreg from the slot it was spilled to, we set <code>gpr_is_native</code>.</li>
<li>When a register is spilled to some spill slot, we set <code>spill_slot_to_reg</code> for that spill slot to that reg.</li>
</ul>
<p>This strategy allows us to robustly keep track of the various corner cases that can arise in drreg, like spill regions from different phases overlapping (nesting or just overlapping), and the other known issues linked above. This was implemented by this <a href="https://github.com/DynamoRIO/dynamorio/commit/f62441bc2a0ced41263e2229deb3691433d6abb9">commit</a>.</p>
<p>The drawback of this approach is that it needs to be aware of other methods of spilling and restoring registers outside drreg (<a href="https://github.com/DynamoRIO/dynamorio/pull/4987">dropped PR</a>). DynamoRIO uses various such methods internally (spilling to stack, slots not managed by drreg), and also the client may use their own unique methods. So, some non-drreg meta instructions may actually restore an application value to a register, but this approach will not be able to recognize that. This may cause it to lose track of some registerâ€™s application value. We dropped this approach on encountering <a href="https://github.com/DynamoRIO/dynamorio/issues/4963">DynamoRIO/dynamorio#4963</a>.</p>
<p><b>Preferred: Pairing restores with spills (instead of the other way)</b></p>
<p>The key observation behind this approach is that it is easier to find the matching spill for a given restore, than to find the matching restore for a given spill. This is because there may be other restores besides the final restore, e.g. restores for app read, user prompted restores, etc. This makes it hard to find exactly where the spill region for a register/aflags ends. Additional complexities include the fact that aflags re-spills may not use the same slot, which makes differentiating spills from multiple phases difficult.</p>
<p>Each restore must have a matching spill. Based on this observation, we scan the faulting fragment from end to beginning, matching register restores to their spills. When we reach the faulting instruction, any restore for which we did not see the matching spill yet must be performed by the drreg state restoration. This was implemented by (<a href="https://github.com/DynamoRIO/dynamorio/commit/be78c124eb787601182e3c73f4be8bb859c50ef8">commit</a>).</p>
<p>This algorithm does not need to be aware of non-drreg methods of spilling/restoring registers. Note that, like the general drreg operation, this method does not restore the application value of a spilled GPR/aflags if they are dead at the faulting instruction. However, even dead registers need to be restored when <code><a class="el" href="struct__drreg__options__t.html#a3f7789278b96170f6b9345c6bec730b8">drreg_options_t.conservative</a></code> is set. This can be handled if there is additional metadata available to the drreg state restore callback (<a href="https://github.com/DynamoRIO/dynamorio/issues/3801">DynamoRIO/dynamorio#3801</a>).</p>
<h2><a class="anchor" id="autotoc_md262"></a>
Simplifying Instrumentation For Emulated Instructions</h2>
<p>Owner: <a href="https://github.com/derekbruening">Derek Bruening</a></p>
<p>Upstream Issue: <a href="https://github.com/DynamoRIO/dynamorio/issues/4865">DynamoRIO/dynamorio#4865</a></p>
<p>Emulated sequences like the expanded scatter and gather sequence described above pose another challenge for clients that need to observe instructions and memory references both. For observing instructions, these clients should see the original application instruction (that is, the scatter or gather instruction), whereas for observing memory references, they should see the emulated sequence (that is, all the individual scalar stores or loads). DynamoRIO should absorb this complexity and provide the required events to the client.</p>
<p>We implemented <code>drmgr_orig_app_instr_for_fetch</code>, <code>drmgr_orig_app_instr_for_operands</code> and <code>drmgr_in_emulation_region</code> APIs (<a href="https://github.com/DynamoRIO/dynamorio/commit/eb5d5af8e3444912c9f3f70e5ebf7969252ee4d6">commit</a>, <a href="https://github.com/DynamoRIO/dynamorio/commit/6d84fea04a036038db5a3af2e979e77d2cd356c0">commit</a>) that return the appropriate instruction to the client to be used for either instruction instrumentation or memory reference instrumentation. These were subsequently used in drcachesim as well (<a href="https://github.com/DynamoRIO/dynamorio/commit/8b9be0fd04e40deb41d993e8d846b69160fb4f04">commit</a>).</p>
<h2><a class="anchor" id="autotoc_md263"></a>
Support For Vector Reservation</h2>
<p>Owner: <a href="https://github.com/abhinav92003">Abhinav Sharma</a></p>
<p>The scatter and gather expansions requires a scratch <code>xmm</code> register, for which we need the capability to spill and restore vector registers. Following are the design choices:</p>
<ul>
<li>Extend drreg to support reservation for vector registers. <a href="https://github.com/DynamoRIO/dynamorio/issues/3844">DynamoRIO/dynamorio#3844</a> aims to add this support.</li>
<li>Use custom spill and restore logic in drx. We can do this by reserving memory in TLS to use as a spill slot.</li>
</ul>
<p>Some observations about this use-case for vector reservation:</p><ul>
<li>We need to spill only one vector register, so we do not need sophisticated spill slot management logic.</li>
<li>The spilled vector register will not need to be restored for app reads, or re- spilled after app writes. Note that we will not encounter any application instructions that use the spilled vector register, because it needs to be spilled only for the duration of the expanded scatter or gather sequence.</li>
</ul>
<p>Extending drreg to support vector spilling is a complex task. Given the above observations, the current use case does not justify the effort. Therefore, we chose to implement custom spill logic in drx (<a href="https://github.com/DynamoRIO/dynamorio/commit/88cba2817fef7a4d4ba3e8c2375784ea4165c133">commit</a>, <a href="https://github.com/DynamoRIO/dynamorio/commit/84bf9288a12e8e38abab04d4d8273cc3226fa13c">commit</a>).</p>
<h2><a class="anchor" id="autotoc_md264"></a>
Using The Expansion In DR Clients</h2>
<p>Owner: <a href="https://github.com/abhinav92003">Abhinav Sharma</a></p>
<p>Clients that need to observe each memory reference must use the <code>drx_expand_scatter_gather</code> API. This was added in the app2app phase of drcachesim and other DynamoRIO clients (<a href="https://github.com/DynamoRIO/dynamorio/commit/cf9d6a95262015581a5184e75ce599cc66ac4df4">commit</a>). This also required fixing some issues (crashes and correctness problems) that surfaced when all pieces were integrated (<a href="https://github.com/DynamoRIO/dynamorio/commit/ced6e253b2e6bb7f1402398798d4bd8a988dacd0">commit</a>, <a href="https://github.com/DynamoRIO/dynamorio/commit/e9f05212a7c1f2ff969cabdacd92914865345303">commit</a>).</p>
<h1><a class="anchor" id="autotoc_md265"></a>
Testing On Large Apps</h1>
<p>Owner: <a href="https://github.com/abhinav92003">Abhinav Sharma</a></p>
<p>drcachesim was successfully used to trace an application with scatter and gather instructions. The resulting trace was observed to have millions of such instructions. We also verified correctness by comparing application output with and without tracing. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="adr__ir__instr_8h_html_ab99dd3460f2fd5abc2d59a9ddb26a6b5"><div class="ttname"><a href="dr__ir__instr_8h.html#ab99dd3460f2fd5abc2d59a9ddb26a6b5">instr_is_gather</a></div><div class="ttdeci">DR_API bool instr_is_gather(instr_t *instr)</div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:04:10 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
