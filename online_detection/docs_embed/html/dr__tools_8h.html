---
title: "/include/dr_tools.h File Reference"
layout: default
permalink: /dr__tools_8h.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_43e0a1f539e00dcfa1a6bc4d4fee4fc2.html">home</a></li><li class="navelem"><a class="el" href="dir_1036706e55c22cab35bc1c58ee689f1d.html">runner</a></li><li class="navelem"><a class="el" href="dir_629f8151d55d307162ff2d619fb1783d.html">work</a></li><li class="navelem"><a class="el" href="dir_84b917e355554dd3f3793c21ab4ddcaf.html">dynamorio</a></li><li class="navelem"><a class="el" href="dir_afee7b8fe0b60d0be677a736c14882ae.html">dynamorio</a></li><li class="navelem"><a class="el" href="dir_48474711f0a4ba29d8b16b7ca2362db9.html">build_release-32</a></li><li class="navelem"><a class="el" href="dir_e77cb64d414c273b7d0ccb7a22f80058.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dr_tools.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main API routines, including transparency support.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__memory__dump__spec__t.html">_dr_memory_dump_spec_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__syscall__result__info__t.html">_dr_syscall_result_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4e6bdc93e35ee5a9f081564a162ec3b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4e6bdc93e35ee5a9f081564a162ec3b9">GLOBAL_DCONTEXT</a>&#160;&#160;&#160;((void *)-1)</td></tr>
<tr class="separator:a4e6bdc93e35ee5a9f081564a162ec3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6d066ab9bdd578d4000e80df8503bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abd6d066ab9bdd578d4000e80df8503bc">DR_ASSERT_MSG</a>(x,  msg)</td></tr>
<tr class="separator:abd6d066ab9bdd578d4000e80df8503bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c07630dffdfd92bc6ee63abf405768c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7c07630dffdfd92bc6ee63abf405768c">DR_ASSERT</a>(x)&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#abd6d066ab9bdd578d4000e80df8503bc">DR_ASSERT_MSG</a>(x, &quot;&quot;)</td></tr>
<tr class="separator:a7c07630dffdfd92bc6ee63abf405768c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0772bc47090cec1a333baf1259f226d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad0772bc47090cec1a333baf1259f226d">DR_FILE_READ</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:ad0772bc47090cec1a333baf1259f226d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f713faf2e1eac95bc26a98b67e28cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a11f713faf2e1eac95bc26a98b67e28cc">DR_FILE_WRITE_REQUIRE_NEW</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:a11f713faf2e1eac95bc26a98b67e28cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac989ab040f48c4c91cc3a6ea63f9ec1f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac989ab040f48c4c91cc3a6ea63f9ec1f">DR_FILE_WRITE_APPEND</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:ac989ab040f48c4c91cc3a6ea63f9ec1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb30eb2b5d14486b3ecbc2b2457dfdb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5fb30eb2b5d14486b3ecbc2b2457dfdb">DR_FILE_WRITE_OVERWRITE</a>&#160;&#160;&#160;0x8</td></tr>
<tr class="separator:a5fb30eb2b5d14486b3ecbc2b2457dfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a3b276c8d9a62bf6d78c3707d4effd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a77a3b276c8d9a62bf6d78c3707d4effd">DR_FILE_ALLOW_LARGE</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:a77a3b276c8d9a62bf6d78c3707d4effd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0401a3003f578602bf31a984a4d5419d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0401a3003f578602bf31a984a4d5419d">DR_FILE_CLOSE_ON_FORK</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:a0401a3003f578602bf31a984a4d5419d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71a8471b604df56ae2fa05ba66e03be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac71a8471b604df56ae2fa05ba66e03be">DR_FILE_WRITE_ONLY</a>&#160;&#160;&#160;0x40</td></tr>
<tr class="separator:ac71a8471b604df56ae2fa05ba66e03be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa675a6270b664511299295ebc1f5562e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa675a6270b664511299295ebc1f5562e">DR_SEEK_SET</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:aa675a6270b664511299295ebc1f5562e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31bd52878d2454d8263d0951cfd1ca0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad31bd52878d2454d8263d0951cfd1ca0">DR_SEEK_CUR</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ad31bd52878d2454d8263d0951cfd1ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e58c043e838f1457853329fd4344a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a06e58c043e838f1457853329fd4344a3">DR_SEEK_END</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a06e58c043e838f1457853329fd4344a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f9b317b468d5e1e3599f3080db7739"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a80f9b317b468d5e1e3599f3080db7739">DR_LOG_NONE</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:a80f9b317b468d5e1e3599f3080db7739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfc4dffcec6a5f6b5851f81e5f2575e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1bfc4dffcec6a5f6b5851f81e5f2575e">DR_LOG_STATS</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:a1bfc4dffcec6a5f6b5851f81e5f2575e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95a611b85c11e557bd2d541c9ed7d22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa95a611b85c11e557bd2d541c9ed7d22">DR_LOG_TOP</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:aa95a611b85c11e557bd2d541c9ed7d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58660d789f8390d329d24f5bd4ac0800"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a58660d789f8390d329d24f5bd4ac0800">DR_LOG_THREADS</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="separator:a58660d789f8390d329d24f5bd4ac0800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187545302d9056b56df6ea2453e2f92d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a187545302d9056b56df6ea2453e2f92d">DR_LOG_SYSCALLS</a>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="separator:a187545302d9056b56df6ea2453e2f92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ba7d86027989b56768e2275246182e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae2ba7d86027989b56768e2275246182e">DR_LOG_ASYNCH</a>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="separator:ae2ba7d86027989b56768e2275246182e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8cedc710c8c450fd09b6542cd5aadc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#add8cedc710c8c450fd09b6542cd5aadc">DR_LOG_INTERP</a>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="separator:add8cedc710c8c450fd09b6542cd5aadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea15a10e6af6dd1f03b6967529b776fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aea15a10e6af6dd1f03b6967529b776fc">DR_LOG_EMIT</a>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="separator:aea15a10e6af6dd1f03b6967529b776fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e0fc2c5c4028f645ab816d0fe06224"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a56e0fc2c5c4028f645ab816d0fe06224">DR_LOG_LINKS</a>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="separator:a56e0fc2c5c4028f645ab816d0fe06224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8714ae07e5f382ab7d989c14c406b935"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8714ae07e5f382ab7d989c14c406b935">DR_LOG_CACHE</a>&#160;&#160;&#160;0x00000100</td></tr>
<tr class="separator:a8714ae07e5f382ab7d989c14c406b935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a1fd3e3710f996d26fa1ac8d3fc369"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae6a1fd3e3710f996d26fa1ac8d3fc369">DR_LOG_FRAGMENT</a>&#160;&#160;&#160;0x00000200</td></tr>
<tr class="separator:ae6a1fd3e3710f996d26fa1ac8d3fc369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c8a0e03b86826f823a169b40699e4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af2c8a0e03b86826f823a169b40699e4f">DR_LOG_DISPATCH</a>&#160;&#160;&#160;0x00000400</td></tr>
<tr class="separator:af2c8a0e03b86826f823a169b40699e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de43f77fcbc908d6ab61f1731db4210"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5de43f77fcbc908d6ab61f1731db4210">DR_LOG_MONITOR</a>&#160;&#160;&#160;0x00000800</td></tr>
<tr class="separator:a5de43f77fcbc908d6ab61f1731db4210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827401778f0f0f90f445c975c5e2f7c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a827401778f0f0f90f445c975c5e2f7c4">DR_LOG_HEAP</a>&#160;&#160;&#160;0x00001000</td></tr>
<tr class="separator:a827401778f0f0f90f445c975c5e2f7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fff9a38640df11852f0aa877452c63e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4fff9a38640df11852f0aa877452c63e">DR_LOG_VMAREAS</a>&#160;&#160;&#160;0x00002000</td></tr>
<tr class="separator:a4fff9a38640df11852f0aa877452c63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf35bd0a62f41090a4da1caf1f7039a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#acf35bd0a62f41090a4da1caf1f7039a9">DR_LOG_SYNCH</a>&#160;&#160;&#160;0x00004000</td></tr>
<tr class="separator:acf35bd0a62f41090a4da1caf1f7039a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52971d4b126b22c760012bdcdba4796e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a52971d4b126b22c760012bdcdba4796e">DR_LOG_MEMSTATS</a>&#160;&#160;&#160;0x00008000</td></tr>
<tr class="separator:a52971d4b126b22c760012bdcdba4796e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e132f043e5fa8d48d32c8cde6ef51d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a31e132f043e5fa8d48d32c8cde6ef51d">DR_LOG_OPTS</a>&#160;&#160;&#160;0x00010000</td></tr>
<tr class="separator:a31e132f043e5fa8d48d32c8cde6ef51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5211b8fe9028d7ffac630d732eaf0614"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5211b8fe9028d7ffac630d732eaf0614">DR_LOG_SIDELINE</a>&#160;&#160;&#160;0x00020000</td></tr>
<tr class="separator:a5211b8fe9028d7ffac630d732eaf0614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4605a61344628bdc31d15abd49a426ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4605a61344628bdc31d15abd49a426ba">DR_LOG_SYMBOLS</a>&#160;&#160;&#160;0x00040000</td></tr>
<tr class="separator:a4605a61344628bdc31d15abd49a426ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d4f7e0b8756ff97ce6eb4831f53177"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa5d4f7e0b8756ff97ce6eb4831f53177">DR_LOG_RCT</a>&#160;&#160;&#160;0x00080000</td></tr>
<tr class="separator:aa5d4f7e0b8756ff97ce6eb4831f53177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8915da4b3e63046309d88e761121e959"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8915da4b3e63046309d88e761121e959">DR_LOG_NT</a>&#160;&#160;&#160;0x00100000</td></tr>
<tr class="separator:a8915da4b3e63046309d88e761121e959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ade83ca6b1ca70c099f1cd775ec10ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0ade83ca6b1ca70c099f1cd775ec10ca">DR_LOG_HOT_PATCHING</a>&#160;&#160;&#160;0x00200000</td></tr>
<tr class="separator:a0ade83ca6b1ca70c099f1cd775ec10ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b470dff6d385ef7feb2f456356d0f2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3b470dff6d385ef7feb2f456356d0f2b">DR_LOG_HTABLE</a>&#160;&#160;&#160;0x00400000</td></tr>
<tr class="separator:a3b470dff6d385ef7feb2f456356d0f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa772ad5c6339d52ca27b3da7e64a272d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa772ad5c6339d52ca27b3da7e64a272d">DR_LOG_MODULEDB</a>&#160;&#160;&#160;0x00800000</td></tr>
<tr class="separator:aa772ad5c6339d52ca27b3da7e64a272d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab56792af6a64911a9e62dfeb8b0981"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#acab56792af6a64911a9e62dfeb8b0981">DR_LOG_ALL</a>&#160;&#160;&#160;0x00ffffff</td></tr>
<tr class="separator:acab56792af6a64911a9e62dfeb8b0981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1632479322efa3952798f98177b54471"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1632479322efa3952798f98177b54471">LOG_NONE</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a80f9b317b468d5e1e3599f3080db7739">DR_LOG_NONE</a></td></tr>
<tr class="separator:a1632479322efa3952798f98177b54471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd9f361c4a23133f724c84192eef8e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9dd9f361c4a23133f724c84192eef8e1">LOG_STATS</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a1bfc4dffcec6a5f6b5851f81e5f2575e">DR_LOG_STATS</a></td></tr>
<tr class="separator:a9dd9f361c4a23133f724c84192eef8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdb93b09477bb1b1ee08d132dd6f4dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9fdb93b09477bb1b1ee08d132dd6f4dc">LOG_TOP</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#aa95a611b85c11e557bd2d541c9ed7d22">DR_LOG_TOP</a></td></tr>
<tr class="separator:a9fdb93b09477bb1b1ee08d132dd6f4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9390202fe239f2ee56c097d6940d10f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9390202fe239f2ee56c097d6940d10f6">LOG_THREADS</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a58660d789f8390d329d24f5bd4ac0800">DR_LOG_THREADS</a></td></tr>
<tr class="separator:a9390202fe239f2ee56c097d6940d10f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ef794555c43a1988eb760835b2fa76"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a87ef794555c43a1988eb760835b2fa76">LOG_SYSCALLS</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a187545302d9056b56df6ea2453e2f92d">DR_LOG_SYSCALLS</a></td></tr>
<tr class="separator:a87ef794555c43a1988eb760835b2fa76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5895b0ef2efc255ad93e50bc88277b6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5895b0ef2efc255ad93e50bc88277b6d">LOG_ASYNCH</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#ae2ba7d86027989b56768e2275246182e">DR_LOG_ASYNCH</a></td></tr>
<tr class="separator:a5895b0ef2efc255ad93e50bc88277b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bbda8cb7e78f2ea32209bab2d7201c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a54bbda8cb7e78f2ea32209bab2d7201c">LOG_INTERP</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#add8cedc710c8c450fd09b6542cd5aadc">DR_LOG_INTERP</a></td></tr>
<tr class="separator:a54bbda8cb7e78f2ea32209bab2d7201c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06582648acdd995a11019f726b15adda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a06582648acdd995a11019f726b15adda">LOG_EMIT</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#aea15a10e6af6dd1f03b6967529b776fc">DR_LOG_EMIT</a></td></tr>
<tr class="separator:a06582648acdd995a11019f726b15adda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438ad3561d9d8616ff702b36d0b2bb7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a438ad3561d9d8616ff702b36d0b2bb7c">LOG_LINKS</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a56e0fc2c5c4028f645ab816d0fe06224">DR_LOG_LINKS</a></td></tr>
<tr class="separator:a438ad3561d9d8616ff702b36d0b2bb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031661fca6b5cb813db972d758caca2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a031661fca6b5cb813db972d758caca2b">LOG_CACHE</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a8714ae07e5f382ab7d989c14c406b935">DR_LOG_CACHE</a></td></tr>
<tr class="separator:a031661fca6b5cb813db972d758caca2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5fcb805e6a1fdfac332931888b3ef7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7c5fcb805e6a1fdfac332931888b3ef7">LOG_FRAGMENT</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#ae6a1fd3e3710f996d26fa1ac8d3fc369">DR_LOG_FRAGMENT</a></td></tr>
<tr class="separator:a7c5fcb805e6a1fdfac332931888b3ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9929e24db31369398fbdc52ee040b234"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9929e24db31369398fbdc52ee040b234">LOG_DISPATCH</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#af2c8a0e03b86826f823a169b40699e4f">DR_LOG_DISPATCH</a></td></tr>
<tr class="separator:a9929e24db31369398fbdc52ee040b234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2575baf458eee6334f746544f91fa6cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2575baf458eee6334f746544f91fa6cf">LOG_MONITOR</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a5de43f77fcbc908d6ab61f1731db4210">DR_LOG_MONITOR</a></td></tr>
<tr class="separator:a2575baf458eee6334f746544f91fa6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5522e92b98898a21b7c26ba9df95f094"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5522e92b98898a21b7c26ba9df95f094">LOG_HEAP</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a827401778f0f0f90f445c975c5e2f7c4">DR_LOG_HEAP</a></td></tr>
<tr class="separator:a5522e92b98898a21b7c26ba9df95f094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557f3a77c5d95b7cd06661245030c687"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a557f3a77c5d95b7cd06661245030c687">LOG_VMAREAS</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a4fff9a38640df11852f0aa877452c63e">DR_LOG_VMAREAS</a></td></tr>
<tr class="separator:a557f3a77c5d95b7cd06661245030c687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8879b800acfbbe8f2ada805be6ef5121"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8879b800acfbbe8f2ada805be6ef5121">LOG_SYNCH</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#acf35bd0a62f41090a4da1caf1f7039a9">DR_LOG_SYNCH</a></td></tr>
<tr class="separator:a8879b800acfbbe8f2ada805be6ef5121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb9931c63f1cf95cacca6463d5a9b09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aabb9931c63f1cf95cacca6463d5a9b09">LOG_MEMSTATS</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a52971d4b126b22c760012bdcdba4796e">DR_LOG_MEMSTATS</a></td></tr>
<tr class="separator:aabb9931c63f1cf95cacca6463d5a9b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f746aa1ef6a208cd1cd7174a694c9e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9f746aa1ef6a208cd1cd7174a694c9e5">LOG_OPTS</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a31e132f043e5fa8d48d32c8cde6ef51d">DR_LOG_OPTS</a></td></tr>
<tr class="separator:a9f746aa1ef6a208cd1cd7174a694c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad7f6071c29a882af67d3a72fe4e787"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8ad7f6071c29a882af67d3a72fe4e787">LOG_SIDELINE</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a5211b8fe9028d7ffac630d732eaf0614">DR_LOG_SIDELINE</a></td></tr>
<tr class="separator:a8ad7f6071c29a882af67d3a72fe4e787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65630bab8d9fcde517b3f8ecb03c6de9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a65630bab8d9fcde517b3f8ecb03c6de9">LOG_SYMBOLS</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a4605a61344628bdc31d15abd49a426ba">DR_LOG_SYMBOLS</a></td></tr>
<tr class="separator:a65630bab8d9fcde517b3f8ecb03c6de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297668a84187b740ff4fe1e1d6e52eeb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a297668a84187b740ff4fe1e1d6e52eeb">LOG_RCT</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#aa5d4f7e0b8756ff97ce6eb4831f53177">DR_LOG_RCT</a></td></tr>
<tr class="separator:a297668a84187b740ff4fe1e1d6e52eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3856a58f1f9971ebcd62c99a448a5a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4f3856a58f1f9971ebcd62c99a448a5a">LOG_NT</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a8915da4b3e63046309d88e761121e959">DR_LOG_NT</a></td></tr>
<tr class="separator:a4f3856a58f1f9971ebcd62c99a448a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c2bbdf11618716da67a305dd24ddde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a51c2bbdf11618716da67a305dd24ddde">LOG_HOT_PATCHING</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a0ade83ca6b1ca70c099f1cd775ec10ca">DR_LOG_HOT_PATCHING</a></td></tr>
<tr class="separator:a51c2bbdf11618716da67a305dd24ddde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec73009ed3f0c2baa1d3c44033c261e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a6ec73009ed3f0c2baa1d3c44033c261e">LOG_HTABLE</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a3b470dff6d385ef7feb2f456356d0f2b">DR_LOG_HTABLE</a></td></tr>
<tr class="separator:a6ec73009ed3f0c2baa1d3c44033c261e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba5e74dd3a5577b7af5177960ecb9dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abba5e74dd3a5577b7af5177960ecb9dd">LOG_MODULEDB</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#aa772ad5c6339d52ca27b3da7e64a272d">DR_LOG_MODULEDB</a></td></tr>
<tr class="separator:abba5e74dd3a5577b7af5177960ecb9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7574ce4aa047de1f4a564c9b441e69dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7574ce4aa047de1f4a564c9b441e69dc">LOG_ALL</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#acab56792af6a64911a9e62dfeb8b0981">DR_LOG_ALL</a></td></tr>
<tr class="separator:a7574ce4aa047de1f4a564c9b441e69dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a97f41adcd55bab41fd0ff817bfaff1c3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__memory__dump__spec__t.html">_dr_memory_dump_spec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a97f41adcd55bab41fd0ff817bfaff1c3">dr_memory_dump_spec_t</a></td></tr>
<tr class="separator:a97f41adcd55bab41fd0ff817bfaff1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc574aa98b0e727a9b75059c4966eb10"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__syscall__result__info__t.html">_dr_syscall_result_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afc574aa98b0e727a9b75059c4966eb10">dr_syscall_result_info_t</a></td></tr>
<tr class="separator:afc574aa98b0e727a9b75059c4966eb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a00269a3ba590923c5d0ec4e0bcf5a9ff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a00269a3ba590923c5d0ec4e0bcf5a9ff">dr_memory_dump_flags_t</a> { <a class="el" href="dr__tools_8h.html#a00269a3ba590923c5d0ec4e0bcf5a9ffa00ec80b5919c0e6e1dc361a5fa9af02f">DR_MEMORY_DUMP_LDMP</a> = 0x0001
 }</td></tr>
<tr class="separator:a00269a3ba590923c5d0ec4e0bcf5a9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7e20e83f7b8e1b65428e45c8ab4211"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211">dr_alloc_flags_t</a> { <br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f">DR_ALLOC_NON_HEAP</a> = 0x0001, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211a312d65229e3450b24e59aec4b7d7410e">DR_ALLOC_THREAD_PRIVATE</a> = 0x0002, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ab33a2e990410bf314bdebe6a25aa06e1">DR_ALLOC_CACHE_REACHABLE</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211a8bcd3bdb2ed2f71a1a7329274a195585">DR_ALLOC_FIXED_LOCATION</a> = 0x0008, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ae32c4869e0c01cb57834e5ee7c163186">DR_ALLOC_LOW_2GB</a> = 0x0010, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211aa0d11211c580eb6b368d07cb7546e376">DR_ALLOC_NON_DR</a> = 0x0020, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211a5d2a736bd28da9bfd1a3238777c74558">DR_ALLOC_RESERVE_ONLY</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211a0f6cd06c9a4aa053b4e39fbde1fe7be1">DR_ALLOC_COMMIT_ONLY</a> = 0x0080
<br />
 }</td></tr>
<tr class="separator:abb7e20e83f7b8e1b65428e45c8ab4211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade307e7bb7b7ac46e874097fe62b9fef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ade307e7bb7b7ac46e874097fe62b9fef">dr_map_executable_flags_t</a> { <a class="el" href="dr__tools_8h.html#ade307e7bb7b7ac46e874097fe62b9fefa183f27400568e903a072c9fc5bf0af96">DR_MAPEXE_SKIP_WRITABLE</a> = 0x0002
 }</td></tr>
<tr class="separator:ade307e7bb7b7ac46e874097fe62b9fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fca1837c5ce7715cbf571669660c13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a39fca1837c5ce7715cbf571669660c13ace272a4f3f0eff24ef44c983bfa4ce63">DR_MAP_PRIVATE</a> = 0x0001, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a39fca1837c5ce7715cbf571669660c13aec0156a07c55523ed4bb3d2f05c00b58">DR_MAP_FIXED</a> = 0x0002, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a39fca1837c5ce7715cbf571669660c13a12a6a7af3936e4c932effc9505f23be5">DR_MAP_IMAGE</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a39fca1837c5ce7715cbf571669660c13a6ba2a46cb1c2697fa81841feb05a777c">DR_MAP_CACHE_REACHABLE</a> = 0x0008
<br />
 }</td></tr>
<tr class="separator:a39fca1837c5ce7715cbf571669660c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bef18f8eabc7a8b8b0368e8a96d179"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a66bef18f8eabc7a8b8b0368e8a96d179">dr_suspend_flags_t</a> { <a class="el" href="dr__tools_8h.html#a66bef18f8eabc7a8b8b0368e8a96d179a21ba834e13979aa7ad97fd13c69b3ae4">DR_SUSPEND_NATIVE</a> = 0x0001
 }</td></tr>
<tr class="separator:a66bef18f8eabc7a8b8b0368e8a96d179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d99790cec275b8bad73c09b68279911"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3d99790cec275b8bad73c09b68279911">dr_indirect_branch_type_t</a> { <br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a3d99790cec275b8bad73c09b68279911a628ceb4b2f3a6421c2a882de0a69e2d2">DR_INDIRECT_RETURN</a>, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a3d99790cec275b8bad73c09b68279911a46a3285d13908b2c79e368074a0d8d06">DR_INDIRECT_CALL</a>, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a3d99790cec275b8bad73c09b68279911ab9d3c8a5bd0110f7e638b9581524bbec">DR_INDIRECT_JUMP</a>
<br />
 }</td></tr>
<tr class="separator:a3d99790cec275b8bad73c09b68279911"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0917d634fe88c7d368eb6a20c17c55cb"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0917d634fe88c7d368eb6a20c17c55cb">dr_standalone_init</a> (void)</td></tr>
<tr class="separator:a0917d634fe88c7d368eb6a20c17c55cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407fa7ac15e482174d2ff75dcc312192"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a407fa7ac15e482174d2ff75dcc312192">dr_standalone_exit</a> (void)</td></tr>
<tr class="separator:a407fa7ac15e482174d2ff75dcc312192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684c0fc332a5e5aa11c28ad3d1a6ef57"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a684c0fc332a5e5aa11c28ad3d1a6ef57">dr_using_all_private_caches</a> (void)</td></tr>
<tr class="separator:a684c0fc332a5e5aa11c28ad3d1a6ef57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558ef634eff90b0e777cddb73983617a"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a558ef634eff90b0e777cddb73983617a">dr_request_synchronized_exit</a> (void)</td></tr>
<tr class="separator:a558ef634eff90b0e777cddb73983617a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc4a7a38a1fa1fe45c1a15e01a98e78"><td class="memItemLeft" align="right" valign="top">const DR_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#affc4a7a38a1fa1fe45c1a15e01a98e78">dr_get_options</a> (<a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> client_id)</td></tr>
<tr class="separator:affc4a7a38a1fa1fe45c1a15e01a98e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f53df83b2108925fa52bd607536e25d"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5f53df83b2108925fa52bd607536e25d">dr_get_option_array</a> (<a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> client_id, int *argc OUT, const char ***argv OUT)</td></tr>
<tr class="separator:a5f53df83b2108925fa52bd607536e25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8202a00c908f0e98083cc2183abc40"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7d8202a00c908f0e98083cc2183abc40">dr_get_string_option</a> (const char *option_name, char *buf OUT, size_t len)</td></tr>
<tr class="separator:a7d8202a00c908f0e98083cc2183abc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b43ec2cea34645dab0282cf6204d226"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0b43ec2cea34645dab0282cf6204d226">dr_get_integer_option</a> (const char *option_name, uint64 *val OUT)</td></tr>
<tr class="separator:a0b43ec2cea34645dab0282cf6204d226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccb9210ada84de4fbbaa8d851952a37"><td class="memItemLeft" align="right" valign="top">const DR_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afccb9210ada84de4fbbaa8d851952a37">dr_get_client_path</a> (<a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> client_id)</td></tr>
<tr class="separator:afccb9210ada84de4fbbaa8d851952a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdead1ca945b38f865c5599bdebf9d0e"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#acdead1ca945b38f865c5599bdebf9d0e">dr_get_client_base</a> (<a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> client_id)</td></tr>
<tr class="separator:acdead1ca945b38f865c5599bdebf9d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0ac44591b6687a3b4b7b233c4140f8"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0b0ac44591b6687a3b4b7b233c4140f8">dr_set_client_name</a> (const char *name, const char *report_URL)</td></tr>
<tr class="separator:a0b0ac44591b6687a3b4b7b233c4140f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcf6af90fe6ca56168cd56ba09fea08"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#affcf6af90fe6ca56168cd56ba09fea08">dr_set_client_version_string</a> (const char *version)</td></tr>
<tr class="separator:affcf6af90fe6ca56168cd56ba09fea08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908074540820a8140bbc46cb3c020778"><td class="memItemLeft" align="right" valign="top">DR_API <a class="el" href="dr__defines_8h.html#a5ecc0dbd0afec416ca2626dba4cd3fe1">dr_error_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a908074540820a8140bbc46cb3c020778">dr_get_error_code</a> (void *drcontext)</td></tr>
<tr class="separator:a908074540820a8140bbc46cb3c020778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf560764ce43a11d3f5abb6e4f78dcae"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aaf560764ce43a11d3f5abb6e4f78dcae">dr_get_time</a> (<a class="el" href="structdr__time__t.html">dr_time_t</a> *time)</td></tr>
<tr class="separator:aaf560764ce43a11d3f5abb6e4f78dcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487aba7cc5d4a71cea5318e4840984e8"><td class="memItemLeft" align="right" valign="top">DR_API uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a487aba7cc5d4a71cea5318e4840984e8">dr_get_milliseconds</a> (void)</td></tr>
<tr class="separator:a487aba7cc5d4a71cea5318e4840984e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec75982f030fbae7019ecf2d54cd1c21"><td class="memItemLeft" align="right" valign="top">DR_API uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aec75982f030fbae7019ecf2d54cd1c21">dr_get_microseconds</a> (void)</td></tr>
<tr class="separator:aec75982f030fbae7019ecf2d54cd1c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036726345f9ea686b7eae46eca38e5e3"><td class="memItemLeft" align="right" valign="top">DR_API uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a036726345f9ea686b7eae46eca38e5e3">dr_get_random_value</a> (uint max)</td></tr>
<tr class="separator:a036726345f9ea686b7eae46eca38e5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc774dc54b77dcd8505277e6bc66722"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aebc774dc54b77dcd8505277e6bc66722">dr_set_random_seed</a> (uint seed)</td></tr>
<tr class="separator:aebc774dc54b77dcd8505277e6bc66722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61da9915f2e77f2bcbc4e07bcac945dc"><td class="memItemLeft" align="right" valign="top">DR_API uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a61da9915f2e77f2bcbc4e07bcac945dc">dr_get_random_seed</a> (void)</td></tr>
<tr class="separator:a61da9915f2e77f2bcbc4e07bcac945dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1fe81ae1737aa0e34eb69c855d359c"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0f1fe81ae1737aa0e34eb69c855d359c">dr_abort</a> (void)</td></tr>
<tr class="separator:a0f1fe81ae1737aa0e34eb69c855d359c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa686dee8c80b96c6615a1e42b46dbb"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aaaa686dee8c80b96c6615a1e42b46dbb">dr_abort_with_code</a> (int exit_code)</td></tr>
<tr class="separator:aaaa686dee8c80b96c6615a1e42b46dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4ac39e59bdcec70223794387db9fd0"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aec4ac39e59bdcec70223794387db9fd0">dr_exit_process</a> (int exit_code)</td></tr>
<tr class="separator:aec4ac39e59bdcec70223794387db9fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa268a6496cad930513c1f0353fdd06e"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afa268a6496cad930513c1f0353fdd06e">dr_create_memory_dump</a> (<a class="el" href="dr__tools_8h.html#a97f41adcd55bab41fd0ff817bfaff1c3">dr_memory_dump_spec_t</a> *spec)</td></tr>
<tr class="separator:afa268a6496cad930513c1f0353fdd06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d391b20559c1737c795f2ef1ba33d2"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a18d391b20559c1737c795f2ef1ba33d2">dr_thread_alloc</a> (void *drcontext, size_t size)</td></tr>
<tr class="separator:a18d391b20559c1737c795f2ef1ba33d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada5a5987fa20f96868c453cd9baacd3"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aada5a5987fa20f96868c453cd9baacd3">dr_thread_free</a> (void *drcontext, void *mem, size_t size)</td></tr>
<tr class="separator:aada5a5987fa20f96868c453cd9baacd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f6546fc3e259e64493aeda5a8f1c86"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a82f6546fc3e259e64493aeda5a8f1c86">dr_global_alloc</a> (size_t size)</td></tr>
<tr class="separator:a82f6546fc3e259e64493aeda5a8f1c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b5d7da931da632140c0e7adcdac75b"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a32b5d7da931da632140c0e7adcdac75b">dr_global_free</a> (void *mem, size_t size)</td></tr>
<tr class="separator:a32b5d7da931da632140c0e7adcdac75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527e0746207909580b705f1743537921"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a527e0746207909580b705f1743537921">dr_custom_alloc</a> (void *drcontext, <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211">dr_alloc_flags_t</a> flags, size_t size, uint prot, void *addr)</td></tr>
<tr class="separator:a527e0746207909580b705f1743537921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe9e5256b085452d5050c4b13ed541d"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#acbe9e5256b085452d5050c4b13ed541d">dr_custom_free</a> (void *drcontext, <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211">dr_alloc_flags_t</a> flags, void *addr, size_t size)</td></tr>
<tr class="separator:acbe9e5256b085452d5050c4b13ed541d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917384359d5efd538976402ff4b08aae"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a917384359d5efd538976402ff4b08aae">dr_nonheap_alloc</a> (size_t size, uint prot)</td></tr>
<tr class="separator:a917384359d5efd538976402ff4b08aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901a89de3fa6af0b48351ddea31ece81"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a901a89de3fa6af0b48351ddea31ece81">dr_nonheap_free</a> (void *mem, size_t size)</td></tr>
<tr class="separator:a901a89de3fa6af0b48351ddea31ece81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5b61c462fe7d4c5f5b78f76a6eedce"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2a5b61c462fe7d4c5f5b78f76a6eedce">dr_raw_mem_alloc</a> (size_t size, uint prot, void *addr)</td></tr>
<tr class="separator:a2a5b61c462fe7d4c5f5b78f76a6eedce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee58c732aec96032bcd5344104ef626c"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aee58c732aec96032bcd5344104ef626c">dr_raw_mem_free</a> (void *addr, size_t size)</td></tr>
<tr class="separator:aee58c732aec96032bcd5344104ef626c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c490f6719db1753260799c3a435324"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a57c490f6719db1753260799c3a435324">dr_raw_mremap</a> (void *old_address, size_t old_size, size_t new_size, int flags, void *new_address)</td></tr>
<tr class="separator:a57c490f6719db1753260799c3a435324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10936426ba45ea96761adc6d9f9d290"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab10936426ba45ea96761adc6d9f9d290">dr_raw_brk</a> (void *new_address)</td></tr>
<tr class="separator:ab10936426ba45ea96761adc6d9f9d290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eb3354bab05483603b96774149aa2e"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a26eb3354bab05483603b96774149aa2e">__wrap_malloc</a> (size_t size)</td></tr>
<tr class="separator:a26eb3354bab05483603b96774149aa2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308b0cde282bb6ad04b413a743ec2675"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a308b0cde282bb6ad04b413a743ec2675">__wrap_realloc</a> (void *mem, size_t size)</td></tr>
<tr class="separator:a308b0cde282bb6ad04b413a743ec2675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbf058d682175b76fe41767ae13198d"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afdbf058d682175b76fe41767ae13198d">__wrap_calloc</a> (size_t nmemb, size_t size)</td></tr>
<tr class="separator:afdbf058d682175b76fe41767ae13198d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4640fe5eadb1d6cb384f61524886211d"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4640fe5eadb1d6cb384f61524886211d">__wrap_free</a> (void *mem)</td></tr>
<tr class="separator:a4640fe5eadb1d6cb384f61524886211d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5122da8f1587e2c38bb4690e830ac2"><td class="memItemLeft" align="right" valign="top">DR_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2f5122da8f1587e2c38bb4690e830ac2">__wrap_strdup</a> (const char *str)</td></tr>
<tr class="separator:a2f5122da8f1587e2c38bb4690e830ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980febd3b9a673e6f08ace31e4c60a19"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a980febd3b9a673e6f08ace31e4c60a19">dr_mutex_create</a> (void)</td></tr>
<tr class="separator:a980febd3b9a673e6f08ace31e4c60a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cde6ad421a8cb78ba57c5adb90ff3a9"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8cde6ad421a8cb78ba57c5adb90ff3a9">dr_mutex_destroy</a> (void *mutex)</td></tr>
<tr class="separator:a8cde6ad421a8cb78ba57c5adb90ff3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fc5f3252b660fec2538ba2d776ee30"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad6fc5f3252b660fec2538ba2d776ee30">dr_mutex_lock</a> (void *mutex)</td></tr>
<tr class="separator:ad6fc5f3252b660fec2538ba2d776ee30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152f688d562d4cae18ad5790d8f6c4f6"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a152f688d562d4cae18ad5790d8f6c4f6">dr_mutex_unlock</a> (void *mutex)</td></tr>
<tr class="separator:a152f688d562d4cae18ad5790d8f6c4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad083ece79f41caa34120d85c82540e7e"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad083ece79f41caa34120d85c82540e7e">dr_mutex_trylock</a> (void *mutex)</td></tr>
<tr class="separator:ad083ece79f41caa34120d85c82540e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2f7a49ae4f18a0b1967f962440b914"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aba2f7a49ae4f18a0b1967f962440b914">dr_mutex_self_owns</a> (void *mutex)</td></tr>
<tr class="separator:aba2f7a49ae4f18a0b1967f962440b914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8877efdba9869ab5b8b3b4169c9bc0ce"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8877efdba9869ab5b8b3b4169c9bc0ce">dr_mutex_mark_as_app</a> (void *mutex)</td></tr>
<tr class="separator:a8877efdba9869ab5b8b3b4169c9bc0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c352ae7d61d62b2ebd13174e2f50bd"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a25c352ae7d61d62b2ebd13174e2f50bd">dr_rwlock_create</a> (void)</td></tr>
<tr class="separator:a25c352ae7d61d62b2ebd13174e2f50bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2165aca91ac2de155d98c709436819f"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad2165aca91ac2de155d98c709436819f">dr_rwlock_destroy</a> (void *rwlock)</td></tr>
<tr class="separator:ad2165aca91ac2de155d98c709436819f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1e9b10eb1f5ef4c6f47940bb48ff15"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#acb1e9b10eb1f5ef4c6f47940bb48ff15">dr_rwlock_read_lock</a> (void *rwlock)</td></tr>
<tr class="separator:acb1e9b10eb1f5ef4c6f47940bb48ff15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa537f5e2153f2ecb20e96bff9d7f0027"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa537f5e2153f2ecb20e96bff9d7f0027">dr_rwlock_read_unlock</a> (void *rwlock)</td></tr>
<tr class="separator:aa537f5e2153f2ecb20e96bff9d7f0027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453d03325d2d6b8bec94e53b5c69c03c"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a453d03325d2d6b8bec94e53b5c69c03c">dr_rwlock_write_lock</a> (void *rwlock)</td></tr>
<tr class="separator:a453d03325d2d6b8bec94e53b5c69c03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819a63fb829fb0fc74a4041965e50079"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a819a63fb829fb0fc74a4041965e50079">dr_rwlock_write_unlock</a> (void *rwlock)</td></tr>
<tr class="separator:a819a63fb829fb0fc74a4041965e50079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfc6f62eaf08a4dbe805206cb51e48e"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aabfc6f62eaf08a4dbe805206cb51e48e">dr_rwlock_write_trylock</a> (void *rwlock)</td></tr>
<tr class="separator:aabfc6f62eaf08a4dbe805206cb51e48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f3399a345c699db539b9dd7a605aaa"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a89f3399a345c699db539b9dd7a605aaa">dr_rwlock_self_owns_write_lock</a> (void *rwlock)</td></tr>
<tr class="separator:a89f3399a345c699db539b9dd7a605aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c95bd55446ba4232ca591233200f275"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2c95bd55446ba4232ca591233200f275">dr_rwlock_mark_as_app</a> (void *rwlock)</td></tr>
<tr class="separator:a2c95bd55446ba4232ca591233200f275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7456664ac3877b03bc5bffbf4306defe"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7456664ac3877b03bc5bffbf4306defe">dr_recurlock_create</a> (void)</td></tr>
<tr class="separator:a7456664ac3877b03bc5bffbf4306defe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4d574fe9cd0bc7ee374e6f5af79b05"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aea4d574fe9cd0bc7ee374e6f5af79b05">dr_recurlock_destroy</a> (void *reclock)</td></tr>
<tr class="separator:aea4d574fe9cd0bc7ee374e6f5af79b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae684e67432a0c4c28c906d00eea8b4a7"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae684e67432a0c4c28c906d00eea8b4a7">dr_recurlock_lock</a> (void *reclock)</td></tr>
<tr class="separator:ae684e67432a0c4c28c906d00eea8b4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659d0f08d07d8b969d8f6c998be24848"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a659d0f08d07d8b969d8f6c998be24848">dr_app_recurlock_lock</a> (void *reclock, <a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *mc)</td></tr>
<tr class="separator:a659d0f08d07d8b969d8f6c998be24848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07e3d46607424a51065f6e8fb08e60d"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac07e3d46607424a51065f6e8fb08e60d">dr_recurlock_unlock</a> (void *reclock)</td></tr>
<tr class="separator:ac07e3d46607424a51065f6e8fb08e60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef68229d49e8527f794de2ee8d9095e"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9ef68229d49e8527f794de2ee8d9095e">dr_recurlock_trylock</a> (void *reclock)</td></tr>
<tr class="separator:a9ef68229d49e8527f794de2ee8d9095e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab3068aa33b43aa0b8ba555d72cc6fd"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7ab3068aa33b43aa0b8ba555d72cc6fd">dr_recurlock_self_owns</a> (void *reclock)</td></tr>
<tr class="separator:a7ab3068aa33b43aa0b8ba555d72cc6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5e7b4ab67d258d69d860c18e937468"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9f5e7b4ab67d258d69d860c18e937468">dr_recurlock_mark_as_app</a> (void *reclock)</td></tr>
<tr class="separator:a9f5e7b4ab67d258d69d860c18e937468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae450459bac13aece28ef7b00438339d1"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae450459bac13aece28ef7b00438339d1">dr_event_create</a> (void)</td></tr>
<tr class="separator:ae450459bac13aece28ef7b00438339d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4f9d413cf4c6b6aedc83880b5b80d6"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8f4f9d413cf4c6b6aedc83880b5b80d6">dr_event_destroy</a> (void *event)</td></tr>
<tr class="separator:a8f4f9d413cf4c6b6aedc83880b5b80d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5fadf6f5c125e1758ba64e9914913a"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2d5fadf6f5c125e1758ba64e9914913a">dr_event_wait</a> (void *event)</td></tr>
<tr class="separator:a2d5fadf6f5c125e1758ba64e9914913a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477e5120f49129fdc09a62051c4eba93"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a477e5120f49129fdc09a62051c4eba93">dr_event_signal</a> (void *event)</td></tr>
<tr class="separator:a477e5120f49129fdc09a62051c4eba93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbc013e6cebabb2048eccd2f219026a"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aafbc013e6cebabb2048eccd2f219026a">dr_event_reset</a> (void *event)</td></tr>
<tr class="separator:aafbc013e6cebabb2048eccd2f219026a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63ccc4dc3cd6bec00c673eb73206808"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac63ccc4dc3cd6bec00c673eb73206808">dr_mark_safe_to_suspend</a> (void *drcontext, bool enter)</td></tr>
<tr class="separator:ac63ccc4dc3cd6bec00c673eb73206808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0335f768c0ae053da44fd3f5886ac96c"><td class="memItemLeft" align="right" valign="top">DR_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0335f768c0ae053da44fd3f5886ac96c">dr_atomic_add32_return_sum</a> (volatile int *dest, int val)</td></tr>
<tr class="separator:a0335f768c0ae053da44fd3f5886ac96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6e3a2c6b51b4d57a18601f840cc9de"><td class="memItemLeft" align="right" valign="top">DR_API int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4a6e3a2c6b51b4d57a18601f840cc9de">dr_atomic_add64_return_sum</a> (volatile int64 *dest, int64 val)</td></tr>
<tr class="separator:a4a6e3a2c6b51b4d57a18601f840cc9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8d7a30d057679d5e791fb94a8910f7"><td class="memItemLeft" align="right" valign="top">DR_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aed8d7a30d057679d5e791fb94a8910f7">dr_atomic_load32</a> (volatile int *src)</td></tr>
<tr class="separator:aed8d7a30d057679d5e791fb94a8910f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f172d289258a22d037bd2ee57aed9c"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad1f172d289258a22d037bd2ee57aed9c">dr_atomic_store32</a> (volatile int *dest, int val)</td></tr>
<tr class="separator:ad1f172d289258a22d037bd2ee57aed9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdbd3905a8b32ce1386d7de86b396c4"><td class="memItemLeft" align="right" valign="top">DR_API int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afcdbd3905a8b32ce1386d7de86b396c4">dr_atomic_load64</a> (volatile int64 *src)</td></tr>
<tr class="separator:afcdbd3905a8b32ce1386d7de86b396c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2752c8a9f9637159c83819285ca4cc40"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2752c8a9f9637159c83819285ca4cc40">dr_atomic_store64</a> (volatile int64 *dest, int64 val)</td></tr>
<tr class="separator:a2752c8a9f9637159c83819285ca4cc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192497da7670d454f6aae17d293f70b4"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a192497da7670d454f6aae17d293f70b4">dr_map_executable_file</a> (const char *filename, <a class="el" href="dr__tools_8h.html#ade307e7bb7b7ac46e874097fe62b9fef">dr_map_executable_flags_t</a> flags, size_t *size OUT)</td></tr>
<tr class="separator:a192497da7670d454f6aae17d293f70b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d306d881c59488dd6ae41f392074af"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a01d306d881c59488dd6ae41f392074af">dr_unmap_executable_file</a> (byte *base, size_t size)</td></tr>
<tr class="separator:a01d306d881c59488dd6ae41f392074af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3912ab20d9a86a19627f3634a3a2f3d"><td class="memItemLeft" align="right" valign="top">DR_API reg_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae3912ab20d9a86a19627f3634a3a2f3d">dr_syscall_get_param</a> (void *drcontext, int param_num)</td></tr>
<tr class="separator:ae3912ab20d9a86a19627f3634a3a2f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba5b83fedf0082d4170c3caaf2224a9"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2ba5b83fedf0082d4170c3caaf2224a9">dr_syscall_set_param</a> (void *drcontext, int param_num, reg_t new_value)</td></tr>
<tr class="separator:a2ba5b83fedf0082d4170c3caaf2224a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f09772f0185557445cb46647268fa8"><td class="memItemLeft" align="right" valign="top">DR_API reg_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a16f09772f0185557445cb46647268fa8">dr_syscall_get_result</a> (void *drcontext)</td></tr>
<tr class="separator:a16f09772f0185557445cb46647268fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2906dcd1979be92605bdf3c58c9f373"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad2906dcd1979be92605bdf3c58c9f373">dr_syscall_get_result_ex</a> (void *drcontext, <a class="el" href="dr__tools_8h.html#afc574aa98b0e727a9b75059c4966eb10">dr_syscall_result_info_t</a> *info INOUT)</td></tr>
<tr class="separator:ad2906dcd1979be92605bdf3c58c9f373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d20c65a63ebb1a2081b3152d9d4647d"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2d20c65a63ebb1a2081b3152d9d4647d">dr_syscall_set_result</a> (void *drcontext, reg_t value)</td></tr>
<tr class="separator:a2d20c65a63ebb1a2081b3152d9d4647d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70710f3b42a9797a72ffb51f46720849"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a70710f3b42a9797a72ffb51f46720849">dr_syscall_set_result_ex</a> (void *drcontext, <a class="el" href="dr__tools_8h.html#afc574aa98b0e727a9b75059c4966eb10">dr_syscall_result_info_t</a> *info)</td></tr>
<tr class="separator:a70710f3b42a9797a72ffb51f46720849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66c42a269f48b13ed57609029e5202b"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae66c42a269f48b13ed57609029e5202b">dr_syscall_set_sysnum</a> (void *drcontext, int new_num)</td></tr>
<tr class="separator:ae66c42a269f48b13ed57609029e5202b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb494e753b1a2f0e79cb4bd09700c3c"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aedb494e753b1a2f0e79cb4bd09700c3c">dr_syscall_invoke_another</a> (void *drcontext)</td></tr>
<tr class="separator:aedb494e753b1a2f0e79cb4bd09700c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582dafe48f9bb894d23ba274913014fb"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a582dafe48f9bb894d23ba274913014fb">dr_syscall_intercept_natively</a> (const char *name, int sysnum, int num_args, int wow64_index)</td></tr>
<tr class="separator:a582dafe48f9bb894d23ba274913014fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0317a4764f0d04b5510fcfd418131a4c"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0317a4764f0d04b5510fcfd418131a4c">dr_create_dir</a> (const char *fname)</td></tr>
<tr class="separator:a0317a4764f0d04b5510fcfd418131a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b23d88adc4536bc69c771999fde3d2"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a43b23d88adc4536bc69c771999fde3d2">dr_delete_dir</a> (const char *fname)</td></tr>
<tr class="separator:a43b23d88adc4536bc69c771999fde3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a677a98692a1f11b4f5b0270cf0912"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac3a677a98692a1f11b4f5b0270cf0912">dr_get_current_directory</a> (char *buf, size_t bufsz)</td></tr>
<tr class="separator:ac3a677a98692a1f11b4f5b0270cf0912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a0a8c4e06776d42bac20ac26c0632d"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab3a0a8c4e06776d42bac20ac26c0632d">dr_directory_exists</a> (const char *fname)</td></tr>
<tr class="separator:ab3a0a8c4e06776d42bac20ac26c0632d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe870f8dd183281593eb10199ec453c2"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afe870f8dd183281593eb10199ec453c2">dr_file_exists</a> (const char *fname)</td></tr>
<tr class="separator:afe870f8dd183281593eb10199ec453c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1399687e4cbc3c0b9bddab3e7619d3"><td class="memItemLeft" align="right" valign="top">DR_API file_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8c1399687e4cbc3c0b9bddab3e7619d3">dr_open_file</a> (const char *fname, uint mode_flags)</td></tr>
<tr class="separator:a8c1399687e4cbc3c0b9bddab3e7619d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9ce8187cd9bff18c879978a9ab1b8a"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2f9ce8187cd9bff18c879978a9ab1b8a">dr_close_file</a> (file_t f)</td></tr>
<tr class="separator:a2f9ce8187cd9bff18c879978a9ab1b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbb2913daa5c083cf9881b5d500513e"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afdbb2913daa5c083cf9881b5d500513e">dr_rename_file</a> (const char *src, const char *dst, bool replace)</td></tr>
<tr class="separator:afdbb2913daa5c083cf9881b5d500513e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518ec4d2f8bb8ab51782c14ba0be2fd3"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a518ec4d2f8bb8ab51782c14ba0be2fd3">dr_delete_file</a> (const char *filename)</td></tr>
<tr class="separator:a518ec4d2f8bb8ab51782c14ba0be2fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02172538d802277fdbeb215b3849f968"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a02172538d802277fdbeb215b3849f968">dr_flush_file</a> (file_t f)</td></tr>
<tr class="separator:a02172538d802277fdbeb215b3849f968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451ff3e57783acbfdf24c1e557145807"><td class="memItemLeft" align="right" valign="top">DR_API ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a451ff3e57783acbfdf24c1e557145807">dr_write_file</a> (file_t f, const void *buf, size_t count)</td></tr>
<tr class="separator:a451ff3e57783acbfdf24c1e557145807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9600abc55b7ed7e283e6d8a9dee1ecc"><td class="memItemLeft" align="right" valign="top">DR_API ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac9600abc55b7ed7e283e6d8a9dee1ecc">dr_read_file</a> (file_t f, void *buf, size_t count)</td></tr>
<tr class="separator:ac9600abc55b7ed7e283e6d8a9dee1ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd936c82cd8b9054a3336598b0343ed"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5fd936c82cd8b9054a3336598b0343ed">dr_file_seek</a> (file_t f, int64 offset, int origin)</td></tr>
<tr class="separator:a5fd936c82cd8b9054a3336598b0343ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb97885112fe6fdad5a983342545643"><td class="memItemLeft" align="right" valign="top">DR_API int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0eb97885112fe6fdad5a983342545643">dr_file_tell</a> (file_t f)</td></tr>
<tr class="separator:a0eb97885112fe6fdad5a983342545643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ac1cc05cf53faed156aa6c16a18d93"><td class="memItemLeft" align="right" valign="top">DR_API file_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a08ac1cc05cf53faed156aa6c16a18d93">dr_dup_file_handle</a> (file_t f)</td></tr>
<tr class="separator:a08ac1cc05cf53faed156aa6c16a18d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ee1db27b9b527a5488314d12782700"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a34ee1db27b9b527a5488314d12782700">dr_file_size</a> (file_t fd, OUT uint64 *size)</td></tr>
<tr class="separator:a34ee1db27b9b527a5488314d12782700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2885193f264131c620475894e3d1e1e"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac2885193f264131c620475894e3d1e1e">dr_map_file</a> (file_t f, INOUT size_t *size, uint64 offs, app_pc addr, uint prot, uint flags)</td></tr>
<tr class="separator:ac2885193f264131c620475894e3d1e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b63ba5945657da579f044daa01ba035"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3b63ba5945657da579f044daa01ba035">dr_unmap_file</a> (void *map, size_t size)</td></tr>
<tr class="separator:a3b63ba5945657da579f044daa01ba035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea154f7dd2f1232aaba2e92d0a5cb24"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aeea154f7dd2f1232aaba2e92d0a5cb24">dr_log</a> (void *drcontext, uint mask, uint level, const char *fmt,...)</td></tr>
<tr class="separator:aeea154f7dd2f1232aaba2e92d0a5cb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96a2deefd61c7308a9beb3a82023603"><td class="memItemLeft" align="right" valign="top">DR_API file_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa96a2deefd61c7308a9beb3a82023603">dr_get_logfile</a> (void *drcontext)</td></tr>
<tr class="separator:aa96a2deefd61c7308a9beb3a82023603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2868b3eac7b652ffa561f3f4d15a6c0"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae2868b3eac7b652ffa561f3f4d15a6c0">dr_is_notify_on</a> (void)</td></tr>
<tr class="separator:ae2868b3eac7b652ffa561f3f4d15a6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b96f569a13ecfd30305cbec82af580"><td class="memItemLeft" align="right" valign="top">DR_API file_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a24b96f569a13ecfd30305cbec82af580">dr_get_stdout_file</a> (void)</td></tr>
<tr class="separator:a24b96f569a13ecfd30305cbec82af580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affce3c79aafa38a4fc00ac083ac9a55a"><td class="memItemLeft" align="right" valign="top">DR_API file_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#affce3c79aafa38a4fc00ac083ac9a55a">dr_get_stderr_file</a> (void)</td></tr>
<tr class="separator:affce3c79aafa38a4fc00ac083ac9a55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf64b8dc334709ed00623248fcae3c73"><td class="memItemLeft" align="right" valign="top">DR_API file_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#adf64b8dc334709ed00623248fcae3c73">dr_get_stdin_file</a> (void)</td></tr>
<tr class="separator:adf64b8dc334709ed00623248fcae3c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52f61049269c0531b66b8c41c69e09e"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae52f61049269c0531b66b8c41c69e09e">dr_messagebox</a> (const char *fmt,...)</td></tr>
<tr class="separator:ae52f61049269c0531b66b8c41c69e09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb88b22ff95c29ae793b9d84e1b95275"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aeb88b22ff95c29ae793b9d84e1b95275">dr_printf</a> (const char *fmt,...)</td></tr>
<tr class="separator:aeb88b22ff95c29ae793b9d84e1b95275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae338685a241cfeae5f3d507ae9cff957"><td class="memItemLeft" align="right" valign="top">DR_API ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae338685a241cfeae5f3d507ae9cff957">dr_fprintf</a> (file_t f, const char *fmt,...)</td></tr>
<tr class="separator:ae338685a241cfeae5f3d507ae9cff957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c794ef952f9163ac3c4927aa859dbf"><td class="memItemLeft" align="right" valign="top">DR_API ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad8c794ef952f9163ac3c4927aa859dbf">dr_vfprintf</a> (file_t f, const char *fmt, va_list ap)</td></tr>
<tr class="separator:ad8c794ef952f9163ac3c4927aa859dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab870ad4d34833368e16bd3f6e07ba624"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab870ad4d34833368e16bd3f6e07ba624">dr_enable_console_printing</a> (void)</td></tr>
<tr class="separator:ab870ad4d34833368e16bd3f6e07ba624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab4b37f37e4ee13e5cbcc999edc561e"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4ab4b37f37e4ee13e5cbcc999edc561e">dr_using_console</a> (void)</td></tr>
<tr class="separator:a4ab4b37f37e4ee13e5cbcc999edc561e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fe87f7bf9560a45751064329bc8c12"><td class="memItemLeft" align="right" valign="top">DR_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a07fe87f7bf9560a45751064329bc8c12">dr_snprintf</a> (char *buf, size_t max, const char *fmt,...)</td></tr>
<tr class="separator:a07fe87f7bf9560a45751064329bc8c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dca11e2920892d292405c49695d4890"><td class="memItemLeft" align="right" valign="top">DR_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a6dca11e2920892d292405c49695d4890">dr_snwprintf</a> (wchar_t *buf, size_t max, const wchar_t *fmt,...)</td></tr>
<tr class="separator:a6dca11e2920892d292405c49695d4890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af763a8387187c98cf359f9819f300833"><td class="memItemLeft" align="right" valign="top">DR_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af763a8387187c98cf359f9819f300833">dr_vsnprintf</a> (char *buf, size_t max, const char *fmt, va_list ap)</td></tr>
<tr class="separator:af763a8387187c98cf359f9819f300833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81096100c4202f0ea841bb24667cabc7"><td class="memItemLeft" align="right" valign="top">DR_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a81096100c4202f0ea841bb24667cabc7">dr_vsnwprintf</a> (wchar_t *buf, size_t max, const wchar_t *fmt, va_list ap)</td></tr>
<tr class="separator:a81096100c4202f0ea841bb24667cabc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb0b327ed9babc47922984b7adfed8b"><td class="memItemLeft" align="right" valign="top">DR_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#accb0b327ed9babc47922984b7adfed8b">dr_sscanf</a> (const char *str, const char *fmt,...)</td></tr>
<tr class="separator:accb0b327ed9babc47922984b7adfed8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4510e709f5b5285eaeb3435f1d42c544"><td class="memItemLeft" align="right" valign="top">const DR_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4510e709f5b5285eaeb3435f1d42c544">dr_get_token</a> (const char *str, char *buf, size_t buflen)</td></tr>
<tr class="separator:a4510e709f5b5285eaeb3435f1d42c544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca7cdf4ffb25d5bb8099dbf69290824"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5ca7cdf4ffb25d5bb8099dbf69290824">dr_print_instr</a> (void *drcontext, file_t f, <a class="el" href="structinstr__t.html">instr_t</a> *instr, const char *msg)</td></tr>
<tr class="separator:a5ca7cdf4ffb25d5bb8099dbf69290824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d96533bfee81c79dfd508be5e524b48"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3d96533bfee81c79dfd508be5e524b48">dr_print_opnd</a> (void *drcontext, file_t f, <a class="el" href="structopnd__t.html">opnd_t</a> opnd, const char *msg)</td></tr>
<tr class="separator:a3d96533bfee81c79dfd508be5e524b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317a1bb4c01ab9e6e64d2644d0ea984c"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a317a1bb4c01ab9e6e64d2644d0ea984c">dr_get_current_drcontext</a> (void)</td></tr>
<tr class="separator:a317a1bb4c01ab9e6e64d2644d0ea984c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56eae1c5bac30a5336a99c5d91d5a10c"><td class="memItemLeft" align="right" valign="top">DR_API thread_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a56eae1c5bac30a5336a99c5d91d5a10c">dr_get_thread_id</a> (void *drcontext)</td></tr>
<tr class="separator:a56eae1c5bac30a5336a99c5d91d5a10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42f2c7b95786297e1b45b6de81e257d"><td class="memItemLeft" align="right" valign="top">DR_API HANDLE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad42f2c7b95786297e1b45b6de81e257d">dr_get_dr_thread_handle</a> (void *drcontext)</td></tr>
<tr class="separator:ad42f2c7b95786297e1b45b6de81e257d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa04a14c2cbf783b4926c2fd14445f82"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aaa04a14c2cbf783b4926c2fd14445f82">dr_get_tls_field</a> (void *drcontext)</td></tr>
<tr class="separator:aaa04a14c2cbf783b4926c2fd14445f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534b38808801da50be64b9f0e6c8616f"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a534b38808801da50be64b9f0e6c8616f">dr_set_tls_field</a> (void *drcontext, void *value)</td></tr>
<tr class="separator:a534b38808801da50be64b9f0e6c8616f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d91064ffa84c097c84694d78a2ad22"><td class="memItemLeft" align="right" valign="top">DR_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a88d91064ffa84c097c84694d78a2ad22">dr_get_dr_segment_base</a> (IN <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> tls_register)</td></tr>
<tr class="separator:a88d91064ffa84c097c84694d78a2ad22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d2a2ccd58268f84c379a38bc4aa399"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac5d2a2ccd58268f84c379a38bc4aa399">dr_raw_tls_calloc</a> (OUT <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> *tls_register, OUT uint *offset, IN uint num_slots, IN uint alignment)</td></tr>
<tr class="separator:ac5d2a2ccd58268f84c379a38bc4aa399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2162f0dbd52d784c1fbfe8ac75cf6ec"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad2162f0dbd52d784c1fbfe8ac75cf6ec">dr_raw_tls_cfree</a> (uint offset, uint num_slots)</td></tr>
<tr class="separator:ad2162f0dbd52d784c1fbfe8ac75cf6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8cdf29035914846c03c4409a3f8fcf"><td class="memItemLeft" align="right" valign="top">DR_API <a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a6b8cdf29035914846c03c4409a3f8fcf">dr_raw_tls_opnd</a> (void *drcontext, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> tls_register, uint tls_offs)</td></tr>
<tr class="separator:a6b8cdf29035914846c03c4409a3f8fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75586a7501d994aa4bbd70519b726c0c"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a75586a7501d994aa4bbd70519b726c0c">dr_insert_read_raw_tls</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> tls_register, uint tls_offs, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:a75586a7501d994aa4bbd70519b726c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802140e02e8ea041cd7ec793160d731f"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a802140e02e8ea041cd7ec793160d731f">dr_insert_write_raw_tls</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> tls_register, uint tls_offs, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:a802140e02e8ea041cd7ec793160d731f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9bc4918a9b5facc7f44cf6a9e8bdca"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aca9bc4918a9b5facc7f44cf6a9e8bdca">dr_create_client_thread</a> (void(*func)(void *param), void *arg)</td></tr>
<tr class="separator:aca9bc4918a9b5facc7f44cf6a9e8bdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52661f5c59ab6478f72e8f6774796188"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a52661f5c59ab6478f72e8f6774796188">dr_client_thread_set_suspendable</a> (bool suspendable)</td></tr>
<tr class="separator:a52661f5c59ab6478f72e8f6774796188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac428021a331be838eca5a0ef19989bd"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aac428021a331be838eca5a0ef19989bd">dr_sleep</a> (int time_ms)</td></tr>
<tr class="separator:aac428021a331be838eca5a0ef19989bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100ea691259a4eff5419e7b34245703d"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a100ea691259a4eff5419e7b34245703d">dr_thread_yield</a> (void)</td></tr>
<tr class="separator:a100ea691259a4eff5419e7b34245703d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566d8b7214afc621019c8f0048a094b0"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a566d8b7214afc621019c8f0048a094b0">dr_suspend_all_other_threads_ex</a> (OUT void ***drcontexts, OUT uint *num_suspended, OUT uint *num_unsuspended, <a class="el" href="dr__tools_8h.html#a66bef18f8eabc7a8b8b0368e8a96d179">dr_suspend_flags_t</a> flags)</td></tr>
<tr class="separator:a566d8b7214afc621019c8f0048a094b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4eaefda11c27210a72df6d24f72871f"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae4eaefda11c27210a72df6d24f72871f">dr_suspend_all_other_threads</a> (OUT void ***drcontexts, OUT uint *num_suspended, OUT uint *num_unsuspended)</td></tr>
<tr class="separator:ae4eaefda11c27210a72df6d24f72871f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5842900d62c160ea7f0e99c0eee77bb0"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5842900d62c160ea7f0e99c0eee77bb0">dr_resume_all_other_threads</a> (IN void **drcontexts, IN uint num_suspended)</td></tr>
<tr class="separator:a5842900d62c160ea7f0e99c0eee77bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f0ea543a114210feefc521b132d69b"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a12f0ea543a114210feefc521b132d69b">dr_is_thread_native</a> (void *drcontext)</td></tr>
<tr class="separator:a12f0ea543a114210feefc521b132d69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e371d4c7d897bf24c8a558b86a4c69"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a69e371d4c7d897bf24c8a558b86a4c69">dr_retakeover_suspended_native_thread</a> (void *drcontext)</td></tr>
<tr class="separator:a69e371d4c7d897bf24c8a558b86a4c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74de1da117d9c807b986aeda2523dd9"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac74de1da117d9c807b986aeda2523dd9">dr_set_itimer</a> (int which, uint millisec, void(*func)(void *drcontext, <a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *mcontext))</td></tr>
<tr class="separator:ac74de1da117d9c807b986aeda2523dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2f1d0559603dc203351d9b8da0e216"><td class="memItemLeft" align="right" valign="top">DR_API uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5d2f1d0559603dc203351d9b8da0e216">dr_get_itimer</a> (int which)</td></tr>
<tr class="separator:a5d2f1d0559603dc203351d9b8da0e216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac922731194013612e4f4cb78075a2170"><td class="memItemLeft" align="right" valign="top">DR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac922731194013612e4f4cb78075a2170">dr_track_where_am_i</a> (void)</td></tr>
<tr class="separator:ac922731194013612e4f4cb78075a2170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab185c8efca620f8cd0e323164afbc935"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab185c8efca620f8cd0e323164afbc935">dr_is_tracking_where_am_i</a> (void)</td></tr>
<tr class="separator:ab185c8efca620f8cd0e323164afbc935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9333e0dee46cc854228efab156ce98c5"><td class="memItemLeft" align="right" valign="top">DR_API <a class="el" href="dr__defines_8h.html#a145cc4ecf7cf2041207f0382d50f9620">dr_where_am_i_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9333e0dee46cc854228efab156ce98c5">dr_where_am_i</a> (void *drcontext, app_pc pc, OUT void **tag)</td></tr>
<tr class="separator:a9333e0dee46cc854228efab156ce98c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c602c9d795079655bc599550cb4492b"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3c602c9d795079655bc599550cb4492b">dr_replace_fragment</a> (void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist)</td></tr>
<tr class="separator:a3c602c9d795079655bc599550cb4492b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e5ee30d5f4226445ce589f5b41b720"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a65e5ee30d5f4226445ce589f5b41b720">dr_delete_fragment</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:a65e5ee30d5f4226445ce589f5b41b720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d4ad288807e3c033ab54013d8a49a4"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa9d4ad288807e3c033ab54013d8a49a4">dr_flush_region_ex</a> (app_pc start, size_t size, void(*flush_completion_callback)(void *user_data), void *user_data)</td></tr>
<tr class="separator:aa9d4ad288807e3c033ab54013d8a49a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b02f80af80dcd6005bf6c70ae7e7ad7"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5b02f80af80dcd6005bf6c70ae7e7ad7">dr_flush_region</a> (app_pc start, size_t size)</td></tr>
<tr class="separator:a5b02f80af80dcd6005bf6c70ae7e7ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57669d0e147191660153b928eca7f09b"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a57669d0e147191660153b928eca7f09b">dr_unlink_flush_region</a> (app_pc start, size_t size)</td></tr>
<tr class="separator:a57669d0e147191660153b928eca7f09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3f791ec0b8edddf607612c6804709f"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9a3f791ec0b8edddf607612c6804709f">dr_delay_flush_region</a> (app_pc start, size_t size, uint flush_id, void(*flush_completion_callback)(int flush_id))</td></tr>
<tr class="separator:a9a3f791ec0b8edddf607612c6804709f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd17c746673622a416b007c3f50e073"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2bd17c746673622a416b007c3f50e073">dr_fragment_exists_at</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:a2bd17c746673622a416b007c3f50e073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d274f12fa95b0534070f2efc654472"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad0d274f12fa95b0534070f2efc654472">dr_bb_exists_at</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:ad0d274f12fa95b0534070f2efc654472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7b59a456b61adffaa9f0f35d41bb6"><td class="memItemLeft" align="right" valign="top">DR_API uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a33a7b59a456b61adffaa9f0f35d41bb6">dr_fragment_size</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:a33a7b59a456b61adffaa9f0f35d41bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d16222754e0f831ef5700a67fcc3fb"><td class="memItemLeft" align="right" valign="top">DR_API app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a84d16222754e0f831ef5700a67fcc3fb">dr_fragment_app_pc</a> (void *tag)</td></tr>
<tr class="separator:a84d16222754e0f831ef5700a67fcc3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f233285fe626838c3f61aac27a92050"><td class="memItemLeft" align="right" valign="top">DR_API app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3f233285fe626838c3f61aac27a92050">dr_app_pc_for_decoding</a> (app_pc pc)</td></tr>
<tr class="separator:a3f233285fe626838c3f61aac27a92050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a1bd0254f72ed1d70307c26d26daca"><td class="memItemLeft" align="right" valign="top">DR_API app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a65a1bd0254f72ed1d70307c26d26daca">dr_app_pc_from_cache_pc</a> (byte *cache_pc)</td></tr>
<tr class="separator:a65a1bd0254f72ed1d70307c26d26daca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554c5441ac5a4e4de19210562ad8ab90"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a554c5441ac5a4e4de19210562ad8ab90">dr_prepopulate_cache</a> (app_pc *tags, size_t tags_count)</td></tr>
<tr class="separator:a554c5441ac5a4e4de19210562ad8ab90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a98f51f66512fcf4611e3b5de68032"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a25a98f51f66512fcf4611e3b5de68032">dr_prepopulate_indirect_targets</a> (<a class="el" href="dr__tools_8h.html#a3d99790cec275b8bad73c09b68279911">dr_indirect_branch_type_t</a> branch_type, app_pc *tags, size_t tags_count)</td></tr>
<tr class="separator:a25a98f51f66512fcf4611e3b5de68032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0436b08f1b548fd783b390dd0e740eef"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0436b08f1b548fd783b390dd0e740eef">dr_get_stats</a> (<a class="el" href="dr__defines_8h.html#a213f155f07a830b79111449062545352">dr_stats_t</a> *drstats)</td></tr>
<tr class="separator:a0436b08f1b548fd783b390dd0e740eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15aa23aae4a1d322fbe0a1cffedbaf3a"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a15aa23aae4a1d322fbe0a1cffedbaf3a">dr_mark_trace_head</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:a15aa23aae4a1d322fbe0a1cffedbaf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74baccca7b783c29e11fe63c286c26a"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab74baccca7b783c29e11fe63c286c26a">dr_trace_head_at</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:ab74baccca7b783c29e11fe63c286c26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad390db9aee211b90323f5b06bda2e489"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad390db9aee211b90323f5b06bda2e489">dr_trace_exists_at</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:ad390db9aee211b90323f5b06bda2e489"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main API routines, including transparency support. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a7c07630dffdfd92bc6ee63abf405768c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c07630dffdfd92bc6ee63abf405768c">&#9670;&nbsp;</a></span>DR_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#abd6d066ab9bdd578d4000e80df8503bc">DR_ASSERT_MSG</a>(x, &quot;&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code>x</code> is false, displays a message about an assertion failure and then calls <a class="el" href="dr__tools_8h.html#a0f1fe81ae1737aa0e34eb69c855d359c">dr_abort()</a> </p>

</div>
</div>
<a id="abd6d066ab9bdd578d4000e80df8503bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6d066ab9bdd578d4000e80df8503bc">&#9670;&nbsp;</a></span>DR_ASSERT_MSG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_ASSERT_MSG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        ((void)((!(x)) ? (<a class="code" href="dr__tools_8h.html#ae52f61049269c0531b66b8c41c69e09e">dr_messagebox</a>(<span class="stringliteral">&quot;ASSERT FAILURE: %s:%d: %s (%s)&quot;</span>, __FILE__, \</div>
<div class="line">                                        __LINE__, #x, msg),                         \</div>
<div class="line">                          dr_abort(), 0)                                            \</div>
<div class="line">                       : 0))</div>
</div><!-- fragment --><p>If <code>x</code> is false, displays a message about an assertion failure (appending <code>msg</code> to the message) and then calls <a class="el" href="dr__tools_8h.html#a0f1fe81ae1737aa0e34eb69c855d359c">dr_abort()</a> </p>

</div>
</div>
<a id="a77a3b276c8d9a62bf6d78c3707d4effd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a3b276c8d9a62bf6d78c3707d4effd">&#9670;&nbsp;</a></span>DR_FILE_ALLOW_LARGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_ALLOW_LARGE&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open with large (&gt;2GB) file support. Only applicable on 32-bit Linux. </p><dl class="section note"><dt>Note</dt><dd>DR's log files and tracedump files are all created with this flag. </dd></dl>

</div>
</div>
<a id="a0401a3003f578602bf31a984a4d5419d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0401a3003f578602bf31a984a4d5419d">&#9670;&nbsp;</a></span>DR_FILE_CLOSE_ON_FORK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_CLOSE_ON_FORK&#160;&#160;&#160;0x20</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Linux-only. This file will be closed in the child of a fork. </p>

</div>
</div>
<a id="ad0772bc47090cec1a333baf1259f226d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0772bc47090cec1a333baf1259f226d">&#9670;&nbsp;</a></span>DR_FILE_READ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_READ&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open with read access. </p>

</div>
</div>
<a id="ac989ab040f48c4c91cc3a6ea63f9ec1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac989ab040f48c4c91cc3a6ea63f9ec1f">&#9670;&nbsp;</a></span>DR_FILE_WRITE_APPEND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_WRITE_APPEND&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open with write access. If the file already exists, set the file position to the end of the file. </p>

</div>
</div>
<a id="ac71a8471b604df56ae2fa05ba66e03be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71a8471b604df56ae2fa05ba66e03be">&#9670;&nbsp;</a></span>DR_FILE_WRITE_ONLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_WRITE_ONLY&#160;&#160;&#160;0x40</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open with write-only access. Meant for use with pipes. Linux-only. Mutually exclusive with DR_FILE_WRITE_REQUIRE_NEW, DR_FILE_WRITE_APPEND, and DR_FILE_WRITE_OVERWRITE. </p>

</div>
</div>
<a id="a5fb30eb2b5d14486b3ecbc2b2457dfdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb30eb2b5d14486b3ecbc2b2457dfdb">&#9670;&nbsp;</a></span>DR_FILE_WRITE_OVERWRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_WRITE_OVERWRITE&#160;&#160;&#160;0x8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open with write access. If the file already exists, truncate the file to zero length. </p>

</div>
</div>
<a id="a11f713faf2e1eac95bc26a98b67e28cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f713faf2e1eac95bc26a98b67e28cc">&#9670;&nbsp;</a></span>DR_FILE_WRITE_REQUIRE_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_WRITE_REQUIRE_NEW&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open with write access, but do not open if the file already exists. </p>

</div>
</div>
<a id="acab56792af6a64911a9e62dfeb8b0981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab56792af6a64911a9e62dfeb8b0981">&#9670;&nbsp;</a></span>DR_LOG_ALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_ALL&#160;&#160;&#160;0x00ffffff</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log all data. </p>

</div>
</div>
<a id="ae2ba7d86027989b56768e2275246182e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ba7d86027989b56768e2275246182e">&#9670;&nbsp;</a></span>DR_LOG_ASYNCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_ASYNCH&#160;&#160;&#160;0x00000010</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to signals/callbacks/etc. </p>

</div>
</div>
<a id="a8714ae07e5f382ab7d989c14c406b935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8714ae07e5f382ab7d989c14c406b935">&#9670;&nbsp;</a></span>DR_LOG_CACHE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_CACHE&#160;&#160;&#160;0x00000100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to code cache management. \ </p>

</div>
</div>
<a id="af2c8a0e03b86826f823a169b40699e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c8a0e03b86826f823a169b40699e4f">&#9670;&nbsp;</a></span>DR_LOG_DISPATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_DISPATCH&#160;&#160;&#160;0x00000400</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data on every context switch dispatch. \ </p>

</div>
</div>
<a id="aea15a10e6af6dd1f03b6967529b776fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea15a10e6af6dd1f03b6967529b776fc">&#9670;&nbsp;</a></span>DR_LOG_EMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_EMIT&#160;&#160;&#160;0x00000040</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to emitting code. </p>

</div>
</div>
<a id="ae6a1fd3e3710f996d26fa1ac8d3fc369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a1fd3e3710f996d26fa1ac8d3fc369">&#9670;&nbsp;</a></span>DR_LOG_FRAGMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_FRAGMENT&#160;&#160;&#160;0x00000200</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to app code fragments. \ </p>

</div>
</div>
<a id="a827401778f0f0f90f445c975c5e2f7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827401778f0f0f90f445c975c5e2f7c4">&#9670;&nbsp;</a></span>DR_LOG_HEAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_HEAP&#160;&#160;&#160;0x00001000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to memory management. </p>

</div>
</div>
<a id="a0ade83ca6b1ca70c099f1cd775ec10ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ade83ca6b1ca70c099f1cd775ec10ca">&#9670;&nbsp;</a></span>DR_LOG_HOT_PATCHING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_HOT_PATCHING&#160;&#160;&#160;0x00200000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to hot patching. </p>

</div>
</div>
<a id="a3b470dff6d385ef7feb2f456356d0f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b470dff6d385ef7feb2f456356d0f2b">&#9670;&nbsp;</a></span>DR_LOG_HTABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_HTABLE&#160;&#160;&#160;0x00400000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to hash tables. </p>

</div>
</div>
<a id="add8cedc710c8c450fd09b6542cd5aadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8cedc710c8c450fd09b6542cd5aadc">&#9670;&nbsp;</a></span>DR_LOG_INTERP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_INTERP&#160;&#160;&#160;0x00000020</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to app interpretation. </p>

</div>
</div>
<a id="a56e0fc2c5c4028f645ab816d0fe06224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e0fc2c5c4028f645ab816d0fe06224">&#9670;&nbsp;</a></span>DR_LOG_LINKS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_LINKS&#160;&#160;&#160;0x00000080</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to linking code. </p>

</div>
</div>
<a id="a52971d4b126b22c760012bdcdba4796e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52971d4b126b22c760012bdcdba4796e">&#9670;&nbsp;</a></span>DR_LOG_MEMSTATS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_MEMSTATS&#160;&#160;&#160;0x00008000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to memory statistics. \ </p>

</div>
</div>
<a id="aa772ad5c6339d52ca27b3da7e64a272d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa772ad5c6339d52ca27b3da7e64a272d">&#9670;&nbsp;</a></span>DR_LOG_MODULEDB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_MODULEDB&#160;&#160;&#160;0x00800000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to the module database. </p>

</div>
</div>
<a id="a5de43f77fcbc908d6ab61f1731db4210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de43f77fcbc908d6ab61f1731db4210">&#9670;&nbsp;</a></span>DR_LOG_MONITOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_MONITOR&#160;&#160;&#160;0x00000800</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to trace building. </p>

</div>
</div>
<a id="a80f9b317b468d5e1e3599f3080db7739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f9b317b468d5e1e3599f3080db7739">&#9670;&nbsp;</a></span>DR_LOG_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_NONE&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log no data. </p>

</div>
</div>
<a id="a8915da4b3e63046309d88e761121e959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8915da4b3e63046309d88e761121e959">&#9670;&nbsp;</a></span>DR_LOG_NT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_NT&#160;&#160;&#160;0x00100000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to Windows Native API. </p>

</div>
</div>
<a id="a31e132f043e5fa8d48d32c8cde6ef51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e132f043e5fa8d48d32c8cde6ef51d">&#9670;&nbsp;</a></span>DR_LOG_OPTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_OPTS&#160;&#160;&#160;0x00010000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to optimizations. </p>

</div>
</div>
<a id="aa5d4f7e0b8756ff97ce6eb4831f53177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d4f7e0b8756ff97ce6eb4831f53177">&#9670;&nbsp;</a></span>DR_LOG_RCT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_RCT&#160;&#160;&#160;0x00080000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to indirect transfers. </p>

</div>
</div>
<a id="a5211b8fe9028d7ffac630d732eaf0614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5211b8fe9028d7ffac630d732eaf0614">&#9670;&nbsp;</a></span>DR_LOG_SIDELINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_SIDELINE&#160;&#160;&#160;0x00020000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to sideline threads. </p>

</div>
</div>
<a id="a1bfc4dffcec6a5f6b5851f81e5f2575e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfc4dffcec6a5f6b5851f81e5f2575e">&#9670;&nbsp;</a></span>DR_LOG_STATS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_STATS&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log per-thread and global statistics. </p>

</div>
</div>
<a id="a4605a61344628bdc31d15abd49a426ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4605a61344628bdc31d15abd49a426ba">&#9670;&nbsp;</a></span>DR_LOG_SYMBOLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_SYMBOLS&#160;&#160;&#160;0x00040000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to app symbols. </p>

</div>
</div>
<a id="acf35bd0a62f41090a4da1caf1f7039a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf35bd0a62f41090a4da1caf1f7039a9">&#9670;&nbsp;</a></span>DR_LOG_SYNCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_SYNCH&#160;&#160;&#160;0x00004000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to synchronization. </p>

</div>
</div>
<a id="a187545302d9056b56df6ea2453e2f92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187545302d9056b56df6ea2453e2f92d">&#9670;&nbsp;</a></span>DR_LOG_SYSCALLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_SYSCALLS&#160;&#160;&#160;0x00000008</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to system calls. </p>

</div>
</div>
<a id="a58660d789f8390d329d24f5bd4ac0800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58660d789f8390d329d24f5bd4ac0800">&#9670;&nbsp;</a></span>DR_LOG_THREADS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_THREADS&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to threads. </p>

</div>
</div>
<a id="aa95a611b85c11e557bd2d541c9ed7d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa95a611b85c11e557bd2d541c9ed7d22">&#9670;&nbsp;</a></span>DR_LOG_TOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_TOP&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log top-level information. </p>

</div>
</div>
<a id="a4fff9a38640df11852f0aa877452c63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fff9a38640df11852f0aa877452c63e">&#9670;&nbsp;</a></span>DR_LOG_VMAREAS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_LOG_VMAREAS&#160;&#160;&#160;0x00002000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to address space regions. </p>

</div>
</div>
<a id="ad31bd52878d2454d8263d0951cfd1ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31bd52878d2454d8263d0951cfd1ca0">&#9670;&nbsp;</a></span>DR_SEEK_CUR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_SEEK_CUR&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>current file position </p>

</div>
</div>
<a id="a06e58c043e838f1457853329fd4344a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e58c043e838f1457853329fd4344a3">&#9670;&nbsp;</a></span>DR_SEEK_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_SEEK_END&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>end of file </p>

</div>
</div>
<a id="aa675a6270b664511299295ebc1f5562e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa675a6270b664511299295ebc1f5562e">&#9670;&nbsp;</a></span>DR_SEEK_SET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_SEEK_SET&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>start of file </p>

</div>
</div>
<a id="a4e6bdc93e35ee5a9f081564a162ec3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6bdc93e35ee5a9f081564a162ec3b9">&#9670;&nbsp;</a></span>GLOBAL_DCONTEXT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GLOBAL_DCONTEXT&#160;&#160;&#160;((void *)-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this dcontext for use with the standalone static decoder library. Pass it whenever a decoding-related API routine asks for a context. </p>

</div>
</div>
<a id="a7574ce4aa047de1f4a564c9b441e69dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7574ce4aa047de1f4a564c9b441e69dc">&#9670;&nbsp;</a></span>LOG_ALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_ALL&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#acab56792af6a64911a9e62dfeb8b0981">DR_LOG_ALL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#acab56792af6a64911a9e62dfeb8b0981">DR_LOG_ALL</a>. </p>

</div>
</div>
<a id="a5895b0ef2efc255ad93e50bc88277b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5895b0ef2efc255ad93e50bc88277b6d">&#9670;&nbsp;</a></span>LOG_ASYNCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_ASYNCH&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#ae2ba7d86027989b56768e2275246182e">DR_LOG_ASYNCH</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#ae2ba7d86027989b56768e2275246182e">DR_LOG_ASYNCH</a>. </p>

</div>
</div>
<a id="a031661fca6b5cb813db972d758caca2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031661fca6b5cb813db972d758caca2b">&#9670;&nbsp;</a></span>LOG_CACHE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_CACHE&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a8714ae07e5f382ab7d989c14c406b935">DR_LOG_CACHE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a8714ae07e5f382ab7d989c14c406b935">DR_LOG_CACHE</a>. </p>

</div>
</div>
<a id="a9929e24db31369398fbdc52ee040b234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9929e24db31369398fbdc52ee040b234">&#9670;&nbsp;</a></span>LOG_DISPATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_DISPATCH&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#af2c8a0e03b86826f823a169b40699e4f">DR_LOG_DISPATCH</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#af2c8a0e03b86826f823a169b40699e4f">DR_LOG_DISPATCH</a>. </p>

</div>
</div>
<a id="a06582648acdd995a11019f726b15adda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06582648acdd995a11019f726b15adda">&#9670;&nbsp;</a></span>LOG_EMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_EMIT&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#aea15a10e6af6dd1f03b6967529b776fc">DR_LOG_EMIT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#aea15a10e6af6dd1f03b6967529b776fc">DR_LOG_EMIT</a>. </p>

</div>
</div>
<a id="a7c5fcb805e6a1fdfac332931888b3ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5fcb805e6a1fdfac332931888b3ef7">&#9670;&nbsp;</a></span>LOG_FRAGMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_FRAGMENT&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#ae6a1fd3e3710f996d26fa1ac8d3fc369">DR_LOG_FRAGMENT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#ae6a1fd3e3710f996d26fa1ac8d3fc369">DR_LOG_FRAGMENT</a>. </p>

</div>
</div>
<a id="a5522e92b98898a21b7c26ba9df95f094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5522e92b98898a21b7c26ba9df95f094">&#9670;&nbsp;</a></span>LOG_HEAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_HEAP&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a827401778f0f0f90f445c975c5e2f7c4">DR_LOG_HEAP</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a827401778f0f0f90f445c975c5e2f7c4">DR_LOG_HEAP</a>. </p>

</div>
</div>
<a id="a51c2bbdf11618716da67a305dd24ddde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c2bbdf11618716da67a305dd24ddde">&#9670;&nbsp;</a></span>LOG_HOT_PATCHING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_HOT_PATCHING&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a0ade83ca6b1ca70c099f1cd775ec10ca">DR_LOG_HOT_PATCHING</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a0ade83ca6b1ca70c099f1cd775ec10ca">DR_LOG_HOT_PATCHING</a>. </p>

</div>
</div>
<a id="a6ec73009ed3f0c2baa1d3c44033c261e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec73009ed3f0c2baa1d3c44033c261e">&#9670;&nbsp;</a></span>LOG_HTABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_HTABLE&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a3b470dff6d385ef7feb2f456356d0f2b">DR_LOG_HTABLE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a3b470dff6d385ef7feb2f456356d0f2b">DR_LOG_HTABLE</a>. </p>

</div>
</div>
<a id="a54bbda8cb7e78f2ea32209bab2d7201c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bbda8cb7e78f2ea32209bab2d7201c">&#9670;&nbsp;</a></span>LOG_INTERP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_INTERP&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#add8cedc710c8c450fd09b6542cd5aadc">DR_LOG_INTERP</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#add8cedc710c8c450fd09b6542cd5aadc">DR_LOG_INTERP</a>. </p>

</div>
</div>
<a id="a438ad3561d9d8616ff702b36d0b2bb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438ad3561d9d8616ff702b36d0b2bb7c">&#9670;&nbsp;</a></span>LOG_LINKS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_LINKS&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a56e0fc2c5c4028f645ab816d0fe06224">DR_LOG_LINKS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a56e0fc2c5c4028f645ab816d0fe06224">DR_LOG_LINKS</a>. </p>

</div>
</div>
<a id="aabb9931c63f1cf95cacca6463d5a9b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb9931c63f1cf95cacca6463d5a9b09">&#9670;&nbsp;</a></span>LOG_MEMSTATS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_MEMSTATS&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a52971d4b126b22c760012bdcdba4796e">DR_LOG_MEMSTATS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a52971d4b126b22c760012bdcdba4796e">DR_LOG_MEMSTATS</a>. </p>

</div>
</div>
<a id="abba5e74dd3a5577b7af5177960ecb9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba5e74dd3a5577b7af5177960ecb9dd">&#9670;&nbsp;</a></span>LOG_MODULEDB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_MODULEDB&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#aa772ad5c6339d52ca27b3da7e64a272d">DR_LOG_MODULEDB</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#aa772ad5c6339d52ca27b3da7e64a272d">DR_LOG_MODULEDB</a>. </p>

</div>
</div>
<a id="a2575baf458eee6334f746544f91fa6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2575baf458eee6334f746544f91fa6cf">&#9670;&nbsp;</a></span>LOG_MONITOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_MONITOR&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a5de43f77fcbc908d6ab61f1731db4210">DR_LOG_MONITOR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a5de43f77fcbc908d6ab61f1731db4210">DR_LOG_MONITOR</a>. </p>

</div>
</div>
<a id="a1632479322efa3952798f98177b54471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1632479322efa3952798f98177b54471">&#9670;&nbsp;</a></span>LOG_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_NONE&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a80f9b317b468d5e1e3599f3080db7739">DR_LOG_NONE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a80f9b317b468d5e1e3599f3080db7739">DR_LOG_NONE</a>. </p>

</div>
</div>
<a id="a4f3856a58f1f9971ebcd62c99a448a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3856a58f1f9971ebcd62c99a448a5a">&#9670;&nbsp;</a></span>LOG_NT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_NT&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a8915da4b3e63046309d88e761121e959">DR_LOG_NT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a8915da4b3e63046309d88e761121e959">DR_LOG_NT</a>. </p>

</div>
</div>
<a id="a9f746aa1ef6a208cd1cd7174a694c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f746aa1ef6a208cd1cd7174a694c9e5">&#9670;&nbsp;</a></span>LOG_OPTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_OPTS&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a31e132f043e5fa8d48d32c8cde6ef51d">DR_LOG_OPTS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a31e132f043e5fa8d48d32c8cde6ef51d">DR_LOG_OPTS</a>. </p>

</div>
</div>
<a id="a297668a84187b740ff4fe1e1d6e52eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297668a84187b740ff4fe1e1d6e52eeb">&#9670;&nbsp;</a></span>LOG_RCT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_RCT&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#aa5d4f7e0b8756ff97ce6eb4831f53177">DR_LOG_RCT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#aa5d4f7e0b8756ff97ce6eb4831f53177">DR_LOG_RCT</a>. </p>

</div>
</div>
<a id="a8ad7f6071c29a882af67d3a72fe4e787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad7f6071c29a882af67d3a72fe4e787">&#9670;&nbsp;</a></span>LOG_SIDELINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SIDELINE&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a5211b8fe9028d7ffac630d732eaf0614">DR_LOG_SIDELINE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a5211b8fe9028d7ffac630d732eaf0614">DR_LOG_SIDELINE</a>. </p>

</div>
</div>
<a id="a9dd9f361c4a23133f724c84192eef8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd9f361c4a23133f724c84192eef8e1">&#9670;&nbsp;</a></span>LOG_STATS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_STATS&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a1bfc4dffcec6a5f6b5851f81e5f2575e">DR_LOG_STATS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a1bfc4dffcec6a5f6b5851f81e5f2575e">DR_LOG_STATS</a>. </p>

</div>
</div>
<a id="a65630bab8d9fcde517b3f8ecb03c6de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65630bab8d9fcde517b3f8ecb03c6de9">&#9670;&nbsp;</a></span>LOG_SYMBOLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SYMBOLS&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a4605a61344628bdc31d15abd49a426ba">DR_LOG_SYMBOLS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a4605a61344628bdc31d15abd49a426ba">DR_LOG_SYMBOLS</a>. </p>

</div>
</div>
<a id="a8879b800acfbbe8f2ada805be6ef5121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8879b800acfbbe8f2ada805be6ef5121">&#9670;&nbsp;</a></span>LOG_SYNCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SYNCH&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#acf35bd0a62f41090a4da1caf1f7039a9">DR_LOG_SYNCH</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#acf35bd0a62f41090a4da1caf1f7039a9">DR_LOG_SYNCH</a>. </p>

</div>
</div>
<a id="a87ef794555c43a1988eb760835b2fa76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ef794555c43a1988eb760835b2fa76">&#9670;&nbsp;</a></span>LOG_SYSCALLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SYSCALLS&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a187545302d9056b56df6ea2453e2f92d">DR_LOG_SYSCALLS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a187545302d9056b56df6ea2453e2f92d">DR_LOG_SYSCALLS</a>. </p>

</div>
</div>
<a id="a9390202fe239f2ee56c097d6940d10f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9390202fe239f2ee56c097d6940d10f6">&#9670;&nbsp;</a></span>LOG_THREADS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_THREADS&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a58660d789f8390d329d24f5bd4ac0800">DR_LOG_THREADS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a58660d789f8390d329d24f5bd4ac0800">DR_LOG_THREADS</a>. </p>

</div>
</div>
<a id="a9fdb93b09477bb1b1ee08d132dd6f4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdb93b09477bb1b1ee08d132dd6f4dc">&#9670;&nbsp;</a></span>LOG_TOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_TOP&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#aa95a611b85c11e557bd2d541c9ed7d22">DR_LOG_TOP</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#aa95a611b85c11e557bd2d541c9ed7d22">DR_LOG_TOP</a>. </p>

</div>
</div>
<a id="a557f3a77c5d95b7cd06661245030c687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557f3a77c5d95b7cd06661245030c687">&#9670;&nbsp;</a></span>LOG_VMAREAS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_VMAREAS&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a4fff9a38640df11852f0aa877452c63e">DR_LOG_VMAREAS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a4fff9a38640df11852f0aa877452c63e">DR_LOG_VMAREAS</a>. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a97f41adcd55bab41fd0ff817bfaff1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f41adcd55bab41fd0ff817bfaff1c3">&#9670;&nbsp;</a></span>dr_memory_dump_spec_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__memory__dump__spec__t.html">_dr_memory_dump_spec_t</a> <a class="el" href="dr__tools_8h.html#a97f41adcd55bab41fd0ff817bfaff1c3">dr_memory_dump_spec_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates the type of memory dump for <a class="el" href="dr__tools_8h.html#afa268a6496cad930513c1f0353fdd06e">dr_create_memory_dump()</a>. </p>

</div>
</div>
<a id="afc574aa98b0e727a9b75059c4966eb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc574aa98b0e727a9b75059c4966eb10">&#9670;&nbsp;</a></span>dr_syscall_result_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__syscall__result__info__t.html">_dr_syscall_result_info_t</a> <a class="el" href="dr__tools_8h.html#afc574aa98b0e727a9b75059c4966eb10">dr_syscall_result_info_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data structure used to obtain or modify the result of an application system call by <a class="el" href="dr__tools_8h.html#ad2906dcd1979be92605bdf3c58c9f373">dr_syscall_get_result_ex()</a> and <a class="el" href="dr__tools_8h.html#a70710f3b42a9797a72ffb51f46720849">dr_syscall_set_result_ex()</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a39fca1837c5ce7715cbf571669660c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fca1837c5ce7715cbf571669660c13">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags for use with <a class="el" href="dr__tools_8h.html#ac2885193f264131c620475894e3d1e1e">dr_map_file()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a39fca1837c5ce7715cbf571669660c13ace272a4f3f0eff24ef44c983bfa4ce63"></a>DR_MAP_PRIVATE&#160;</td><td class="fielddoc"><p>If set, changes to mapped memory are private to the mapping process and are not reflected in the underlying file. If not set, changes are visible to other processes that map the same file, and will be propagated to the file itself. </p>
</td></tr>
<tr><td class="fieldname"><a id="a39fca1837c5ce7715cbf571669660c13aec0156a07c55523ed4bb3d2f05c00b58"></a>DR_MAP_FIXED&#160;</td><td class="fielddoc"><p>If set, indicates that the passed-in start address is required rather than a hint. On Linux, this has the same semantics as mmap with MAP_FIXED: i.e., any existing mapping in [addr,addr+size) will be unmapped. This flag is not supported on Windows. </p>
</td></tr>
<tr><td class="fieldname"><a id="a39fca1837c5ce7715cbf571669660c13a12a6a7af3936e4c932effc9505f23be5"></a>DR_MAP_IMAGE&#160;</td><td class="fielddoc"><p>If set, loads the specified file as an executable image, rather than a data file. This flag is not supported on Linux. </p>
</td></tr>
<tr><td class="fieldname"><a id="a39fca1837c5ce7715cbf571669660c13a6ba2a46cb1c2697fa81841feb05a777c"></a>DR_MAP_CACHE_REACHABLE&#160;</td><td class="fielddoc"><p>If set, loads the specified file at a location that is reachable from the code cache and client libraries by a 32-bit displacement. If not set, the mapped file is not guaranteed to be reachable from the cache. </p>
</td></tr>
</table>

</div>
</div>
<a id="abb7e20e83f7b8e1b65428e45c8ab4211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7e20e83f7b8e1b65428e45c8ab4211">&#9670;&nbsp;</a></span>dr_alloc_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211">dr_alloc_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags used with <a class="el" href="dr__tools_8h.html#a527e0746207909580b705f1743537921">dr_custom_alloc()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f"></a>DR_ALLOC_NON_HEAP&#160;</td><td class="fielddoc"><p>If this flag is not specified, <a class="el" href="dr__tools_8h.html#a527e0746207909580b705f1743537921">dr_custom_alloc()</a> uses a managed heap to allocate the memory, just like <a class="el" href="dr__tools_8h.html#a18d391b20559c1737c795f2ef1ba33d2">dr_thread_alloc()</a> or <a class="el" href="dr__tools_8h.html#a82f6546fc3e259e64493aeda5a8f1c86">dr_global_alloc()</a>. In that case, it ignores any requested protection bits (<code>prot</code> parameter), and the location (<code>addr</code> parameter) must be NULL. If this flag is specified, a page-aligned, separate block of memory is allocated, in a similar fashion to <a class="el" href="dr__tools_8h.html#a917384359d5efd538976402ff4b08aae">dr_nonheap_alloc()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="abb7e20e83f7b8e1b65428e45c8ab4211a312d65229e3450b24e59aec4b7d7410e"></a>DR_ALLOC_THREAD_PRIVATE&#160;</td><td class="fielddoc"><p>This flag only applies to heap memory (i.e., when <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f">DR_ALLOC_NON_HEAP</a> is not specified). If this flag is not specified, global heap is used (just like <a class="el" href="dr__tools_8h.html#a82f6546fc3e259e64493aeda5a8f1c86">dr_global_alloc()</a>) and the <code>drcontext</code> parameter is ignored. If it is specified, thread-private heap specific to <code>drcontext</code> is used, just like <a class="el" href="dr__tools_8h.html#a18d391b20559c1737c795f2ef1ba33d2">dr_thread_alloc()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="abb7e20e83f7b8e1b65428e45c8ab4211ab33a2e990410bf314bdebe6a25aa06e1"></a>DR_ALLOC_CACHE_REACHABLE&#160;</td><td class="fielddoc"><p>Allocate memory that is 32-bit-displacement reachable from the code caches and from the client library. Memory allocated through <a class="el" href="dr__tools_8h.html#a18d391b20559c1737c795f2ef1ba33d2">dr_thread_alloc()</a>, <a class="el" href="dr__tools_8h.html#a82f6546fc3e259e64493aeda5a8f1c86">dr_global_alloc()</a>, and <a class="el" href="dr__tools_8h.html#a917384359d5efd538976402ff4b08aae">dr_nonheap_alloc()</a> is also reachable, but for <a class="el" href="dr__tools_8h.html#a527e0746207909580b705f1743537921">dr_custom_alloc()</a>, the resulting memory is not reachable unless this flag is specified. If this flag is passed, the requested location (<code>addr</code> parameter) must be NULL. This flag is not compatible with <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ae32c4869e0c01cb57834e5ee7c163186">DR_ALLOC_LOW_2GB</a>, <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211a8bcd3bdb2ed2f71a1a7329274a195585">DR_ALLOC_FIXED_LOCATION</a>, or <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211aa0d11211c580eb6b368d07cb7546e376">DR_ALLOC_NON_DR</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="abb7e20e83f7b8e1b65428e45c8ab4211a8bcd3bdb2ed2f71a1a7329274a195585"></a>DR_ALLOC_FIXED_LOCATION&#160;</td><td class="fielddoc"><p>This flag only applies to non-heap memory (i.e., when <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f">DR_ALLOC_NON_HEAP</a> is specified). The flag requests that memory be allocated at a specific address, given in the <code>addr</code> parameter. Without this flag, the <code>addr</code> parameter is not honored. This flag is not compatible with <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ae32c4869e0c01cb57834e5ee7c163186">DR_ALLOC_LOW_2GB</a> or <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ab33a2e990410bf314bdebe6a25aa06e1">DR_ALLOC_CACHE_REACHABLE</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="abb7e20e83f7b8e1b65428e45c8ab4211ae32c4869e0c01cb57834e5ee7c163186"></a>DR_ALLOC_LOW_2GB&#160;</td><td class="fielddoc"><p>This flag only applies to non-heap memory (i.e., when <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f">DR_ALLOC_NON_HEAP</a> is specified) in 64-bit mode. The flag requests that memory be allocated in the low 2GB of the address space. If this flag is passed, the requested location (<code>addr</code> parameter) must be NULL. This flag is not compatible with <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211a8bcd3bdb2ed2f71a1a7329274a195585">DR_ALLOC_FIXED_LOCATION</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="abb7e20e83f7b8e1b65428e45c8ab4211aa0d11211c580eb6b368d07cb7546e376"></a>DR_ALLOC_NON_DR&#160;</td><td class="fielddoc"><p>This flag only applies to non-heap memory (i.e., when <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f">DR_ALLOC_NON_HEAP</a> is specified). When this flag is specified, the allocated memory is not considered to be DynamoRIO or tool memory and thus is not kept separate from the application. This is similar to <a class="el" href="dr__tools_8h.html#a2a5b61c462fe7d4c5f5b78f76a6eedce">dr_raw_mem_alloc()</a>. Use of this memory is at the client's own risk. This flag is not compatible with <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ab33a2e990410bf314bdebe6a25aa06e1">DR_ALLOC_CACHE_REACHABLE</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="abb7e20e83f7b8e1b65428e45c8ab4211a5d2a736bd28da9bfd1a3238777c74558"></a>DR_ALLOC_RESERVE_ONLY&#160;</td><td class="fielddoc"><p>This flag only applies to non-heap, non-DR memory (i.e., when both <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f">DR_ALLOC_NON_HEAP</a> and <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211aa0d11211c580eb6b368d07cb7546e376">DR_ALLOC_NON_DR</a> are specified) on Windows. When this flag is specified, the allocated memory is reserved but not committed, just like the MEM_RESERVE Windows API flag (the default is MEM_RESERVE|MEM_COMMIT). </p>
</td></tr>
<tr><td class="fieldname"><a id="abb7e20e83f7b8e1b65428e45c8ab4211a0f6cd06c9a4aa053b4e39fbde1fe7be1"></a>DR_ALLOC_COMMIT_ONLY&#160;</td><td class="fielddoc"><p>This flag only applies to non-heap, non-DR memory (i.e., when both <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f">DR_ALLOC_NON_HEAP</a> and <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211aa0d11211c580eb6b368d07cb7546e376">DR_ALLOC_NON_DR</a> are specified) on Windows. This flag must be combined with DR_ALLOC_FIXED_LOCATION. When this flag is specified, previously allocated memory is committed, just like the MEM_COMMIT Windows API flag (when this flag is not passed, the effect is MEM_RESERVE|MEM_COMMIT). When passed to <a class="el" href="dr__tools_8h.html#acbe9e5256b085452d5050c4b13ed541d">dr_custom_free()</a>, this flag causes a de-commit, just like the MEM_DECOMMIT Windows API flag. This flag cannot be combined with <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ae32c4869e0c01cb57834e5ee7c163186">DR_ALLOC_LOW_2GB</a> and must include a non-NULL requested location (<code>addr</code> parameter). </p>
</td></tr>
</table>

</div>
</div>
<a id="a3d99790cec275b8bad73c09b68279911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d99790cec275b8bad73c09b68279911">&#9670;&nbsp;</a></span>dr_indirect_branch_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#a3d99790cec275b8bad73c09b68279911">dr_indirect_branch_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies the type of indirect branch for use with <a class="el" href="dr__tools_8h.html#a25a98f51f66512fcf4611e3b5de68032">dr_prepopulate_indirect_targets()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3d99790cec275b8bad73c09b68279911a628ceb4b2f3a6421c2a882de0a69e2d2"></a>DR_INDIRECT_RETURN&#160;</td><td class="fielddoc"><p>Return instruction type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d99790cec275b8bad73c09b68279911a46a3285d13908b2c79e368074a0d8d06"></a>DR_INDIRECT_CALL&#160;</td><td class="fielddoc"><p>Indirect call instruction type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d99790cec275b8bad73c09b68279911ab9d3c8a5bd0110f7e638b9581524bbec"></a>DR_INDIRECT_JUMP&#160;</td><td class="fielddoc"><p>Indirect jump instruction type. </p>
</td></tr>
</table>

</div>
</div>
<a id="ade307e7bb7b7ac46e874097fe62b9fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade307e7bb7b7ac46e874097fe62b9fef">&#9670;&nbsp;</a></span>dr_map_executable_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#ade307e7bb7b7ac46e874097fe62b9fef">dr_map_executable_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags for use with <a class="el" href="dr__tools_8h.html#a192497da7670d454f6aae17d293f70b4">dr_map_executable_file()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ade307e7bb7b7ac46e874097fe62b9fefa183f27400568e903a072c9fc5bf0af96"></a>DR_MAPEXE_SKIP_WRITABLE&#160;</td><td class="fielddoc"><p>Requests that writable segments are not mapped, to save address space. This may be ignored on some platforms and may only be honored for a writable segment that is at the very end of the loaded module. </p>
</td></tr>
</table>

</div>
</div>
<a id="a00269a3ba590923c5d0ec4e0bcf5a9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00269a3ba590923c5d0ec4e0bcf5a9ff">&#9670;&nbsp;</a></span>dr_memory_dump_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#a00269a3ba590923c5d0ec4e0bcf5a9ff">dr_memory_dump_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates the type of memory dump for <a class="el" href="dr__tools_8h.html#afa268a6496cad930513c1f0353fdd06e">dr_create_memory_dump()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a00269a3ba590923c5d0ec4e0bcf5a9ffa00ec80b5919c0e6e1dc361a5fa9af02f"></a>DR_MEMORY_DUMP_LDMP&#160;</td><td class="fielddoc"><p>A "livedump", or "ldmp", DynamoRIO's own custom memory dump format. The ldmp format does not currently support specifying a context for the calling thread, so it will always include the call frames to <a class="el" href="dr__tools_8h.html#afa268a6496cad930513c1f0353fdd06e">dr_create_memory_dump()</a>. The <code>ldmp.exe</code> tool can be used to create a dummy process (using the <code>dummy.exe</code> executable) which can then be attached to by the debugger (use a non-invasive attach) in order to view the memory dump contents.</p>
<dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="a66bef18f8eabc7a8b8b0368e8a96d179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bef18f8eabc7a8b8b0368e8a96d179">&#9670;&nbsp;</a></span>dr_suspend_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#a66bef18f8eabc7a8b8b0368e8a96d179">dr_suspend_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags controlling the behavior of <a class="el" href="dr__tools_8h.html#a566d8b7214afc621019c8f0048a094b0">dr_suspend_all_other_threads_ex()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a66bef18f8eabc7a8b8b0368e8a96d179a21ba834e13979aa7ad97fd13c69b3ae4"></a>DR_SUSPEND_NATIVE&#160;</td><td class="fielddoc"><p>By default, native threads are not suspended by <a class="el" href="dr__tools_8h.html#a566d8b7214afc621019c8f0048a094b0">dr_suspend_all_other_threads_ex()</a>. This flag requests that native threads (including those temporarily-native due to actions such as <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a184a564eaa6cee9890f98f8a2d1c9c89">DR_EMIT_GO_NATIVE</a>) be suspended as well. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afdbf058d682175b76fe41767ae13198d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbf058d682175b76fe41767ae13198d">&#9670;&nbsp;</a></span>__wrap_calloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* __wrap_calloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory from DR's global memory pool, but mimics the behavior of calloc. Memory must be freed with <a class="el" href="dr__tools_8h.html#a4640fe5eadb1d6cb384f61524886211d">__wrap_free()</a>. The __wrap routines are intended to be used with ld's -wrap option; see <a class="el" href="dr__tools_8h.html#a26eb3354bab05483603b96774149aa2e">__wrap_malloc()</a> for more information. The returned address is guaranteed to be double-pointer-aligned: aligned to 16 bytes for 64-bit; aligned to 8 bytes for 32-bit. </p>

</div>
</div>
<a id="a4640fe5eadb1d6cb384f61524886211d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4640fe5eadb1d6cb384f61524886211d">&#9670;&nbsp;</a></span>__wrap_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void __wrap_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees memory from DR's global memory pool. Memory must have been allocated with <a class="el" href="dr__tools_8h.html#a26eb3354bab05483603b96774149aa2e">__wrap_malloc()</a>. The __wrap routines are intended to be used with ld's -wrap option; see <a class="el" href="dr__tools_8h.html#a26eb3354bab05483603b96774149aa2e">__wrap_malloc()</a> for more information. </p>

</div>
</div>
<a id="a26eb3354bab05483603b96774149aa2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26eb3354bab05483603b96774149aa2e">&#9670;&nbsp;</a></span>__wrap_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* __wrap_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory from DR's global memory pool, but mimics the behavior of malloc. Memory must be freed with <a class="el" href="dr__tools_8h.html#a4640fe5eadb1d6cb384f61524886211d">__wrap_free()</a>. The __wrap routines are intended to be used with ld's -wrap option to replace a client's use of malloc, realloc, and free with internal versions that allocate memory from DR's private pool. With -wrap, clients can link to libraries that allocate heap memory without interfering with application allocations. The returned address is guaranteed to be double-pointer-aligned: aligned to 16 bytes for 64-bit; aligned to 8 bytes for 32-bit. </p>

</div>
</div>
<a id="a308b0cde282bb6ad04b413a743ec2675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308b0cde282bb6ad04b413a743ec2675">&#9670;&nbsp;</a></span>__wrap_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* __wrap_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reallocates memory from DR's global memory pool, but mimics the behavior of realloc. Memory must be freed with <a class="el" href="dr__tools_8h.html#a4640fe5eadb1d6cb384f61524886211d">__wrap_free()</a>. The __wrap routines are intended to be used with ld's -wrap option; see <a class="el" href="dr__tools_8h.html#a26eb3354bab05483603b96774149aa2e">__wrap_malloc()</a> for more information. The returned address is guaranteed to be double-pointer-aligned: aligned to 16 bytes for 64-bit; aligned to 8 bytes for 32-bit. </p>

</div>
</div>
<a id="a2f5122da8f1587e2c38bb4690e830ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5122da8f1587e2c38bb4690e830ac2">&#9670;&nbsp;</a></span>__wrap_strdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API char* __wrap_strdup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory for a new string identical to 'str' and copies the contents of 'str' into the new string, including a terminating null. Memory must be freed with <a class="el" href="dr__tools_8h.html#a4640fe5eadb1d6cb384f61524886211d">__wrap_free()</a>. The __wrap routines are intended to be used with ld's -wrap option; see <a class="el" href="dr__tools_8h.html#a26eb3354bab05483603b96774149aa2e">__wrap_malloc()</a> for more information. The returned address is guaranteed to be double-pointer-aligned: aligned to 16 bytes for 64-bit; aligned to 8 bytes for 32-bit. </p>

</div>
</div>
<a id="a0f1fe81ae1737aa0e34eb69c855d359c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1fe81ae1737aa0e34eb69c855d359c">&#9670;&nbsp;</a></span>dr_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_abort </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aborts the process immediately without any cleanup (i.e., the exit event will not be called). </p>

</div>
</div>
<a id="aaaa686dee8c80b96c6615a1e42b46dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa686dee8c80b96c6615a1e42b46dbb">&#9670;&nbsp;</a></span>dr_abort_with_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_abort_with_code </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exit_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aborts the process immediately without any cleanup (i.e., the exit event will not be called) with the exit code <code>exit_code</code>.</p>
<p>On Linux, only the bottom 8 bits of <code>exit_code</code> will be honored for a normal exit. If bits 9..16 are not all zero, DR will send an unhandled signal of that signal number instead of performing a normal exit. </p>

</div>
</div>
<a id="a3f233285fe626838c3f61aac27a92050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f233285fe626838c3f61aac27a92050">&#9670;&nbsp;</a></span>dr_app_pc_for_decoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API app_pc dr_app_pc_for_decoding </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an application PC, returns a PC that contains the application code corresponding to the original PC. In some circumstances on Windows DR inserts a jump on top of the original code, which the client will not see in the bb and trace hooks due to DR replacing it there with the displaced original application code in order to present the client with an unmodified view of the application code. A client should use this routine when attempting to decode the original application instruction that caused a fault from the translated fault address, as the translated address may actually point in the middle of DR's jump.</p>
<dl class="section note"><dt>Note</dt><dd>Other applications on the system sometimes insert their own hooks, which will not be hidden by DR and will appear to the client as jumps and subsequent displaced code. </dd></dl>

</div>
</div>
<a id="a65a1bd0254f72ed1d70307c26d26daca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a1bd0254f72ed1d70307c26d26daca">&#9670;&nbsp;</a></span>dr_app_pc_from_cache_pc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API app_pc dr_app_pc_from_cache_pc </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>cache_pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a code cache pc, returns the corresponding application pc. This involves translating the state and thus may incur calls to the basic block and trace events (see <a class="el" href="dr__events_8h.html#acbfe1ece2c520d409ffd59076507a710">dr_register_bb_event()</a>). If translation fails, returns NULL. This routine may not be called from a thread exit event. </p>

</div>
</div>
<a id="a659d0f08d07d8b969d8f6c998be24848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659d0f08d07d8b969d8f6c998be24848">&#9670;&nbsp;</a></span>dr_app_recurlock_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_app_recurlock_lock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reclock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>mc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires <code>reclock</code>, or increments the ownership count if already owned. Calls to this method which block (i.e. when the lock is already held) are marked safe to suspend AND transfer; in that case the provided mcontext <code>mc</code> will overwrite the current thread's mcontext. <code>mc</code> must have a valid PC and its flags must be DR_MC_ALL.</p>
<p>This routine must be used in clients holding application locks to prevent deadlocks in a way similar to <a class="el" href="dr__tools_8h.html#ac63ccc4dc3cd6bec00c673eb73206808">dr_mark_safe_to_suspend()</a>, but this routine is intended to be called by a clean call and may return execution to the provided mcontext rather than returning normally.</p>
<p>If this routine is called from a clean call, callers should not return normally. Instead, <a class="el" href="dr__ir__utils_8h.html#ac3aa7797e4e3ce2f741f99712bb704f5">dr_redirect_execution()</a> or <a class="el" href="dr__ir__utils_8h.html#acb507c7b85501e8e52d85643c1e96a66">dr_redirect_native_target()</a> should be called to to prevent a return into a flushed code page. </p>

</div>
</div>
<a id="a0335f768c0ae053da44fd3f5886ac96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0335f768c0ae053da44fd3f5886ac96c">&#9670;&nbsp;</a></span>dr_atomic_add32_return_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int dr_atomic_add32_return_sum </td>
          <td>(</td>
          <td class="paramtype">volatile int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomically adds <code>val</code> to <code>*dest</code> and returns the sum. <code>dest</code> must not straddle two cache lines. </p>

</div>
</div>
<a id="a4a6e3a2c6b51b4d57a18601f840cc9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6e3a2c6b51b4d57a18601f840cc9de">&#9670;&nbsp;</a></span>dr_atomic_add64_return_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int64 dr_atomic_add64_return_sum </td>
          <td>(</td>
          <td class="paramtype">volatile int64 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomically adds <code>val</code> to <code>*dest</code> and returns the sum. <code>dest</code> must not straddle two cache lines. Currently 64-bit-build only. </p>

</div>
</div>
<a id="aed8d7a30d057679d5e791fb94a8910f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8d7a30d057679d5e791fb94a8910f7">&#9670;&nbsp;</a></span>dr_atomic_load32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int dr_atomic_load32 </td>
          <td>(</td>
          <td class="paramtype">volatile int *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomically and visibly loads the value at <code>src</code> and returns it. </p>

</div>
</div>
<a id="afcdbd3905a8b32ce1386d7de86b396c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdbd3905a8b32ce1386d7de86b396c4">&#9670;&nbsp;</a></span>dr_atomic_load64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int64 dr_atomic_load64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64 *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomically and visibly loads the value at <code>src</code> and returns it. Currently 64-bit-build only. </p>

</div>
</div>
<a id="ad1f172d289258a22d037bd2ee57aed9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f172d289258a22d037bd2ee57aed9c">&#9670;&nbsp;</a></span>dr_atomic_store32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_atomic_store32 </td>
          <td>(</td>
          <td class="paramtype">volatile int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomically and visibly stores <code>val</code> to <code>dest</code>. </p>

</div>
</div>
<a id="a2752c8a9f9637159c83819285ca4cc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2752c8a9f9637159c83819285ca4cc40">&#9670;&nbsp;</a></span>dr_atomic_store64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_atomic_store64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomically and visibly stores <code>val</code> to <code>dest</code>. Currently 64-bit-build only. </p>

</div>
</div>
<a id="ad0d274f12fa95b0534070f2efc654472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d274f12fa95b0534070f2efc654472">&#9670;&nbsp;</a></span>dr_bb_exists_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_bb_exists_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if a basic block with tag <code>tag</code> exists in the code cache. </p>

</div>
</div>
<a id="a52661f5c59ab6478f72e8f6774796188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52661f5c59ab6478f72e8f6774796188">&#9670;&nbsp;</a></span>dr_client_thread_set_suspendable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_client_thread_set_suspendable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>suspendable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Can only be called from a client thread: returns false if called from a non-client thread.</p>
<p>Controls whether a client thread created with <a class="el" href="dr__tools_8h.html#aca9bc4918a9b5facc7f44cf6a9e8bdca">dr_create_client_thread()</a> will be suspended by DR for synchronization operations such as flushing or client requests like <a class="el" href="dr__tools_8h.html#ae4eaefda11c27210a72df6d24f72871f">dr_suspend_all_other_threads()</a>. A client thread that spends a lot of time holding locks can gain greater performance by not being suspended.</p>
<p>A client thread <b>will</b> be suspended for a thread termination operation, including at process exit, regardless of its suspendable requests. </p>

</div>
</div>
<a id="a2f9ce8187cd9bff18c879978a9ab1b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9ce8187cd9bff18c879978a9ab1b8a">&#9670;&nbsp;</a></span>dr_close_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_close_file </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes file <code>f</code>. </p>

</div>
</div>
<a id="aca9bc4918a9b5facc7f44cf6a9e8bdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9bc4918a9b5facc7f44cf6a9e8bdca">&#9670;&nbsp;</a></span>dr_create_client_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_create_client_thread </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *param)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new thread that is marked as a non-application thread (i.e., DR will let it run natively and not execute its code from the code cache). The thread will terminate automatically simply by returning from <code>func</code>; if running when the application terminates its last thread, the client thread will also terminate when DR shuts the process down.</p>
<p>Init and exit events will not be raised for this thread (instead simply place init and exit code in <code>func</code>).</p>
<p>The new client thread has a drcontext that can be used for thread-private heap allocations. It has a stack of the same size as the DR stack used by application threads.</p>
<p>On Linux, this thread is guaranteed to have its own private itimer if <a class="el" href="dr__tools_8h.html#ac74de1da117d9c807b986aeda2523dd9">dr_set_itimer()</a> is called from it. However this does mean it will have its own process id.</p>
<p>A client thread should refrain from spending most of its time in calls to other libraries or making blocking or long-running system calls as such actions may incur performance or correctness problems with DR's synchronization engine, which needs to be able to suspend client threads at safe points and cannot determine whether the aforementioned actions are safe for suspension. Calling <a class="el" href="dr__tools_8h.html#aac428021a331be838eca5a0ef19989bd">dr_sleep()</a>, <a class="el" href="dr__tools_8h.html#a100ea691259a4eff5419e7b34245703d">dr_thread_yield()</a>, <a class="el" href="dr__tools_8h.html#ae52f61049269c0531b66b8c41c69e09e">dr_messagebox()</a>, or using DR's locks are safe. If a client thread spends a lot of time holding locks, consider marking it as un-suspendable by calling <a class="el" href="dr__tools_8h.html#a52661f5c59ab6478f72e8f6774796188">dr_client_thread_set_suspendable()</a> for better performance.</p>
<p>Client threads, whether suspendable or not, must never execute from the code cache as the underlying fragments might be removed by another thread.</p>
<p>Client threads are suspended while DR is not executing the application. This includes initialization time: the client thread's <code>func</code> code will not execute until DR starts executing the application.</p>
<dl class="section note"><dt>Note</dt><dd>Thread creation via this routine is not yet fully transparent: on Windows, the thread will show up in the list of application threads if the operating system is queried about threads. The thread will not trigger a DLL_THREAD_ATTACH message. On Linux, the thread will not receive signals meant for the application, and is guaranteed to have a private itimer. </dd></dl>

</div>
</div>
<a id="a0317a4764f0d04b5510fcfd418131a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0317a4764f0d04b5510fcfd418131a4c">&#9670;&nbsp;</a></span>dr_create_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_create_dir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new directory. Fails if the directory already exists or if it can't be created. Relative path support on Windows is identical to that described in <a class="el" href="dr__tools_8h.html#a8c1399687e4cbc3c0b9bddab3e7619d3">dr_open_file()</a>. </p>

</div>
</div>
<a id="afa268a6496cad930513c1f0353fdd06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa268a6496cad930513c1f0353fdd06e">&#9670;&nbsp;</a></span>dr_create_memory_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_create_memory_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#a97f41adcd55bab41fd0ff817bfaff1c3">dr_memory_dump_spec_t</a> *&#160;</td>
          <td class="paramname"><em>spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requests that DR create a memory dump file of the current process. The type of dump is specified by <code>spec</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function is only supported on Windows for now. </dd></dl>

</div>
</div>
<a id="a527e0746207909580b705f1743537921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527e0746207909580b705f1743537921">&#9670;&nbsp;</a></span>dr_custom_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_custom_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211">dr_alloc_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory with the properties requested by <code>flags</code>.</p>
<p>If <code>addr</code> is non-NULL (only allowed with certain flags), it must be page-aligned.</p>
<p>To make more space available for the code caches when running larger applications, or for clients that use a lot of heap memory that is not directly referenced from the cache, we recommend that <a class="el" href="dr__tools_8h.html#a527e0746207909580b705f1743537921">dr_custom_alloc()</a> be called to obtain memory that is not guaranteed to be reachable from the code cache (by not passing <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ab33a2e990410bf314bdebe6a25aa06e1">DR_ALLOC_CACHE_REACHABLE</a>). This frees up space in the reachable region.</p>
<p>Returns NULL on failure. </p>

</div>
</div>
<a id="acbe9e5256b085452d5050c4b13ed541d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe9e5256b085452d5050c4b13ed541d">&#9670;&nbsp;</a></span>dr_custom_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_custom_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211">dr_alloc_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees memory allocated by <a class="el" href="dr__tools_8h.html#a527e0746207909580b705f1743537921">dr_custom_alloc()</a>. The same <code>flags</code> and <code>size</code> must be passed here as were passed to <a class="el" href="dr__tools_8h.html#a527e0746207909580b705f1743537921">dr_custom_alloc()</a>. </p>

</div>
</div>
<a id="a9a3f791ec0b8edddf607612c6804709f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3f791ec0b8edddf607612c6804709f">&#9670;&nbsp;</a></span>dr_delay_flush_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_delay_flush_region </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flush_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int flush_id)&#160;</td>
          <td class="paramname"><em>flush_completion_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request a flush of all fragments containing code from the region [<code>start</code>, <code>start</code> + <code>size</code>). The flush will be performed at the next safe point in time (usually before any new code is added to the cache after this routine is called). If <code>flush_completion_callback</code> is non-NULL, it will be called with the <code>flush_id</code> provided to this routine when the flush completes, after which no execution will occur out of the fragments flushed. Returns true if the flush was successfully queued.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="dr__tools_8h.html#a5b02f80af80dcd6005bf6c70ae7e7ad7">dr_flush_region()</a> and <a class="el" href="dr__tools_8h.html#a57669d0e147191660153b928eca7f09b">dr_unlink_flush_region()</a> can give stronger guarantees on when the flush will occur, but have more restrictions on use. </dd>
<dd>
Use <code>size</code> == 1 to flush fragments containing the instruction at address <code>start</code>. A flush of <code>size</code> == 0 is not allowed. </dd>
<dd>
As currently implemented there may be a performance penalty for requesting a <code>flush_completion_callback</code>; for most performant usage set <code>flush_completion_callback</code> to NULL. </dd></dl>

</div>
</div>
<a id="a43b23d88adc4536bc69c771999fde3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b23d88adc4536bc69c771999fde3d2">&#9670;&nbsp;</a></span>dr_delete_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_delete_dir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the given directory. Fails if the directory is not empty. Relative path support on Windows is identical to that described in <a class="el" href="dr__tools_8h.html#a8c1399687e4cbc3c0b9bddab3e7619d3">dr_open_file()</a>. </p>

</div>
</div>
<a id="a518ec4d2f8bb8ab51782c14ba0be2fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518ec4d2f8bb8ab51782c14ba0be2fd3">&#9670;&nbsp;</a></span>dr_delete_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_delete_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the file referred to by <code>filename</code>. Returns true if successful. On both Linux and Windows, if filename refers to a symlink, the symlink will be deleted and not the target of the symlink. On Windows, this will fail to delete any file that was not opened with FILE_SHARE_DELETE and is still open. Relative path support on Windows is identical to that described in <a class="el" href="dr__tools_8h.html#a8c1399687e4cbc3c0b9bddab3e7619d3">dr_open_file()</a>. </p>

</div>
</div>
<a id="a65e5ee30d5f4226445ce589f5b41b720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e5ee30d5f4226445ce589f5b41b720">&#9670;&nbsp;</a></span>dr_delete_fragment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_delete_fragment </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the fragment with tag <code>tag</code>. This routine is only valid with the -thread_private option; it deletes the fragment in the current thread only. After deletion, the existing fragment is allowed to complete execution. For example, a clean call deleting the currently executing fragment will safely return to the existing code. Subsequent executions will cause DynamoRIO to reconstruct the fragment, and therefore call the appropriate fragment-creation event hook, if registered.</p>
<dl class="section note"><dt>Note</dt><dd>This routine supports deletion for the current thread only. <code>drcontext</code> must be from the current thread and must be the drcontext used to create the instruction list. This routine may not be called from the thread exit event.</dd>
<dd>
Other options of removing the code fragments from code cache include <a class="el" href="dr__tools_8h.html#a5b02f80af80dcd6005bf6c70ae7e7ad7">dr_flush_region()</a>, <a class="el" href="dr__tools_8h.html#a57669d0e147191660153b928eca7f09b">dr_unlink_flush_region()</a>, and <a class="el" href="dr__tools_8h.html#a9a3f791ec0b8edddf607612c6804709f">dr_delay_flush_region()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if the fragment does not exist and true otherwise. </dd></dl>

</div>
</div>
<a id="ab3a0a8c4e06776d42bac20ac26c0632d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a0a8c4e06776d42bac20ac26c0632d">&#9670;&nbsp;</a></span>dr_directory_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_directory_exists </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks for the existence of a directory. Relative path support on Windows is identical to that described in <a class="el" href="dr__tools_8h.html#a8c1399687e4cbc3c0b9bddab3e7619d3">dr_open_file()</a>. </p>

</div>
</div>
<a id="a08ac1cc05cf53faed156aa6c16a18d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ac1cc05cf53faed156aa6c16a18d93">&#9670;&nbsp;</a></span>dr_dup_file_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API file_t dr_dup_file_handle </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new copy of the file handle <code>f</code>. Returns INVALID_FILE on error. </p>

</div>
</div>
<a id="ab870ad4d34833368e16bd3f6e07ba624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab870ad4d34833368e16bd3f6e07ba624">&#9670;&nbsp;</a></span>dr_enable_console_printing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_enable_console_printing </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables <a class="el" href="dr__tools_8h.html#aeb88b22ff95c29ae793b9d84e1b95275">dr_printf()</a> and <a class="el" href="dr__tools_8h.html#ae338685a241cfeae5f3d507ae9cff957">dr_fprintf()</a> to work with a legacy console window (viz., <code>cmd</code> on Windows 7 or earlier). Loads a private copy of kernel32.dll (if not already loaded) in order to accomplish this. To keep the default DR lean and mean, loading kernel32.dll is not performed by default.</p>
<p>This routine must be called during client initialization (<code><a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a></code>). If called later, it will fail.</p>
<p>Without calling this routine, <a class="el" href="dr__tools_8h.html#aeb88b22ff95c29ae793b9d84e1b95275">dr_printf()</a> and <a class="el" href="dr__tools_8h.html#ae338685a241cfeae5f3d507ae9cff957">dr_fprintf()</a> will not print anything in a console window on Windows 7 or earlier, nor will they print anything when running a graphical application.</p>
<p>Even after calling this routine, there are significant limitations to console printing support in DR:</p>
<ul>
<li>On Windows versions prior to Vista, and for WOW64 applications on Vista, it does not work from the exit event. Once the application terminates its state with csrss (toward the very end of ExitProcess), no output will show up on the console. We have no good solution here yet as exiting early is not ideal.</li>
<li>In the future, with earliest injection (Issue 234), writing to the console may not work from the client init event on Windows 7 and earlier (it will work on Windows 8).</li>
</ul>
<p>These limitations stem from the complex arrangement of the console window in Windows (prior to Windows 8), where printing to it involves sending a message in an undocumented format to the <code>csrss</code> process, rather than a simple write to a file handle. We recommend using a terminal window such as cygwin's <code>rxvt</code> rather than the <code>cmd</code> window, or alternatively redirecting all output to a file, which will solve all of the above limitations.</p>
<p>Returns whether successful. </p><dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>

</div>
</div>
<a id="ae450459bac13aece28ef7b00438339d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae450459bac13aece28ef7b00438339d1">&#9670;&nbsp;</a></span>dr_event_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_event_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an event object on which threads can wait and be signaled. </p>

</div>
</div>
<a id="a8f4f9d413cf4c6b6aedc83880b5b80d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4f9d413cf4c6b6aedc83880b5b80d6">&#9670;&nbsp;</a></span>dr_event_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_event_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys an event object. </p>

</div>
</div>
<a id="aafbc013e6cebabb2048eccd2f219026a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbc013e6cebabb2048eccd2f219026a">&#9670;&nbsp;</a></span>dr_event_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_event_reset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets <code>event</code> to no longer be in a signaled state. </p>

</div>
</div>
<a id="a477e5120f49129fdc09a62051c4eba93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477e5120f49129fdc09a62051c4eba93">&#9670;&nbsp;</a></span>dr_event_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_event_signal </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wakes up at most one thread waiting on <code>event</code>. </p>

</div>
</div>
<a id="a2d5fadf6f5c125e1758ba64e9914913a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5fadf6f5c125e1758ba64e9914913a">&#9670;&nbsp;</a></span>dr_event_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_event_wait </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suspends the current thread until <code>event</code> is signaled. </p>

</div>
</div>
<a id="aec4ac39e59bdcec70223794387db9fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4ac39e59bdcec70223794387db9fd0">&#9670;&nbsp;</a></span>dr_exit_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_exit_process </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exit_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exits the process, first performing a full cleanup that will trigger the exit event (<a class="el" href="dr__events_8h.html#a32f38cabf4b2c554ce4e476c5d5f6f3a">dr_register_exit_event()</a>). The process exit code is set to <code>exit_code</code>.</p>
<p>On Linux, only the bottom 8 bits of <code>exit_code</code> will be honored for a normal exit. If bits 9..16 are not all zero, DR will send an unhandled signal of that signal number instead of performing a normal exit.</p>
<dl class="section note"><dt>Note</dt><dd>Calling this from <code>dr_client_main</code> or from the primary thread's initialization event is not guaranteed to always work, as DR may invoke a thread exit event where a thread init event was never called. We recommend using dr_abort_ex() or waiting for full initialization prior to use of this routine. </dd></dl>

</div>
</div>
<a id="afe870f8dd183281593eb10199ec453c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe870f8dd183281593eb10199ec453c2">&#9670;&nbsp;</a></span>dr_file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_file_exists </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the existence of a file. Relative path support on Windows is identical to that described in <a class="el" href="dr__tools_8h.html#a8c1399687e4cbc3c0b9bddab3e7619d3">dr_open_file()</a>. </p>

</div>
</div>
<a id="a5fd936c82cd8b9054a3336598b0343ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd936c82cd8b9054a3336598b0343ed">&#9670;&nbsp;</a></span>dr_file_seek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_file_seek </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the current file position for file <code>f</code> to <code>offset</code> bytes from the specified origin, where <code>origin</code> is one of the DR_SEEK_* values. Returns true if successful. </p>

</div>
</div>
<a id="a34ee1db27b9b527a5488314d12782700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ee1db27b9b527a5488314d12782700">&#9670;&nbsp;</a></span>dr_file_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_file_size </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint64 *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the size of the file <code>fd</code>. On success, returns the size in <code>size</code>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="a0eb97885112fe6fdad5a983342545643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb97885112fe6fdad5a983342545643">&#9670;&nbsp;</a></span>dr_file_tell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int64 dr_file_tell </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current position for the file <code>f</code> in bytes from the start of the file. Returns -1 on an error. </p>

</div>
</div>
<a id="a02172538d802277fdbeb215b3849f968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02172538d802277fdbeb215b3849f968">&#9670;&nbsp;</a></span>dr_flush_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_flush_file </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flushes any buffers for file <code>f</code>. </p>

</div>
</div>
<a id="a5b02f80af80dcd6005bf6c70ae7e7ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b02f80af80dcd6005bf6c70ae7e7ad7">&#9670;&nbsp;</a></span>dr_flush_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_flush_region </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to dr_flush_region_ex(start, size, NULL). </p>

</div>
</div>
<a id="aa9d4ad288807e3c033ab54013d8a49a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d4ad288807e3c033ab54013d8a49a4">&#9670;&nbsp;</a></span>dr_flush_region_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_flush_region_ex </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *user_data)&#160;</td>
          <td class="paramname"><em>flush_completion_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush all fragments containing any code from the region [<code>start</code>, <code>start</code> + <code>size</code>). Once this routine returns no execution will occur out of the fragments flushed. This routine may only be called during a clean call from the cache, from a nudge event handler, or from a pre- or post-system call event handler. It may not be called from any other event callback. No locks can held when calling this routine. If called from a clean call, caller can NOT return to the cache (the fragment that was called out of may have been flushed even if it doesn't apparently overlap the flushed region). Instead the caller must redirect execution via <a class="el" href="dr__ir__utils_8h.html#ac3aa7797e4e3ce2f741f99712bb704f5">dr_redirect_execution()</a> (or DR_SIGNAL_REDIRECT from a signal callback) after this routine to continue execution. Returns true if successful.</p>
<dl class="section note"><dt>Note</dt><dd>This routine may not be called from any registered event callback other than the nudge event, the pre- or post-system call events, the exception event, or the signal event; clean calls out of the cache may call this routine.</dd>
<dd>
If called from a clean call, caller must continue execution by calling <a class="el" href="dr__ir__utils_8h.html#ac3aa7797e4e3ce2f741f99712bb704f5">dr_redirect_execution()</a> after this routine, as the fragment containing the callout may have been flushed. The context to use can be obtained via <a class="el" href="dr__ir__utils_8h.html#a9e348b2596b8750ce3fad234ab022ced">dr_get_mcontext()</a> with the exception of the pc to continue at which must be passed as an argument to the callout (see <a class="el" href="dr__ir__instr_8h.html#a090b27b5334c6be542c4fcfed7b97ffb">instr_get_app_pc()</a>) or otherwise determined.</dd>
<dd>
This routine may not be called while any locks are held that could block a thread processing a registered event callback or cache callout.</dd>
<dd>
<a class="el" href="dr__tools_8h.html#a9a3f791ec0b8edddf607612c6804709f">dr_delay_flush_region()</a> has fewer restrictions on use, but is less synchronous.</dd>
<dd>
Use <code>size</code> == 1 to flush fragments containing the instruction at address <code>start</code>. A flush of <code>size</code> == 0 is not allowed.</dd>
<dd>
Use flush_completion_callback to specify logic to be executed after the flush and before the threads are resumed. Use NULL if not needed.</dd>
<dd>
As currently implemented, <a class="el" href="dr__tools_8h.html#a9a3f791ec0b8edddf607612c6804709f">dr_delay_flush_region()</a> with no completion callback routine specified can be substantially more performant. </dd></dl>

</div>
</div>
<a id="ae338685a241cfeae5f3d507ae9cff957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae338685a241cfeae5f3d507ae9cff957">&#9670;&nbsp;</a></span>dr_fprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API ssize_t dr_fprintf </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Printing to a file that won't interfere with the application's own printing. It is not buffered, which means that it should not be used for very frequent, small print amounts: for that the client should either do its own buffering or it should use printf from the C library via DR's private loader. </p><dl class="section note"><dt>Note</dt><dd>On Windows 7 and earlier, this routine is not able to print to STDOUT or STDERR in the <code>cmd</code> window unless <a class="el" href="dr__tools_8h.html#ab870ad4d34833368e16bd3f6e07ba624">dr_enable_console_printing()</a> is called ahead of time, and even then there are limitations: see <a class="el" href="dr__tools_8h.html#ab870ad4d34833368e16bd3f6e07ba624">dr_enable_console_printing()</a>. </dd>
<dd>
This routine supports printing wide characters via the ls or S format specifiers. On Windows, they are assumed to be UTF-16, and are converted to UTF-8. On Linux, they are converted by simply dropping the high-order bytes. </dd>
<dd>
If the data to be printed is large it will be truncated to an internal buffer size. Use <a class="el" href="dr__tools_8h.html#a07fe87f7bf9560a45751064329bc8c12">dr_snprintf()</a> and <a class="el" href="dr__tools_8h.html#a451ff3e57783acbfdf24c1e557145807">dr_write_file()</a> for large output. </dd>
<dd>
On Linux this routine does not check for errors like EINTR. Use <a class="el" href="dr__tools_8h.html#a451ff3e57783acbfdf24c1e557145807">dr_write_file()</a> if that is a concern. </dd>
<dd>
When printing floating-point values, the caller's code should use <a class="el" href="dr__proc_8h.html#a48ca3205c37d6e41d007ac54a1d60e6a">proc_save_fpstate()</a> or be inside a clean call that has requested to preserve the floating-point state, unless it can prove that its compiler will not use x87 operations. On success, the number of bytes written is returned. On error, -1 is returned. </dd></dl>

</div>
</div>
<a id="a84d16222754e0f831ef5700a67fcc3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d16222754e0f831ef5700a67fcc3fb">&#9670;&nbsp;</a></span>dr_fragment_app_pc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API app_pc dr_fragment_app_pc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the application PC of a fragment with tag <code>tag</code>. </p>

</div>
</div>
<a id="a2bd17c746673622a416b007c3f50e073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd17c746673622a416b007c3f50e073">&#9670;&nbsp;</a></span>dr_fragment_exists_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_fragment_exists_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether or not there is a fragment in code cache with tag <code>tag</code>. </p>

</div>
</div>
<a id="a33a7b59a456b61adffaa9f0f35d41bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a7b59a456b61adffaa9f0f35d41bb6">&#9670;&nbsp;</a></span>dr_fragment_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API uint dr_fragment_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks up the fragment with tag <code>tag</code>. If not found, returns 0. If found, returns the total size occupied in the cache by the fragment. </p>

</div>
</div>
<a id="acdead1ca945b38f865c5599bdebf9d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdead1ca945b38f865c5599bdebf9d0e">&#9670;&nbsp;</a></span>dr_get_client_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* dr_get_client_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&#160;</td>
          <td class="paramname"><em>client_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the base address of the client library. <code>client_id</code> is the client ID passed to a client's <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a> function. </p>

</div>
</div>
<a id="afccb9210ada84de4fbbaa8d851952a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccb9210ada84de4fbbaa8d851952a37">&#9670;&nbsp;</a></span>dr_get_client_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const DR_API char* dr_get_client_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&#160;</td>
          <td class="paramname"><em>client_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the client library name and path that were originally specified to load the library. If the resulting string is longer than <a class="el" href="dr__defines_8h.html#a95c7b582d53e0a376f2a0e89323b2a7b">MAXIMUM_PATH</a> it will be truncated. <code>client_id</code> is the client ID passed to a client's <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a> function. </p>

</div>
</div>
<a id="ac3a677a98692a1f11b4f5b0270cf0912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a677a98692a1f11b4f5b0270cf0912">&#9670;&nbsp;</a></span>dr_get_current_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_get_current_directory </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current directory for this process in <code>buf</code>. On Windows, reading the current directory is considered unsafe except during initialization, as it is stored in user memory and access is not controlled via any standard synchronization. </p>

</div>
</div>
<a id="a317a1bb4c01ab9e6e64d2644d0ea984c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317a1bb4c01ab9e6e64d2644d0ea984c">&#9670;&nbsp;</a></span>dr_get_current_drcontext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_get_current_drcontext </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the DR context of the current thread. </p>

</div>
</div>
<a id="a88d91064ffa84c097c84694d78a2ad22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d91064ffa84c097c84694d78a2ad22">&#9670;&nbsp;</a></span>dr_get_dr_segment_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_get_dr_segment_base </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>tls_register</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get DR's thread local storage segment base pointed at by <code>tls_register</code>. It can be used to get the base of the thread-local storage segment used by <a class="el" href="dr__tools_8h.html#ac5d2a2ccd58268f84c379a38bc4aa399">dr_raw_tls_calloc</a>.</p>
<dl class="section note"><dt>Note</dt><dd>It should not be called on thread exit event, as the thread exit event may be invoked from other threads. See <a class="el" href="dr__events_8h.html#aa34d296a9e990925a096501a7d5c6596">dr_register_thread_exit_event</a> for details. </dd></dl>

</div>
</div>
<a id="ad42f2c7b95786297e1b45b6de81e257d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42f2c7b95786297e1b45b6de81e257d">&#9670;&nbsp;</a></span>dr_get_dr_thread_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API HANDLE dr_get_dr_thread_handle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a Windows handle to the thread with drcontext <code>drcontext</code>. This handle is DR's handle to this thread (it is not a separate copy) and as such it should not be closed by the caller; nor should it be used beyond the thread's exit, as DR's handle will be closed at that point.</p>
<p>The handle should have THREAD_ALL_ACCESS privileges. </p><dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>

</div>
</div>
<a id="a908074540820a8140bbc46cb3c020778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908074540820a8140bbc46cb3c020778">&#9670;&nbsp;</a></span>dr_get_error_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API <a class="el" href="dr__defines_8h.html#a5ecc0dbd0afec416ca2626dba4cd3fe1">dr_error_code_t</a> dr_get_error_code </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the error code of the last failed API routine. Users should check whether or not the API routine that they just called has failed prior to calling this function.</p>
<dl class="section warning"><dt>Warning</dt><dd>Not all API routines currently support the registering of an error code upon their failure. Therefore, check the routine's documentation to see whether it supports setting error codes. </dd></dl>

</div>
</div>
<a id="a0b43ec2cea34645dab0282cf6204d226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b43ec2cea34645dab0282cf6204d226">&#9670;&nbsp;</a></span>dr_get_integer_option()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_get_integer_option </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>option_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64 *val&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the value of an integer DynamoRIO runtime option named <code>option_name</code> into <code>val</code>. This includes boolean options. Options are listed in <a class="el" href="page_deploy.html#sec_options">DynamoRIO Runtime Options</a>. DynamoRIO has many other undocumented options which may be queried through this API, but they are not officially supported. </p><dl class="section warning"><dt>Warning</dt><dd>Always pass a full uint64 for <code>val</code> even if the option is a smaller integer to avoid overwriting nearby data. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if no option named <code>option_name</code> exists, and true otherwise. </dd></dl>

</div>
</div>
<a id="a5d2f1d0559603dc203351d9b8da0e216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2f1d0559603dc203351d9b8da0e216">&#9670;&nbsp;</a></span>dr_get_itimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API uint dr_get_itimer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If an interval timer is already installed in the itimer sharing group that contains the calling thread, returns its frequency. Else returns 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">which</td><td>Must be one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Linux-only. </dd></dl>

</div>
</div>
<a id="aa96a2deefd61c7308a9beb3a82023603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96a2deefd61c7308a9beb3a82023603">&#9670;&nbsp;</a></span>dr_get_logfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API file_t dr_get_logfile </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log file for the thread with drcontext <code>drcontext</code>. If <code>drcontext</code> is NULL, returns the main log file. </p>

</div>
</div>
<a id="aec75982f030fbae7019ecf2d54cd1c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec75982f030fbae7019ecf2d54cd1c21">&#9670;&nbsp;</a></span>dr_get_microseconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API uint64 dr_get_microseconds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of microseconds since Jan 1, 1601 (this is the current UTC time).</p>
<dl class="section note"><dt>Note</dt><dd>This is the Windows standard. UNIX time functions typically count from the Epoch (Jan 1, 1970). The Epoch is 11644473600*1000*1000 microseconds after Jan 1, 1601. </dd></dl>

</div>
</div>
<a id="a487aba7cc5d4a71cea5318e4840984e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487aba7cc5d4a71cea5318e4840984e8">&#9670;&nbsp;</a></span>dr_get_milliseconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API uint64 dr_get_milliseconds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of milliseconds since Jan 1, 1601 (this is the current UTC time).</p>
<dl class="section note"><dt>Note</dt><dd>This is the Windows standard. UNIX time functions typically count from the Epoch (Jan 1, 1970). The Epoch is 11644473600*1000 milliseconds after Jan 1, 1601. </dd></dl>

</div>
</div>
<a id="a5f53df83b2108925fa52bd607536e25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f53df83b2108925fa52bd607536e25d">&#9670;&nbsp;</a></span>dr_get_option_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_get_option_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *argc&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char ***argv&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the client-specific option string specified at client registration, parsed into an array of <code>argc</code> separate option tokens stored in <code>argv</code>. This is the same array of arguments passed to the <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a> routine. </p>

</div>
</div>
<a id="affc4a7a38a1fa1fe45c1a15e01a98e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc4a7a38a1fa1fe45c1a15e01a98e78">&#9670;&nbsp;</a></span>dr_get_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const DR_API char* dr_get_options </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&#160;</td>
          <td class="paramname"><em>client_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the client-specific option string specified at client registration. <code>client_id</code> is the client ID passed to <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>This routine is replaced by <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a>'s arguments and by <a class="el" href="dr__tools_8h.html#a5f53df83b2108925fa52bd607536e25d">dr_get_option_array()</a>. The front-end <code>drrun</code> and other utilities now re-quote all tokens, providing simpler option passing without escaping or extra quote layers. This routine, for compatibility, strips those quotes off and returns a flat string without any token-delimiting quotes. </dd></dl>

</div>
</div>
<a id="a61da9915f2e77f2bcbc4e07bcac945dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61da9915f2e77f2bcbc4e07bcac945dc">&#9670;&nbsp;</a></span>dr_get_random_seed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API uint dr_get_random_seed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the seed used for <a class="el" href="dr__tools_8h.html#a036726345f9ea686b7eae46eca38e5e3">dr_get_random_value()</a>. </p>

</div>
</div>
<a id="a036726345f9ea686b7eae46eca38e5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036726345f9ea686b7eae46eca38e5e3">&#9670;&nbsp;</a></span>dr_get_random_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API uint dr_get_random_value </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pseudo-random number in the range [0..max). The pseudo-random sequence can be repeated by passing the seed used during a run to the next run via the -prng_seed runtime option. </p>

</div>
</div>
<a id="a0436b08f1b548fd783b390dd0e740eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0436b08f1b548fd783b390dd0e740eef">&#9670;&nbsp;</a></span>dr_get_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_get_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a213f155f07a830b79111449062545352">dr_stats_t</a> *&#160;</td>
          <td class="paramname"><em>drstats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves various statistics exported by DR as global, process-wide values. The API is not thread-safe. The caller is expected to pass a pointer to a valid, initialized <a class="el" href="dr__defines_8h.html#a213f155f07a830b79111449062545352">dr_stats_t</a> value, with the size field set (see <a class="el" href="dr__defines_8h.html#a213f155f07a830b79111449062545352">dr_stats_t</a>). Returns false if stats are not enabled. </p>

</div>
</div>
<a id="affce3c79aafa38a4fc00ac083ac9a55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affce3c79aafa38a4fc00ac083ac9a55a">&#9670;&nbsp;</a></span>dr_get_stderr_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API file_t dr_get_stderr_file </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a handle to stderr. </p>

</div>
</div>
<a id="adf64b8dc334709ed00623248fcae3c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf64b8dc334709ed00623248fcae3c73">&#9670;&nbsp;</a></span>dr_get_stdin_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API file_t dr_get_stdin_file </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a handle to stdin. </p>

</div>
</div>
<a id="a24b96f569a13ecfd30305cbec82af580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b96f569a13ecfd30305cbec82af580">&#9670;&nbsp;</a></span>dr_get_stdout_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API file_t dr_get_stdout_file </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a handle to stdout. </p>

</div>
</div>
<a id="a7d8202a00c908f0e98083cc2183abc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8202a00c908f0e98083cc2183abc40">&#9670;&nbsp;</a></span>dr_get_string_option()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_get_string_option </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>option_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *buf&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the value of a string DynamoRIO runtime option named <code>option_name</code> into <code>buf</code>. Options are listed in <a class="el" href="page_deploy.html#sec_options">DynamoRIO Runtime Options</a>. DynamoRIO has many other undocumented options which may be queried through this API, but they are not officially supported. The option value is truncated to <code>len</code> bytes and null-terminated. </p><dl class="section return"><dt>Returns</dt><dd>false if no option named <code>option_name</code> exists, and true otherwise. </dd></dl>

</div>
</div>
<a id="a56eae1c5bac30a5336a99c5d91d5a10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56eae1c5bac30a5336a99c5d91d5a10c">&#9670;&nbsp;</a></span>dr_get_thread_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API thread_id_t dr_get_thread_id </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the thread id of the thread with drcontext <code>drcontext</code>. </p>

</div>
</div>
<a id="aaf560764ce43a11d3f5abb6e4f78dcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf560764ce43a11d3f5abb6e4f78dcae">&#9670;&nbsp;</a></span>dr_get_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_get_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdr__time__t.html">dr_time_t</a> *&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the current time. </p>

</div>
</div>
<a id="aaa04a14c2cbf783b4926c2fd14445f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa04a14c2cbf783b4926c2fd14445f82">&#9670;&nbsp;</a></span>dr_get_tls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_get_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the user-controlled thread-local-storage field. To generate an instruction sequence that reads the drcontext field inline in the code cache, use <a class="el" href="dr__ir__utils_8h.html#aab7b4392c68e53f807bba5791183f240">dr_insert_read_tls_field()</a>. </p>

</div>
</div>
<a id="a4510e709f5b5285eaeb3435f1d42c544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4510e709f5b5285eaeb3435f1d42c544">&#9670;&nbsp;</a></span>dr_get_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const DR_API char* dr_get_token </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function that aids in tokenizing a string, such as a client options string from <a class="el" href="dr__tools_8h.html#affc4a7a38a1fa1fe45c1a15e01a98e78">dr_get_options()</a>. The function scans <code>str</code> until a non-whitespace character is found. It then starts copying into <code>buf</code> until a whitespace character is found denoting the end of the token. If the token begins with a quote, the token continues (including across whitespace) until the matching end quote is found. Characters considered whitespace are ' ', '\t', '\r', and '\n'; characters considered quotes are '\'', '\"', and '&lsquo;&rsquo;.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The start of the string containing the next token. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A buffer to store a null-terminated copy of the next token. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>The capacity of the buffer, in characters. If the token is too large to fit, it will be truncated and null-terminated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the end of the token in <code>str</code>. Thus, to retrieve the subsequent token, call this routine again with the prior return value as the new value of <code>str</code>. Returns NULL when the end of <code>str</code> is reached. </dd></dl>

</div>
</div>
<a id="a82f6546fc3e259e64493aeda5a8f1c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f6546fc3e259e64493aeda5a8f1c86">&#9670;&nbsp;</a></span>dr_global_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_global_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates <code>size</code> bytes of memory from DR's global memory pool. This memory is only guaranteed to be aligned to the pointer size: 8 byte alignment for 64-bit; 4-byte alignment for 32-bit. (The wrapped malloc() guarantees the more standard double-pointer-size.) </p>

</div>
</div>
<a id="a32b5d7da931da632140c0e7adcdac75b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b5d7da931da632140c0e7adcdac75b">&#9670;&nbsp;</a></span>dr_global_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_global_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees memory allocated by <a class="el" href="dr__tools_8h.html#a82f6546fc3e259e64493aeda5a8f1c86">dr_global_alloc()</a>. <code>size</code> must be the same as that passed to <a class="el" href="dr__tools_8h.html#a82f6546fc3e259e64493aeda5a8f1c86">dr_global_alloc()</a>. </p>

</div>
</div>
<a id="a75586a7501d994aa4bbd70519b726c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75586a7501d994aa4bbd70519b726c0c">&#9670;&nbsp;</a></span>dr_insert_read_raw_tls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_insert_read_raw_tls </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>tls_register</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tls_offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into ilist prior to "where" instruction(s) to read into the general-purpose full-size register <code>reg</code> from the raw TLS slot with offset <code>tls_offs</code> from the TLS base <code>tls_register</code>. </p>

</div>
</div>
<a id="a802140e02e8ea041cd7ec793160d731f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802140e02e8ea041cd7ec793160d731f">&#9670;&nbsp;</a></span>dr_insert_write_raw_tls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_insert_write_raw_tls </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>tls_register</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tls_offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into ilist prior to "where" instruction(s) to store the value in the general-purpose full-size register <code>reg</code> into the raw TLS slot with offset <code>tls_offs</code> from the TLS base <code>tls_register</code>. </p>

</div>
</div>
<a id="ae2868b3eac7b652ffa561f3f4d15a6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2868b3eac7b652ffa561f3f4d15a6c0">&#9670;&nbsp;</a></span>dr_is_notify_on()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_is_notify_on </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff the -stderr_mask runtime option is non-zero, indicating that the user wants notification messages printed to stderr. </p>

</div>
</div>
<a id="a12f0ea543a114210feefc521b132d69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f0ea543a114210feefc521b132d69b">&#9670;&nbsp;</a></span>dr_is_thread_native()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_is_thread_native </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the thread represented by <code>drcontext</code> is currently executing natively (typically due to an earlier <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a184a564eaa6cee9890f98f8a2d1c9c89">DR_EMIT_GO_NATIVE</a> return value). </p>

</div>
</div>
<a id="ab185c8efca620f8cd0e323164afbc935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab185c8efca620f8cd0e323164afbc935">&#9670;&nbsp;</a></span>dr_is_tracking_where_am_i()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_is_tracking_where_am_i </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether DR is using accurate tracking of the <a class="el" href="dr__tools_8h.html#a9333e0dee46cc854228efab156ce98c5">dr_where_am_i</a> value. Typically this is enabled by calling <a class="el" href="dr__tools_8h.html#ac922731194013612e4f4cb78075a2170">dr_track_where_am_i()</a>. </p>

</div>
</div>
<a id="aeea154f7dd2f1232aaba2e92d0a5cb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea154f7dd2f1232aaba2e92d0a5cb24">&#9670;&nbsp;</a></span>dr_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_log </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes to DR's log file for the thread with drcontext <code>drcontext</code> if the current loglevel is &gt;= <code>level</code> and the current <code>logmask</code> &amp; <code>mask</code> != 0. The mask constants are the DR_LOG_* defines below. Logging is disabled for the release build. If <code>drcontext</code> is NULL, writes to the main log file. </p>

</div>
</div>
<a id="a192497da7670d454f6aae17d293f70b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192497da7670d454f6aae17d293f70b4">&#9670;&nbsp;</a></span>dr_map_executable_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* dr_map_executable_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#ade307e7bb7b7ac46e874097fe62b9fef">dr_map_executable_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *size&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads <code>filename</code> as an executable file for examination, rather than for execution. No entry point, initialization, or constructor code is executed, nor is any thread-local storage or other resources set up. Returns the size (which may include unmappped gaps) in <code>size</code>. The return value of the function is the base address at which the file is mapped.</p>
<dl class="section note"><dt>Note</dt><dd>Not currently supported on Mac OSX. </dd></dl>

</div>
</div>
<a id="ac2885193f264131c620475894e3d1e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2885193f264131c620475894e3d1e1e">&#9670;&nbsp;</a></span>dr_map_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_map_file </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INOUT size_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory-maps <code>size</code> bytes starting at offset <code>offs</code> from the file <code>f</code> at address <code>addr</code> with privileges <code>prot</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The file to map. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>The requested size to map. Upon successful return, contains the actual mapped size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offs</td><td>The offset within the file at which to start the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The requested start address of the map. Unless <code>fixed</code> is true, this is just a hint and may not be honored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prot</td><td>The access privileges of the mapping, composed of the DR_MEMPROT_READ, DR_MEMPROT_WRITE, and DR_MEMPROT_EXEC bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Optional DR_MAP_* flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Mapping image files for execution is not supported.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the start address of the mapping, or NULL if unsuccessful. </dd></dl>

</div>
</div>
<a id="ac63ccc4dc3cd6bec00c673eb73206808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63ccc4dc3cd6bec00c673eb73206808">&#9670;&nbsp;</a></span>dr_mark_safe_to_suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_mark_safe_to_suspend </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this function to mark a region of code as safe for DR to suspend the client while inside the region. DR will not relocate the client from the region and will resume it at precisely the suspend point.</p>
<p>This function must be used in client code that acquires application locks. Use this feature with care! Do not mark code as safe to suspend that has a code cache return point. I.e., do not call this routine from a clean call. For acquiring application locks from a clean call, see <a class="el" href="dr__tools_8h.html#a659d0f08d07d8b969d8f6c998be24848">dr_app_recurlock_lock()</a>.</p>
<p>No DR locks can be held while in a safe region. Consequently, do not call this routine from any DR event callback. It may only be used from natively executing code.</p>
<p>Always invoke this routine in pairs, with the first passing true for <code>enter</code> and the second passing false, thus delimiting the region. </p>

</div>
</div>
<a id="a15aa23aae4a1d322fbe0a1cffedbaf3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15aa23aae4a1d322fbe0a1cffedbaf3a">&#9670;&nbsp;</a></span>dr_mark_trace_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_mark_trace_head </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks the fragment associated with tag <code>tag</code> as a trace head. The fragment need not exist yet &ndash; once it is created it will be marked as a trace head.</p>
<p>DR associates a counter with a trace head and once it passes the -hot_threshold parameter, DR begins building a trace. Before each fragment is added to the trace, DR calls the client's end_trace callback to determine whether to end the trace. (The callback will be called both for standard DR traces and for client-defined traces.)</p>
<dl class="section note"><dt>Note</dt><dd>Some fragments are unsuitable for trace heads. DR will ignore attempts to mark such fragments as trace heads and will return false. If the client marks a fragment that doesn't exist yet as a trace head and DR later determines that the fragment is unsuitable for a trace head it will unmark the fragment as a trace head without notifying the client.</dd>
<dd>
Some fragments' notion of trace heads is dependent on which previous block targets them. For these fragments, calling this routine will only mark as a trace head for targets from the same memory region.</dd></dl>
<p>Returns true if the target fragment is marked as a trace head. </p>

</div>
</div>
<a id="ae52f61049269c0531b66b8c41c69e09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52f61049269c0531b66b8c41c69e09e">&#9670;&nbsp;</a></span>dr_messagebox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_messagebox </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Displays a message in a pop-up window. </p><dl class="section note"><dt>Note</dt><dd>Windows only. </dd>
<dd>
On Windows Vista most Windows services are unable to display message boxes. </dd></dl>

</div>
</div>
<a id="a980febd3b9a673e6f08ace31e4c60a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980febd3b9a673e6f08ace31e4c60a19">&#9670;&nbsp;</a></span>dr_mutex_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_mutex_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a mutex.</p>
<p>Warning: there are restrictions on when DR-provided mutexes, and locks in general, can be held by a client: no lock should be held while application code is executing in the code cache. Locks can be used while inside client code reached from clean calls out of the code cache, but they must be released before returning to the cache. A lock must also be released by the same thread that acquired it. Failing to follow these restrictions can lead to deadlocks. </p>

</div>
</div>
<a id="a8cde6ad421a8cb78ba57c5adb90ff3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cde6ad421a8cb78ba57c5adb90ff3a9">&#9670;&nbsp;</a></span>dr_mutex_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_mutex_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes <code>mutex</code>. </p>

</div>
</div>
<a id="ad6fc5f3252b660fec2538ba2d776ee30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fc5f3252b660fec2538ba2d776ee30">&#9670;&nbsp;</a></span>dr_mutex_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks <code>mutex</code>. Waits until the mutex is successfully held. </p>

</div>
</div>
<a id="a8877efdba9869ab5b8b3b4169c9bc0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8877efdba9869ab5b8b3b4169c9bc0ce">&#9670;&nbsp;</a></span>dr_mutex_mark_as_app()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_mutex_mark_as_app </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs DR to treat this lock as an application lock. Primarily this avoids debug-build checks that no DR locks are held in situations where locks are disallowed.</p>
<dl class="section warning"><dt>Warning</dt><dd>Any one lock should either be a DR lock or an application lock. Use this routine with caution and do not call it on a DR lock that is used in DR contexts, as it disables debug checks.</dd>
<dd>
This routine is not sufficient on its own to prevent deadlocks during scenarios where DR wants to suspend all threads such as detach or relocation. See <a class="el" href="dr__tools_8h.html#a659d0f08d07d8b969d8f6c998be24848">dr_app_recurlock_lock()</a> and <a class="el" href="dr__tools_8h.html#ac63ccc4dc3cd6bec00c673eb73206808">dr_mark_safe_to_suspend()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="aba2f7a49ae4f18a0b1967f962440b914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2f7a49ae4f18a0b1967f962440b914">&#9670;&nbsp;</a></span>dr_mutex_self_owns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_mutex_self_owns </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>mutex</code> is owned by the calling thread. This routine is only available in debug builds. In release builds it always returns true. </p>

</div>
</div>
<a id="ad083ece79f41caa34120d85c82540e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad083ece79f41caa34120d85c82540e7e">&#9670;&nbsp;</a></span>dr_mutex_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_mutex_trylock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries once to lock <code>mutex</code> and returns whether or not successful. </p>

</div>
</div>
<a id="a152f688d562d4cae18ad5790d8f6c4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152f688d562d4cae18ad5790d8f6c4f6">&#9670;&nbsp;</a></span>dr_mutex_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlocks <code>mutex</code>. Asserts that mutex is currently locked by the current thread. </p>

</div>
</div>
<a id="a917384359d5efd538976402ff4b08aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917384359d5efd538976402ff4b08aae">&#9670;&nbsp;</a></span>dr_nonheap_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_nonheap_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>prot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates <code>size</code> bytes of memory as a separate allocation from DR's heap, allowing for separate protection. The <code>prot</code> protection should use the DR_MEMPROT_READ, DR_MEMPROT_WRITE, and DR_MEMPROT_EXEC bits. When creating a region to hold dynamically generated code, use this routine in order to create executable memory. </p>

</div>
</div>
<a id="a901a89de3fa6af0b48351ddea31ece81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901a89de3fa6af0b48351ddea31ece81">&#9670;&nbsp;</a></span>dr_nonheap_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_nonheap_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees memory allocated by <a class="el" href="dr__tools_8h.html#a917384359d5efd538976402ff4b08aae">dr_nonheap_alloc()</a>. <code>size</code> must be the same as that passed to <a class="el" href="dr__tools_8h.html#a917384359d5efd538976402ff4b08aae">dr_nonheap_alloc()</a>. </p>

</div>
</div>
<a id="a8c1399687e4cbc3c0b9bddab3e7619d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1399687e4cbc3c0b9bddab3e7619d3">&#9670;&nbsp;</a></span>dr_open_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API file_t dr_open_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mode_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens the file <code>fname</code>. If no such file exists then one is created. The file access mode is set by the <code>mode_flags</code> argument which is drawn from the DR_FILE_* defines ORed together. Returns INVALID_FILE if unsuccessful.</p>
<p>On Windows, <code>fname</code> is safest as an absolute path (when using Windows system calls directly there is no such thing as a relative path). A relative path passed to this routine will be converted to absolute on a best-effort basis using the current directory that was set at process initialization time. (The most recently set current directory can be retrieved (albeit with no safety guarantees) with <a class="el" href="dr__tools_8h.html#ac3a677a98692a1f11b4f5b0270cf0912">dr_get_current_directory()</a>.) Drive-implied-absolute paths ("\foo.txt") and other-drive-relative paths ("c:foo.txt") are not supported.</p>
<p>On Linux, the file descriptor will be marked as close-on-exec. The DR_FILE_CLOSE_ON_FORK flag can be used to automatically close a file on a fork.</p>
<dl class="section note"><dt>Note</dt><dd>No more then one write mode flag can be specified.</dd>
<dd>
On Linux, DR hides files opened by clients from the application by using file descriptors that are separate from the application's and preventing the application from closing client-opened files. </dd></dl>

</div>
</div>
<a id="a554c5441ac5a4e4de19210562ad8ab90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554c5441ac5a4e4de19210562ad8ab90">&#9670;&nbsp;</a></span>dr_prepopulate_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_prepopulate_cache </td>
          <td>(</td>
          <td class="paramtype">app_pc *&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tags_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intended to be called between <a class="el" href="dr__app_8h.html#abcdedd068a4d264401c31767355ec218">dr_app_setup()</a> and <a class="el" href="dr__app_8h.html#afb7b7aed03dd6f0ed8d48b8a8796e55e">dr_app_start()</a> to pre-create code cache fragments for each basic block address in the <code>tags</code> array. This speeds up the subsequent attach when <a class="el" href="dr__app_8h.html#afb7b7aed03dd6f0ed8d48b8a8796e55e">dr_app_start()</a> is called. If any code in the passed-in tags array is not readable, it is up to the caller to handle any fault, as DR's own signal handlers are not enabled at this point. Returns whether successful. </p>

</div>
</div>
<a id="a25a98f51f66512fcf4611e3b5de68032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a98f51f66512fcf4611e3b5de68032">&#9670;&nbsp;</a></span>dr_prepopulate_indirect_targets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_prepopulate_indirect_targets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#a3d99790cec275b8bad73c09b68279911">dr_indirect_branch_type_t</a>&#160;</td>
          <td class="paramname"><em>branch_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc *&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tags_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intended to augment <a class="el" href="dr__tools_8h.html#a554c5441ac5a4e4de19210562ad8ab90">dr_prepopulate_cache()</a> by populating DR's indirect branch tables, avoiding trips back to the dispatcher during initial execution. This is only effective when one of the the runtime options -shared_trace_ibt_tables and -shared_bb_ibt_tables (depending on whether traces are enabled) is turned on, as this routine does not try to populate tables belonging to threads other than the calling thread.</p>
<p>This is meant to be called between <a class="el" href="dr__app_8h.html#abcdedd068a4d264401c31767355ec218">dr_app_setup()</a> and <a class="el" href="dr__app_8h.html#afb7b7aed03dd6f0ed8d48b8a8796e55e">dr_app_start()</a>, immediately after calling <a class="el" href="dr__tools_8h.html#a554c5441ac5a4e4de19210562ad8ab90">dr_prepopulate_cache()</a>. It adds entries for each target address in the <code>tags</code> array to the indirect branch table for the branch type <code>branch_type</code>.</p>
<p>Returns whether successful. </p>

</div>
</div>
<a id="a5ca7cdf4ffb25d5bb8099dbf69290824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca7cdf4ffb25d5bb8099dbf69290824">&#9670;&nbsp;</a></span>dr_print_instr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_print_instr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints <code>msg</code> followed by the instruction <code>instr</code> to file <code>f</code>. </p>

</div>
</div>
<a id="a3d96533bfee81c79dfd508be5e524b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d96533bfee81c79dfd508be5e524b48">&#9670;&nbsp;</a></span>dr_print_opnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_print_opnd </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>opnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints <code>msg</code> followed by the operand <code>opnd</code> to file <code>f</code>. </p>

</div>
</div>
<a id="aeb88b22ff95c29ae793b9d84e1b95275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb88b22ff95c29ae793b9d84e1b95275">&#9670;&nbsp;</a></span>dr_printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_printf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stdout printing that won't interfere with the application's own printing. It is not buffered, which means that it should not be used for very frequent, small print amounts: for that the client should either do its own buffering or it should use printf from the C library via DR's private loader. </p><dl class="section note"><dt>Note</dt><dd>On Windows 7 and earlier, this routine is not able to print to the <code>cmd</code> window unless <a class="el" href="dr__tools_8h.html#ab870ad4d34833368e16bd3f6e07ba624">dr_enable_console_printing()</a> is called ahead of time, and even then there are limitations: see <a class="el" href="dr__tools_8h.html#ab870ad4d34833368e16bd3f6e07ba624">dr_enable_console_printing()</a>. </dd>
<dd>
This routine supports printing wide characters via the ls or S format specifiers. On Windows, they are assumed to be UTF-16, and are converted to UTF-8. On Linux, they are converted by simply dropping the high-order bytes. </dd>
<dd>
If the data to be printed is large it will be truncated to an internal buffer size. Use <a class="el" href="dr__tools_8h.html#a07fe87f7bf9560a45751064329bc8c12">dr_snprintf()</a> and <a class="el" href="dr__tools_8h.html#a451ff3e57783acbfdf24c1e557145807">dr_write_file()</a> for large output. </dd>
<dd>
When printing floating-point values on x86, the caller's code should use <a class="el" href="dr__proc_8h.html#a48ca3205c37d6e41d007ac54a1d60e6a">proc_save_fpstate()</a> or be inside a clean call that has requested to preserve the floating-point state, unless it can prove that its compiler will not use x87 operations. </dd></dl>

</div>
</div>
<a id="ab10936426ba45ea96761adc6d9f9d290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10936426ba45ea96761adc6d9f9d290">&#9670;&nbsp;</a></span>dr_raw_brk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_raw_brk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>new_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the program break to the specified value. Invokes the SYS_brk system call and returns the result. This is the application's program break, so use this system call only when deliberately changing the application's behavior. </p><dl class="section note"><dt>Note</dt><dd>Linux-only. </dd></dl>

</div>
</div>
<a id="a2a5b61c462fe7d4c5f5b78f76a6eedce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5b61c462fe7d4c5f5b78f76a6eedce">&#9670;&nbsp;</a></span>dr_raw_mem_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_raw_mem_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>This raw memory allocation interface is in flux and is subject to change in the next release. Consider it experimental in this release.</dd></dl>
<p>Allocates <code>size</code> bytes (page size aligned) of memory as a separate allocation at preferred base <code>addr</code> that must be page size aligned, allowing for separate protection. If <code>addr</code> is NULL, an arbitrary address is picked.</p>
<p>The <code>prot</code> protection should use the DR_MEMPROT_READ, DR_MEMPROT_WRITE, and DR_MEMPROT_EXEC bits. The allocated memory is not considered to be DynamoRIO or tool memory and thus is not kept separate from the application. Use of this memory is at the client's own risk.</p>
<p>The resulting memory is guaranteed to be initialized to all zeroes.</p>
<p>Returns the actual address allocated or NULL if memory allocation at preferred base fails. </p>

</div>
</div>
<a id="aee58c732aec96032bcd5344104ef626c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee58c732aec96032bcd5344104ef626c">&#9670;&nbsp;</a></span>dr_raw_mem_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_raw_mem_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees memory allocated by <a class="el" href="dr__tools_8h.html#a2a5b61c462fe7d4c5f5b78f76a6eedce">dr_raw_mem_alloc()</a>. <code>addr</code> and <code>size</code> must be the same as that passed to <a class="el" href="dr__tools_8h.html#a2a5b61c462fe7d4c5f5b78f76a6eedce">dr_raw_mem_alloc()</a> on Windows. </p>

</div>
</div>
<a id="a57c490f6719db1753260799c3a435324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c490f6719db1753260799c3a435324">&#9670;&nbsp;</a></span>dr_raw_mremap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_raw_mremap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>old_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>old_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>new_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls mremap with the specified parameters and returns the result. The old memory must be non-DR memory, and the new memory is also considered to be non-DR memory (see <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211aa0d11211c580eb6b368d07cb7546e376">DR_ALLOC_NON_DR</a>). </p><dl class="section note"><dt>Note</dt><dd>Linux-only. </dd></dl>

</div>
</div>
<a id="ac5d2a2ccd58268f84c379a38bc4aa399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d2a2ccd58268f84c379a38bc4aa399">&#9670;&nbsp;</a></span>dr_raw_tls_calloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_raw_tls_calloc </td>
          <td>(</td>
          <td class="paramtype">OUT <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> *&#160;</td>
          <td class="paramname"><em>tls_register</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN uint&#160;</td>
          <td class="paramname"><em>num_slots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN uint&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates <code>num_slots</code> contiguous thread-local storage (TLS) slots that can be directly accessed via an offset from <code>tls_register</code>. If <code>alignment</code> is non-zero, the slots will be aligned to <code>alignment</code>. These slots will be initialized to 0 for each new thread. The slot offsets are [<code>offset</code> .. <code>offset</code> + (num_slots - 1)]. These slots are disjoint from the <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> register spill slots and the client tls field (<a class="el" href="dr__tools_8h.html#aaa04a14c2cbf783b4926c2fd14445f82">dr_get_tls_field()</a>). Returns whether or not the slots were successfully obtained. The linear address of the TLS base pointed at by <code>tls_register</code> can be obtained using <a class="el" href="dr__tools_8h.html#a88d91064ffa84c097c84694d78a2ad22">dr_get_dr_segment_base</a>. Raw TLs slots can be read directly using <a class="el" href="dr__tools_8h.html#a75586a7501d994aa4bbd70519b726c0c">dr_insert_read_raw_tls()</a> and written using <a class="el" href="dr__tools_8h.html#a802140e02e8ea041cd7ec793160d731f">dr_insert_write_raw_tls()</a>.</p>
<p>Supports passing 0 for <code>num_slots</code>, in which case <code>tls_register</code> will be written but no other action taken.</p>
<dl class="section note"><dt>Note</dt><dd>These slots are useful for thread-shared code caches. With thread-private caches, DR's memory pools are guaranteed to be reachable via absolute or rip-relative accesses from the code cache and client libraries.</dd>
<dd>
These slots are a limited resource. On Windows the slots are shared with the application and reserving even one slot can result in failure to initialize for certain applications. On Linux they are more plentiful and transparent but currently DR limits clients to no more than 64 slots.</dd>
<dd>
On Mac OS, TLS slots may not be initialized to zero. </dd></dl>

</div>
</div>
<a id="ad2162f0dbd52d784c1fbfe8ac75cf6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2162f0dbd52d784c1fbfe8ac75cf6ec">&#9670;&nbsp;</a></span>dr_raw_tls_cfree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_raw_tls_cfree </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_slots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees <code>num_slots</code> raw thread-local storage slots starting at offset <code>offset</code> that were allocated with <a class="el" href="dr__tools_8h.html#ac5d2a2ccd58268f84c379a38bc4aa399">dr_raw_tls_calloc()</a>. Returns whether or not the slots were successfully freed. </p>

</div>
</div>
<a id="a6b8cdf29035914846c03c4409a3f8fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8cdf29035914846c03c4409a3f8fcf">&#9670;&nbsp;</a></span>dr_raw_tls_opnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API <a class="el" href="structopnd__t.html">opnd_t</a> dr_raw_tls_opnd </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>tls_register</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tls_offs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an operand that refers to the raw TLS slot with offset <code>tls_offs</code> from the TLS base <code>tls_register</code>. </p>

</div>
</div>
<a id="ac9600abc55b7ed7e283e6d8a9dee1ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9600abc55b7ed7e283e6d8a9dee1ecc">&#9670;&nbsp;</a></span>dr_read_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API ssize_t dr_read_file </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads up to <code>count</code> bytes from file <code>f</code> into <code>buf</code>. Returns the actual number read. </p>

</div>
</div>
<a id="a7456664ac3877b03bc5bffbf4306defe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7456664ac3877b03bc5bffbf4306defe">&#9670;&nbsp;</a></span>dr_recurlock_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_recurlock_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and initializes a recursive lock. A recursive lock allows the same thread to acquire it multiple times. The lock restrictions for mutexes apply (see <a class="el" href="dr__tools_8h.html#a980febd3b9a673e6f08ace31e4c60a19">dr_mutex_create()</a>). </p>

</div>
</div>
<a id="aea4d574fe9cd0bc7ee374e6f5af79b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4d574fe9cd0bc7ee374e6f5af79b05">&#9670;&nbsp;</a></span>dr_recurlock_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_recurlock_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reclock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes <code>reclock</code>. </p>

</div>
</div>
<a id="ae684e67432a0c4c28c906d00eea8b4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae684e67432a0c4c28c906d00eea8b4a7">&#9670;&nbsp;</a></span>dr_recurlock_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_recurlock_lock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reclock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires <code>reclock</code>, or increments the ownership count if already owned. </p>

</div>
</div>
<a id="a9f5e7b4ab67d258d69d860c18e937468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5e7b4ab67d258d69d860c18e937468">&#9670;&nbsp;</a></span>dr_recurlock_mark_as_app()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_recurlock_mark_as_app </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reclock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs DR to treat this lock as an application lock. Primarily this avoids debug-build checks that no DR locks are held in situations where locks are disallowed.</p>
<dl class="section warning"><dt>Warning</dt><dd>Any one lock should either be a DR lock or an application lock. Use this routine with caution and do not call it on a DR lock that is used in DR contexts, as it disables debug checks.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="a7ab3068aa33b43aa0b8ba555d72cc6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab3068aa33b43aa0b8ba555d72cc6fd">&#9670;&nbsp;</a></span>dr_recurlock_self_owns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_recurlock_self_owns </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reclock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the calling thread owns <code>reclock</code>. </p>

</div>
</div>
<a id="a9ef68229d49e8527f794de2ee8d9095e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef68229d49e8527f794de2ee8d9095e">&#9670;&nbsp;</a></span>dr_recurlock_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_recurlock_trylock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reclock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries once to acquire <code>reclock</code> and returns whether successful. </p>

</div>
</div>
<a id="ac07e3d46607424a51065f6e8fb08e60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07e3d46607424a51065f6e8fb08e60d">&#9670;&nbsp;</a></span>dr_recurlock_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_recurlock_unlock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reclock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrements the ownership count of <code>reclock</code> and releases if zero. </p>

</div>
</div>
<a id="afdbb2913daa5c083cf9881b5d500513e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbb2913daa5c083cf9881b5d500513e">&#9670;&nbsp;</a></span>dr_rename_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_rename_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renames the file <code>src</code> to <code>dst</code>, replacing an existing file named <code>dst</code> if <code>replace</code> is true. Atomic if <code>src</code> and <code>dst</code> are on the same filesystem. Returns true if successful. </p>

</div>
</div>
<a id="a3c602c9d795079655bc599550cb4492b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c602c9d795079655bc599550cb4492b">&#9670;&nbsp;</a></span>dr_replace_fragment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_replace_fragment </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the fragment with tag <code>tag</code> with the instructions in <code>ilist</code>. This routine is only valid with the -thread_private option; it replaces the fragment for the current thread only. After replacement, the existing fragment is allowed to complete if currently executing. For example, a clean call replacing the currently executing fragment will safely return to the existing code. Subsequent executions will use the new instructions.</p>
<dl class="section note"><dt>Note</dt><dd>The routine takes control of <code>ilist</code> and all responsibility for deleting it. The client should not keep, use, or reference, the instrlist or any of the instrs it contains after passing.</dd>
<dd>
This routine supports replacement for the current thread only. <code>drcontext</code> must be from the current thread and must be the drcontext used to create the instruction list. This routine may not be called from the thread exit event.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if the fragment does not exist and true otherwise. </dd></dl>

</div>
</div>
<a id="a558ef634eff90b0e777cddb73983617a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558ef634eff90b0e777cddb73983617a">&#9670;&nbsp;</a></span>dr_request_synchronized_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_request_synchronized_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="dr__events_8h.html#a02752a5882342ab163cb666b6ec3cf44">dr_set_process_exit_behavior()</a> </dd></dl>

</div>
</div>
<a id="a5842900d62c160ea7f0e99c0eee77bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5842900d62c160ea7f0e99c0eee77bb0">&#9670;&nbsp;</a></span>dr_resume_all_other_threads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_resume_all_other_threads </td>
          <td>(</td>
          <td class="paramtype">IN void **&#160;</td>
          <td class="paramname"><em>drcontexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN uint&#160;</td>
          <td class="paramname"><em>num_suspended</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>May only be used after invoking <a class="el" href="dr__tools_8h.html#ae4eaefda11c27210a72df6d24f72871f">dr_suspend_all_other_threads()</a>. This routine resumes the threads that were suspended by <a class="el" href="dr__tools_8h.html#ae4eaefda11c27210a72df6d24f72871f">dr_suspend_all_other_threads()</a> and must be passed the same array and count of suspended threads that were returned by <a class="el" href="dr__tools_8h.html#ae4eaefda11c27210a72df6d24f72871f">dr_suspend_all_other_threads()</a>. It also frees the <code>drcontexts</code> array and releases the locks acquired by <a class="el" href="dr__tools_8h.html#ae4eaefda11c27210a72df6d24f72871f">dr_suspend_all_other_threads()</a>. The return value indicates whether all resumption attempts were successful. </p>

</div>
</div>
<a id="a69e371d4c7d897bf24c8a558b86a4c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e371d4c7d897bf24c8a558b86a4c69">&#9670;&nbsp;</a></span>dr_retakeover_suspended_native_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_retakeover_suspended_native_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the thread owning <code>drcontext</code> to begin executing in the code cache again once it is resumed. The thread must currently be suspended (typically by <a class="el" href="dr__tools_8h.html#a566d8b7214afc621019c8f0048a094b0">dr_suspend_all_other_threads_ex()</a> with <a class="el" href="dr__tools_8h.html#a66bef18f8eabc7a8b8b0368e8a96d179a21ba834e13979aa7ad97fd13c69b3ae4">DR_SUSPEND_NATIVE</a>) and must be currently native (typically from <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a184a564eaa6cee9890f98f8a2d1c9c89">DR_EMIT_GO_NATIVE</a>). </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="a25c352ae7d61d62b2ebd13174e2f50bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c352ae7d61d62b2ebd13174e2f50bd">&#9670;&nbsp;</a></span>dr_rwlock_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_rwlock_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and initializes a read-write lock. A read-write lock allows multiple readers or alternatively a single writer. The lock restrictions for mutexes apply (see <a class="el" href="dr__tools_8h.html#a980febd3b9a673e6f08ace31e4c60a19">dr_mutex_create()</a>). </p>

</div>
</div>
<a id="ad2165aca91ac2de155d98c709436819f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2165aca91ac2de155d98c709436819f">&#9670;&nbsp;</a></span>dr_rwlock_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_rwlock_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes <code>rwlock</code>. </p>

</div>
</div>
<a id="a2c95bd55446ba4232ca591233200f275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c95bd55446ba4232ca591233200f275">&#9670;&nbsp;</a></span>dr_rwlock_mark_as_app()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_rwlock_mark_as_app </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs DR to treat this lock as an application lock. Primarily this avoids debug-build checks that no DR locks are held in situations where locks are disallowed.</p>
<dl class="section warning"><dt>Warning</dt><dd>Any one lock should either be a DR lock or an application lock. Use this routine with caution and do not call it on a DR lock that is used in DR contexts, as it disables debug checks.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="acb1e9b10eb1f5ef4c6f47940bb48ff15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1e9b10eb1f5ef4c6f47940bb48ff15">&#9670;&nbsp;</a></span>dr_rwlock_read_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_rwlock_read_lock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires a read lock on <code>rwlock</code>. </p>

</div>
</div>
<a id="aa537f5e2153f2ecb20e96bff9d7f0027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa537f5e2153f2ecb20e96bff9d7f0027">&#9670;&nbsp;</a></span>dr_rwlock_read_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_rwlock_read_unlock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a read lock on <code>rwlock</code>. </p>

</div>
</div>
<a id="a89f3399a345c699db539b9dd7a605aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f3399a345c699db539b9dd7a605aaa">&#9670;&nbsp;</a></span>dr_rwlock_self_owns_write_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_rwlock_self_owns_write_lock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the calling thread owns the write lock on <code>rwlock</code>. </p>

</div>
</div>
<a id="a453d03325d2d6b8bec94e53b5c69c03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453d03325d2d6b8bec94e53b5c69c03c">&#9670;&nbsp;</a></span>dr_rwlock_write_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_rwlock_write_lock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires a write lock on <code>rwlock</code>. </p>

</div>
</div>
<a id="aabfc6f62eaf08a4dbe805206cb51e48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfc6f62eaf08a4dbe805206cb51e48e">&#9670;&nbsp;</a></span>dr_rwlock_write_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_rwlock_write_trylock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries once to acquire a write lock on <code>rwlock</code> and returns whether successful. </p>

</div>
</div>
<a id="a819a63fb829fb0fc74a4041965e50079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819a63fb829fb0fc74a4041965e50079">&#9670;&nbsp;</a></span>dr_rwlock_write_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_rwlock_write_unlock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a write lock on <code>rwlock</code>. </p>

</div>
</div>
<a id="a0b0ac44591b6687a3b4b7b233c4140f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0ac44591b6687a3b4b7b233c4140f8">&#9670;&nbsp;</a></span>dr_set_client_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_set_client_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>report_URL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets information presented to users in diagnostic messages. Only one name is supported, regardless of how many clients are in use. If this routine is called a second time, the new values supersede the original. The <code>report_URL</code> is meant to be a bug tracker location where users should go to report errors in the client end-user tool. </p>

</div>
</div>
<a id="affcf6af90fe6ca56168cd56ba09fea08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcf6af90fe6ca56168cd56ba09fea08">&#9670;&nbsp;</a></span>dr_set_client_version_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_set_client_version_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the version string presented to users in diagnostic messages. This has a maximum length of 96 characters; anything beyond that is silently truncated. </p>

</div>
</div>
<a id="ac74de1da117d9c807b986aeda2523dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74de1da117d9c807b986aeda2523dd9">&#9670;&nbsp;</a></span>dr_set_itimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_set_itimer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>millisec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *drcontext, <a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *mcontext)&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Installs an interval timer in the itimer sharing group that contains the calling thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">which</td><td>Must be one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">millisec</td><td>The frequency of the timer, in milliseconds. Passing 0 disables the timer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function that will be called each time the timer fires. It will be passed the context of the thread that received the itimer signal and its machine context, which has not been translated and so may contain raw code cache values. The function will be called from a signal handler that may have interrupted a lock holder or other critical code, so it must be careful in its operations: keep it as simple as possible, and avoid any non-reentrant actions such as lock usage. If a general timer that does not interrupt client code is required, the client should create a separate thread via <a class="el" href="dr__tools_8h.html#aca9bc4918a9b5facc7f44cf6a9e8bdca">dr_create_client_thread()</a> (which is guaranteed to have a private itimer) and set the itimer there, where the callback function can perform more operations safely if that new thread never acquires locks in its normal operation.</td></tr>
  </table>
  </dd>
</dl>
<p>Itimer sharing varies by kernel. Prior to 2.6.12 itimers were thread-private; after 2.6.12 they are shared across a thread group, though there could be multiple thread groups in one address space. The <a class="el" href="dr__tools_8h.html#a5d2f1d0559603dc203351d9b8da0e216">dr_get_itimer()</a> function can be used to see whether a thread already has an itimer in its group to avoid re-setting an itimer set by an earlier thread. A client thread created by <a class="el" href="dr__tools_8h.html#aca9bc4918a9b5facc7f44cf6a9e8bdca">dr_create_client_thread()</a> is guaranteed to not share its itimers with application threads.</p>
<p>The itimer will operate successfully in the presence of an application itimer of the same type.</p>
<p>Additional itimer signals are blocked while in our signal handler.</p>
<p>The return value indicates whether the timer was successfully installed (or uninstalled if 0 was passed for <code>millisec</code>).</p>
<dl class="section note"><dt>Note</dt><dd>Linux-only. </dd></dl>

</div>
</div>
<a id="aebc774dc54b77dcd8505277e6bc66722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc774dc54b77dcd8505277e6bc66722">&#9670;&nbsp;</a></span>dr_set_random_seed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_set_random_seed </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the seed used for <a class="el" href="dr__tools_8h.html#a036726345f9ea686b7eae46eca38e5e3">dr_get_random_value()</a>. Generally this would only be called during client initialization. </p>

</div>
</div>
<a id="a534b38808801da50be64b9f0e6c8616f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534b38808801da50be64b9f0e6c8616f">&#9670;&nbsp;</a></span>dr_set_tls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_set_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the user-controlled thread-local-storage field. To generate an instruction sequence that reads the drcontext field inline in the code cache, use <a class="el" href="dr__ir__utils_8h.html#a06b5104ef0d55577cee0f66bd9a0051f">dr_insert_write_tls_field()</a>. </p>

</div>
</div>
<a id="aac428021a331be838eca5a0ef19989bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac428021a331be838eca5a0ef19989bd">&#9670;&nbsp;</a></span>dr_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_sleep </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Current thread sleeps for <code>time_ms</code> milliseconds. </p>

</div>
</div>
<a id="a07fe87f7bf9560a45751064329bc8c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07fe87f7bf9560a45751064329bc8c12">&#9670;&nbsp;</a></span>dr_snprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int dr_snprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility routine to print a formatted message to a string. Will not print more than max characters. If successful, returns the number of characters printed, not including the terminating null character. If the number of characters to write equals max, then the caller is responsible for supplying a terminating null character. If the number of characters to write exceeds max, then max characters are written and -1 is returned. If an error occurs, a negative value is returned. </p><dl class="section note"><dt>Note</dt><dd>This routine supports printing wide characters via the ls or S format specifiers. On Windows, they are assumed to be UTF-16, and are converted to UTF-8. On Linux, they are converted by simply dropping the high-order bytes. </dd>
<dd>
When printing floating-point values, the caller's code should use <a class="el" href="dr__proc_8h.html#a48ca3205c37d6e41d007ac54a1d60e6a">proc_save_fpstate()</a> or be inside a clean call that has requested to preserve the floating-point state, unless it can prove that its compiler will not use x87 operations.. </dd></dl>

</div>
</div>
<a id="a6dca11e2920892d292405c49695d4890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dca11e2920892d292405c49695d4890">&#9670;&nbsp;</a></span>dr_snwprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int dr_snwprintf </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wide character version of <a class="el" href="dr__tools_8h.html#a07fe87f7bf9560a45751064329bc8c12">dr_snprintf()</a>. All of the comments for <a class="el" href="dr__tools_8h.html#a07fe87f7bf9560a45751064329bc8c12">dr_snprintf()</a> apply, except for the hs or S format specifiers. On Windows, these will assume that the input is UTF-8, and will convert to UTF-16. On Linux, they will widen a single-byte character string into a wchar_t character string with zero as the high-order bytes. </p>

</div>
</div>
<a id="accb0b327ed9babc47922984b7adfed8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb0b327ed9babc47922984b7adfed8b">&#9670;&nbsp;</a></span>dr_sscanf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int dr_sscanf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility routine to parse strings that match a pre-defined format string, similar to the sscanf() C routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>String to parse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Format string controlling parsing. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">...</td><td>All remaining parameters interpreted as output parameter pointers. The type of each parameter must match the type implied by the corresponding format specifier in <code>fmt</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of specifiers matched.</dd></dl>
<p>The benefit of using <a class="el" href="dr__tools_8h.html#accb0b327ed9babc47922984b7adfed8b">dr_sscanf()</a> over native sscanf() is that DR's implementation is standalone, signal-safe, and cross-platform. On Linux, sscanf() has been observed to call malloc(). On Windows, sscanf() will call strlen(), which can break when using mapped files.</p>
<p>The behavior of <a class="el" href="dr__tools_8h.html#accb0b327ed9babc47922984b7adfed8b">dr_sscanf()</a> is mostly identical to that of the sscanf() C routine.</p>
<p>Supported format specifiers:</p><ul>
<li>%s: Matches a sequence of non-whitespace characters. The string is copied into the provided output buffer. To avoid buffer overflow, the caller should use a width specifier.</li>
<li>%c: Matches any single character.</li>
<li>%d: Matches a signed decimal integer.</li>
<li>%u: Matches an unsigned decimal integer.</li>
<li>%x: Matches an unsigned hexadecimal integer, with or without a leading 0x.</li>
<li>%p: Matches a pointer-sized hexadecimal integer as x does.</li>
<li>%%: Matches a literal % character. Does not store output.</li>
</ul>
<p>Supported format modifiers:</p><ul>
<li>*: The * modifier causes the scan to match the specifier, but not store any output. No output parameter is consumed for this specifier, and one should not be passed.</li>
<li>0-9: A decimal integer preceding the specifier gives the width to match. For strings, this indicates the maximum number of characters to copy. For integers, this indicates the maximum number of digits to parse.</li>
<li>h: Marks an integer specifier as short.</li>
<li>l: Marks an integer specifier as long.</li>
<li>ll: Marks an integer specifier as long long. Use this for 64-bit integers.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="dr__tools_8h.html#accb0b327ed9babc47922984b7adfed8b">dr_sscanf()</a> does <em>not</em> support parsing floating point numbers yet. </dd></dl>

</div>
</div>
<a id="a407fa7ac15e482174d2ff75dcc312192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407fa7ac15e482174d2ff75dcc312192">&#9670;&nbsp;</a></span>dr_standalone_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_standalone_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restores application state modified by <a class="el" href="dr__tools_8h.html#a0917d634fe88c7d368eb6a20c17c55cb">dr_standalone_init()</a>, which can include some signal handlers. </p>

</div>
</div>
<a id="a0917d634fe88c7d368eb6a20c17c55cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0917d634fe88c7d368eb6a20c17c55cb">&#9670;&nbsp;</a></span>dr_standalone_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_standalone_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a DR context that can be used in a standalone program. </p><dl class="section warning"><dt>Warning</dt><dd>This context cannot be used as the drcontext for a thread running under DR control! It is only for standalone programs that wish to use DR as a library of disassembly, etc. routines. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on failure, such as running on an unsupported operating system version. </dd></dl>

</div>
</div>
<a id="ae4eaefda11c27210a72df6d24f72871f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4eaefda11c27210a72df6d24f72871f">&#9670;&nbsp;</a></span>dr_suspend_all_other_threads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_suspend_all_other_threads </td>
          <td>(</td>
          <td class="paramtype">OUT void ***&#160;</td>
          <td class="paramname"><em>drcontexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&#160;</td>
          <td class="paramname"><em>num_suspended</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&#160;</td>
          <td class="paramname"><em>num_unsuspended</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a566d8b7214afc621019c8f0048a094b0">dr_suspend_all_other_threads_ex()</a> with <code>flags</code> set to 0. </p>

</div>
</div>
<a id="a566d8b7214afc621019c8f0048a094b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566d8b7214afc621019c8f0048a094b0">&#9670;&nbsp;</a></span>dr_suspend_all_other_threads_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_suspend_all_other_threads_ex </td>
          <td>(</td>
          <td class="paramtype">OUT void ***&#160;</td>
          <td class="paramname"><em>drcontexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&#160;</td>
          <td class="paramname"><em>num_suspended</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&#160;</td>
          <td class="paramname"><em>num_unsuspended</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#a66bef18f8eabc7a8b8b0368e8a96d179">dr_suspend_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suspends all other threads in the process and returns an array of contexts in <code>drcontexts</code> with one context per successfully suspended thread. The contexts can be passed to routines like <a class="el" href="dr__tools_8h.html#a56eae1c5bac30a5336a99c5d91d5a10c">dr_get_thread_id()</a> or <a class="el" href="dr__ir__utils_8h.html#a9e348b2596b8750ce3fad234ab022ced">dr_get_mcontext()</a>. However, the contexts may not be modified: <a class="el" href="dr__ir__utils_8h.html#ac4bfa7fc3f9d4adb0857675bec2712a2">dr_set_mcontext()</a> is not supported. <a class="el" href="dr__ir__utils_8h.html#a9e348b2596b8750ce3fad234ab022ced">dr_get_mcontext()</a> can be called on the caller of this routine, unless in a Windows nudge callback.</p>
<p>The <code>flags</code> argument controls which threads are suspended and may add further options in the future.</p>
<p>The number of successfully suspended threads, which is also the length of the <code>drcontexts</code> array, is returned in <code>num_suspended</code>, which is a required parameter. The number of un-successfully suspended threads, if any, is returned in the optional parameter <code>num_unsuspended</code>. The calling thread is not considered in either count. DR can fail to suspend a thread for privilege reasons (e.g., on Windows in a low-privilege process where another process injected a thread). This function returns true iff all threads were suspended, in which case <code>num_unsuspended</code> will be 0.</p>
<p>The caller must invoke <a class="el" href="dr__tools_8h.html#a5842900d62c160ea7f0e99c0eee77bb0">dr_resume_all_other_threads()</a> in order to resume the suspended threads, free the <code>drcontexts</code> array, and release coarse-grain locks that prevent new threads from being created.</p>
<p>This routine may not be called from any registered event callback other than the nudge event or the pre- or post-system call event. It may be called from clean calls out of the cache. This routine may not be called while any locks are held that could block a thread processing a registered event callback or cache callout.</p>
<dl class="section note"><dt>Note</dt><dd>A client wishing to invoke this routine from an event callback can queue up a nudge via <a class="el" href="dr__events_8h.html#a77b1a5319fb74fad6115f62393384380">dr_nudge_client()</a> and invoke this routine from the nudge callback. </dd></dl>

</div>
</div>
<a id="ae3912ab20d9a86a19627f3634a3a2f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3912ab20d9a86a19627f3634a3a2f3d">&#9670;&nbsp;</a></span>dr_syscall_get_param()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API reg_t dr_syscall_get_param </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>param_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#a80d0f026def74d903a83fb6122816ae2">dr_register_pre_syscall_event()</a>) event. Returns the value of system call parameter number <code>param_num</code>.</p>
<p>It is up to the caller to ensure that reading this parameter is safe: this routine does not know the number of parameters for each system call, nor does it check whether this might read off the base of the stack.</p>
<dl class="section note"><dt>Note</dt><dd>On some platforms, notably MacOS, a 32-bit application's system call can still take a 64-bit parameter (typically on the stack). In that situation, this routine will consider the 64-bit parameter to be split into high and low parts, each with its own parameter number. </dd></dl>

</div>
</div>
<a id="a16f09772f0185557445cb46647268fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f09772f0185557445cb46647268fa8">&#9670;&nbsp;</a></span>dr_syscall_get_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API reg_t dr_syscall_get_result </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a post-syscall (<a class="el" href="dr__events_8h.html#a7a62b6c11f3b0ae2fe7773189f6e4826">dr_register_post_syscall_event()</a>) event. Returns the return value of the system call that will be presented to the application.</p>
<dl class="section note"><dt>Note</dt><dd>On some platforms (such as MacOS), a 32-bit application's system call can return a 64-bit value. Use <a class="el" href="dr__tools_8h.html#ad2906dcd1979be92605bdf3c58c9f373">dr_syscall_get_result_ex()</a> to obtain the upper bits in that case.</dd>
<dd>
On some platforms (such as MacOS), whether a system call succeeded or failed cannot be determined from the main result value. Use <a class="el" href="dr__tools_8h.html#ad2906dcd1979be92605bdf3c58c9f373">dr_syscall_get_result_ex()</a> to obtain the success result in such cases. </dd></dl>

</div>
</div>
<a id="ad2906dcd1979be92605bdf3c58c9f373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2906dcd1979be92605bdf3c58c9f373">&#9670;&nbsp;</a></span>dr_syscall_get_result_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_syscall_get_result_ex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#afc574aa98b0e727a9b75059c4966eb10">dr_syscall_result_info_t</a> *info&#160;</td>
          <td class="paramname"><em>INOUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a post-syscall (<a class="el" href="dr__events_8h.html#a7a62b6c11f3b0ae2fe7773189f6e4826">dr_register_post_syscall_event()</a>) event. Returns whether it successfully retrieved the results of the system call into <code>info</code>.</p>
<p>The caller should set the <code>size</code>, <code>use_high</code>, and <code>use_errno</code> fields of <code>info</code> prior to calling this routine. See the fields of <a class="el" href="dr__tools_8h.html#afc574aa98b0e727a9b75059c4966eb10">dr_syscall_result_info_t</a> for details. </p>

</div>
</div>
<a id="a582dafe48f9bb894d23ba274913014fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582dafe48f9bb894d23ba274913014fb">&#9670;&nbsp;</a></span>dr_syscall_intercept_natively()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_syscall_intercept_natively </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sysnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wow64_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Must be invoked from <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a>. Requests that the named ntoskrnl system call be intercepted even when threads are native (e.g., due to <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a184a564eaa6cee9890f98f8a2d1c9c89">DR_EMIT_GO_NATIVE</a>). Only a limited number of system calls being intercepted while native are supported. This routine will fail once that limit is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The system call name. The name must match an exported system call wrapper in <code>ntdll.dll</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sysnum</td><td>The system call number (the value placed in the eax register). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_args</td><td>The number of arguments to the system call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wow64_index</td><td>The value placed in the ecx register when this system call is executed in a WOW64 process. This value should be obtainable by examining the system call wrapper.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>

</div>
</div>
<a id="aedb494e753b1a2f0e79cb4bd09700c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb494e753b1a2f0e79cb4bd09700c3c">&#9670;&nbsp;</a></span>dr_syscall_invoke_another()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_syscall_invoke_another </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a post-syscall (<a class="el" href="dr__events_8h.html#a7a62b6c11f3b0ae2fe7773189f6e4826">dr_register_post_syscall_event()</a>) event. An additional system call will be invoked immediately, using the current values of the parameters, which can be set with <a class="el" href="dr__tools_8h.html#a2ba5b83fedf0082d4170c3caaf2224a9">dr_syscall_set_param()</a>. The system call to be invoked should be specified with <a class="el" href="dr__tools_8h.html#ae66c42a269f48b13ed57609029e5202b">dr_syscall_set_sysnum()</a>.</p>
<p>Use this routine with caution. Especially on Windows, care must be taken if the application is expected to continue afterward. When system call parameters are stored on the stack, modifying them can result in incorrect application behavior, particularly when setting more parameters than were present in the original system call, which will result in corruption of the application stack.</p>
<p>On Windows, when the first system call is interruptible (alertable), the additional system call may be delayed.</p>
<p>DR will set key registers such as r10 for 64-bit or xdx for sysenter or WOW64 system calls. However, DR will not set ecx for WOW64; that is up to the client. </p>

</div>
</div>
<a id="a2ba5b83fedf0082d4170c3caaf2224a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba5b83fedf0082d4170c3caaf2224a9">&#9670;&nbsp;</a></span>dr_syscall_set_param()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_syscall_set_param </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>param_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#a80d0f026def74d903a83fb6122816ae2">dr_register_pre_syscall_event()</a>) event, or from a post-syscall (<a class="el" href="dr__events_8h.html#a7a62b6c11f3b0ae2fe7773189f6e4826">dr_register_post_syscall_event()</a>) event when also using <a class="el" href="dr__tools_8h.html#aedb494e753b1a2f0e79cb4bd09700c3c">dr_syscall_invoke_another()</a>. Sets the value of system call parameter number <code>param_num</code> to <code>new_value</code>.</p>
<p>It is up to the caller to ensure that writing this parameter is safe: this routine does not know the number of parameters for each system call, nor does it check whether this might write beyond the base of the stack.</p>
<dl class="section note"><dt>Note</dt><dd>On some platforms, notably MacOS, a 32-bit application's system call can still take a 64-bit parameter (typically on the stack). In that situation, this routine will consider the 64-bit parameter to be split into high and low parts, each with its own parameter number. </dd></dl>

</div>
</div>
<a id="a2d20c65a63ebb1a2081b3152d9d4647d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d20c65a63ebb1a2081b3152d9d4647d">&#9670;&nbsp;</a></span>dr_syscall_set_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_syscall_set_result </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#a80d0f026def74d903a83fb6122816ae2">dr_register_pre_syscall_event()</a>) or post-syscall (<a class="el" href="dr__events_8h.html#a7a62b6c11f3b0ae2fe7773189f6e4826">dr_register_post_syscall_event()</a>) event. For pre-syscall, should only be used when skipping the system call. This sets the return value of the system call that the application sees to <code>value</code>.</p>
<dl class="section note"><dt>Note</dt><dd>On MacOS, do not use this function as it fails to set the carry flag and thus fails to properly indicate whether the system call succeeded or failed: use <a class="el" href="dr__tools_8h.html#a70710f3b42a9797a72ffb51f46720849">dr_syscall_set_result_ex()</a> instead. </dd></dl>

</div>
</div>
<a id="a70710f3b42a9797a72ffb51f46720849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70710f3b42a9797a72ffb51f46720849">&#9670;&nbsp;</a></span>dr_syscall_set_result_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_syscall_set_result_ex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#afc574aa98b0e727a9b75059c4966eb10">dr_syscall_result_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#a80d0f026def74d903a83fb6122816ae2">dr_register_pre_syscall_event()</a>) or post-syscall (<a class="el" href="dr__events_8h.html#a7a62b6c11f3b0ae2fe7773189f6e4826">dr_register_post_syscall_event()</a>) event. For pre-syscall, should only be used when skipping the system call.</p>
<p>This sets the returned results of the system call as specified in <code>info</code>. Returns whether it successfully did so. See the fields of <a class="el" href="dr__tools_8h.html#afc574aa98b0e727a9b75059c4966eb10">dr_syscall_result_info_t</a> for details. </p>

</div>
</div>
<a id="ae66c42a269f48b13ed57609029e5202b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66c42a269f48b13ed57609029e5202b">&#9670;&nbsp;</a></span>dr_syscall_set_sysnum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_syscall_set_sysnum </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#a80d0f026def74d903a83fb6122816ae2">dr_register_pre_syscall_event()</a>) event, or from a post-syscall (<a class="el" href="dr__events_8h.html#a7a62b6c11f3b0ae2fe7773189f6e4826">dr_register_post_syscall_event()</a>) event when also using <a class="el" href="dr__tools_8h.html#aedb494e753b1a2f0e79cb4bd09700c3c">dr_syscall_invoke_another()</a>. Sets the system call number of the system call about to be invoked to <code>new_num</code>. </p>

</div>
</div>
<a id="a18d391b20559c1737c795f2ef1ba33d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d391b20559c1737c795f2ef1ba33d2">&#9670;&nbsp;</a></span>dr_thread_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void* dr_thread_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates <code>size</code> bytes of memory from DR's memory pool specific to the thread associated with <code>drcontext</code>. This memory is only guaranteed to be aligned to the pointer size: 8 byte alignment for 64-bit; 4-byte alignment for 32-bit. (The wrapped malloc() guarantees the more standard double-pointer-size.) </p>

</div>
</div>
<a id="aada5a5987fa20f96868c453cd9baacd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada5a5987fa20f96868c453cd9baacd3">&#9670;&nbsp;</a></span>dr_thread_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_thread_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees thread-specific memory allocated by <a class="el" href="dr__tools_8h.html#a18d391b20559c1737c795f2ef1ba33d2">dr_thread_alloc()</a>. <code>size</code> must be the same as that passed to <a class="el" href="dr__tools_8h.html#a18d391b20559c1737c795f2ef1ba33d2">dr_thread_alloc()</a>. </p>

</div>
</div>
<a id="a100ea691259a4eff5419e7b34245703d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100ea691259a4eff5419e7b34245703d">&#9670;&nbsp;</a></span>dr_thread_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_thread_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Current thread gives up its time quantum. </p>

</div>
</div>
<a id="ad390db9aee211b90323f5b06bda2e489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad390db9aee211b90323f5b06bda2e489">&#9670;&nbsp;</a></span>dr_trace_exists_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_trace_exists_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks to see that if there is a trace in the code cache at tag <code>tag</code>. </p>

</div>
</div>
<a id="ab74baccca7b783c29e11fe63c286c26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74baccca7b783c29e11fe63c286c26a">&#9670;&nbsp;</a></span>dr_trace_head_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_trace_head_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks to see if the fragment (or future fragment) with tag <code>tag</code> is marked as a trace head. </p>

</div>
</div>
<a id="ac922731194013612e4f4cb78075a2170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac922731194013612e4f4cb78075a2170">&#9670;&nbsp;</a></span>dr_track_where_am_i()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API void dr_track_where_am_i </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Should be called during process initialization. Requests more accurate tracking of the <a class="el" href="dr__defines_8h.html#a145cc4ecf7cf2041207f0382d50f9620">dr_where_am_i_t</a> value for use with <a class="el" href="dr__tools_8h.html#a9333e0dee46cc854228efab156ce98c5">dr_where_am_i()</a>. By default, if this routine is not called, DR avoids some updates to the value that incur extra overhead, such as identifying clean callees. </p>

</div>
</div>
<a id="a57669d0e147191660153b928eca7f09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57669d0e147191660153b928eca7f09b">&#9670;&nbsp;</a></span>dr_unlink_flush_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_unlink_flush_region </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush all fragments containing any code from the region [<code>start</code>, <code>start</code> + <code>size</code>). Control will not enter a fragment containing code from the region after this returns, but a thread already in such a fragment will finish out the fragment. This includes the current thread if this is called from a clean call that returns to the cache. This routine may only be called during a clean call from the cache, from a nudge event handler, or from a pre- or post-system call event handler. It may not be called from any other event callback. No locks can be held when calling this routine. Returns true if successful.</p>
<dl class="section note"><dt>Note</dt><dd>This routine may not be called from any registered event callback other than the nudge event, the pre- or post-system call events, the exception event, or the signal event; clean calls out of the cache may call this routine. </dd>
<dd>
This routine may not be called while any locks are held that could block a thread processing a registered event callback or cache callout. </dd>
<dd>
<a class="el" href="dr__tools_8h.html#a9a3f791ec0b8edddf607612c6804709f">dr_delay_flush_region()</a> has fewer restrictions on use, but is less synchronous. </dd>
<dd>
Use <code>size</code> == 1 to flush fragments containing the instruction at address <code>start</code>. A flush of <code>size</code> == 0 is not allowed. </dd>
<dd>
This routine is only available with either the -thread_private or -enable_full_api options. It is not available when -opt_memory is specified. </dd></dl>

</div>
</div>
<a id="a01d306d881c59488dd6ae41f392074af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d306d881c59488dd6ae41f392074af">&#9670;&nbsp;</a></span>dr_unmap_executable_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_unmap_executable_file </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unmaps a file loaded by <a class="el" href="dr__tools_8h.html#a192497da7670d454f6aae17d293f70b4">dr_map_executable_file()</a>. </p>

</div>
</div>
<a id="a3b63ba5945657da579f044daa01ba035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b63ba5945657da579f044daa01ba035">&#9670;&nbsp;</a></span>dr_unmap_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_unmap_file </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unmaps a portion of a file mapping previously created by <a class="el" href="dr__tools_8h.html#ac2885193f264131c620475894e3d1e1e">dr_map_file()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The base address to be unmapped. Must be page size aligned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size to be unmapped. All pages overlapping with the range are unmapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On Windows, the whole file will be unmapped instead. </dd></dl>

</div>
</div>
<a id="a684c0fc332a5e5aa11c28ad3d1a6ef57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684c0fc332a5e5aa11c28ad3d1a6ef57">&#9670;&nbsp;</a></span>dr_using_all_private_caches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_using_all_private_caches </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if all DynamoRIO caches are thread private. </p>

</div>
</div>
<a id="a4ab4b37f37e4ee13e5cbcc999edc561e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab4b37f37e4ee13e5cbcc999edc561e">&#9670;&nbsp;</a></span>dr_using_console()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_using_console </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the current standard error handle belongs to a legacy console window (viz., <code>cmd</code> on Windows 7 or earlier). DR's <a class="el" href="dr__tools_8h.html#aeb88b22ff95c29ae793b9d84e1b95275">dr_printf()</a> and <a class="el" href="dr__tools_8h.html#ae338685a241cfeae5f3d507ae9cff957">dr_fprintf()</a> do not work with such console windows unless <a class="el" href="dr__tools_8h.html#ab870ad4d34833368e16bd3f6e07ba624">dr_enable_console_printing()</a> is called ahead of time, and even then there are limitations detailed in <a class="el" href="dr__tools_8h.html#ab870ad4d34833368e16bd3f6e07ba624">dr_enable_console_printing()</a>. This routine may result in loading a private copy of kernel32.dll. </p><dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>

</div>
</div>
<a id="ad8c794ef952f9163ac3c4927aa859dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c794ef952f9163ac3c4927aa859dbf">&#9670;&nbsp;</a></span>dr_vfprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API ssize_t dr_vfprintf </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#ae338685a241cfeae5f3d507ae9cff957">dr_fprintf()</a> but exposes va_list. </p>

</div>
</div>
<a id="af763a8387187c98cf359f9819f300833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af763a8387187c98cf359f9819f300833">&#9670;&nbsp;</a></span>dr_vsnprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int dr_vsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a07fe87f7bf9560a45751064329bc8c12">dr_snprintf()</a> but exposes va_list. </p>

</div>
</div>
<a id="a81096100c4202f0ea841bb24667cabc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81096100c4202f0ea841bb24667cabc7">&#9670;&nbsp;</a></span>dr_vsnwprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API int dr_vsnwprintf </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a6dca11e2920892d292405c49695d4890">dr_snwprintf()</a> but exposes va_list. </p>

</div>
</div>
<a id="a9333e0dee46cc854228efab156ce98c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9333e0dee46cc854228efab156ce98c5">&#9670;&nbsp;</a></span>dr_where_am_i()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API <a class="el" href="dr__defines_8h.html#a145cc4ecf7cf2041207f0382d50f9620">dr_where_am_i_t</a> dr_where_am_i </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT void **&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="dr__defines_8h.html#a145cc4ecf7cf2041207f0382d50f9620">dr_where_am_i_t</a> value indicating in which area of code <code>pc</code> resides. This is meant for use with <a class="el" href="dr__tools_8h.html#ac74de1da117d9c807b986aeda2523dd9">dr_set_itimer()</a> for PC sampling for profiling purposes. If the optional <code>tag</code> is non-NULL and <code>pc</code> is inside a fragment in the code cache, the fragment's tag is returned in <code>tag</code>. It is recommended that the user of this routine also call <a class="el" href="dr__tools_8h.html#ac922731194013612e4f4cb78075a2170">dr_track_where_am_i()</a> during process initialization for more accurate results. </p>

</div>
</div>
<a id="a451ff3e57783acbfdf24c1e557145807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451ff3e57783acbfdf24c1e557145807">&#9670;&nbsp;</a></span>dr_write_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API ssize_t dr_write_file </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes <code>count</code> bytes from <code>buf</code> to file <code>f</code>. Returns the actual number written. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="adr__tools_8h_html_ae52f61049269c0531b66b8c41c69e09e"><div class="ttname"><a href="dr__tools_8h.html#ae52f61049269c0531b66b8c41c69e09e">dr_messagebox</a></div><div class="ttdeci">DR_API void dr_messagebox(const char *fmt,...)</div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:04:13 &nbsp; <img border=0 src="favicon.png">
</small></address>
